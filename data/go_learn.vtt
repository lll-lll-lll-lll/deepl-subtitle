WEBVTT
Kind: captions
Language: en

00:00:02.610 --> 00:00:06.649
So I wanted to start out with an introduction
to the go language itself. Now I know that

00:00:06.649 --> 00:00:10.690
this is much storied territory, but I have
to start somewhere. And this is going to serve

00:00:10.690 --> 00:00:15.620
as a stepping off point for us to go through
a survey of the entire go language, as well

00:00:15.620 --> 00:00:19.710
as hitting some of the key libraries along
the way. So the first thing that we need to

00:00:19.710 --> 00:00:23.660
know is that go is created by a small team
within Google. And that team was made up of

00:00:23.660 --> 00:00:28.540
Robert griesemer, Rob Pike, and Ken Thompson.
Now these guys have been around the software

00:00:28.540 --> 00:00:32.279
industry for a little while, for example,
Ken designed and implemented the first Unix

00:00:32.279 --> 00:00:36.540
operating system, as well as had a key role
in the development of Unicode. So when these

00:00:36.540 --> 00:00:40.730
guys got together and decided that they wanted
to create a language, we had a lot of talent

00:00:40.730 --> 00:00:45.030
in the room as soon as these guys got together.
But one of the questions that we need to understand

00:00:45.030 --> 00:00:49.750
is, why create a new language at all? Well,
to understand that, we have to look at the

00:00:49.750 --> 00:00:54.130
languages that are common inside of Google.
And that's the time that go is being designed,

00:00:54.130 --> 00:00:59.990
there were really three languages that were
key. The first is Python, then Java, and then

00:00:59.990 --> 00:01:06.250
C and c++. Now, each of these languages in
and of itself is very powerful. However, the

00:01:06.250 --> 00:01:10.460
go designers started to recognize that there
were some limitations that Google was running

00:01:10.460 --> 00:01:15.100
into, that might not be able to be fixed,
given the history and the designs of the existing

00:01:15.100 --> 00:01:20.600
languages. So for example, when we look at
Python, Python is very easy to use, but it's

00:01:20.600 --> 00:01:24.580
an interpreted language. And so it can be
a little bit difficult to run applications

00:01:24.580 --> 00:01:29.000
at Google scale that are based on Python,
it can certainly happen. But that is one of

00:01:29.000 --> 00:01:34.530
the challenges that you can run into in very
large Python implementations. Java is very

00:01:34.530 --> 00:01:39.590
quick, but its type system has become increasingly
complex over time. Now, this is a natural

00:01:39.590 --> 00:01:44.280
trend that a lot of languages go through.
They start out very simple, but it has additional

00:01:44.280 --> 00:01:48.900
use cases and additional features are layered
into the language, it becomes increasingly

00:01:48.900 --> 00:01:54.259
more difficult to navigate things C and c++
is quick as well. However, it suffers from

00:01:54.259 --> 00:01:59.909
a complex type system. And additionally, its
compile times are notoriously slow. Now, the

00:01:59.909 --> 00:02:04.950
type system has been receiving a lot of attention
lately in the C and c++ communities. However,

00:02:04.950 --> 00:02:09.910
they still have the burden of needing to manage
all that legacy code. And so similar to Java,

00:02:09.910 --> 00:02:16.540
it's very difficult for them to move past
the history that they have, because c++ applications

00:02:16.540 --> 00:02:20.590
written 10 years ago still need to compile
today. And the slow compile times are another

00:02:20.590 --> 00:02:26.900
legacy issue that C and c++ have inherited
as well. When C and c++ were designed computers

00:02:26.900 --> 00:02:32.069
had nowhere near as much memory as they do
today. So the decision was made to optimize

00:02:32.069 --> 00:02:36.430
the compilers to use a minimum amount of memory.
And one of the compromises that that brought

00:02:36.430 --> 00:02:41.209
about was the compile times can be a little
bit sluggish. In addition, all three of these

00:02:41.209 --> 00:02:46.379
languages were created in a time where multi
threaded applications were extremely rare.

00:02:46.379 --> 00:02:49.810
Almost every application that was created
really had to focus on a single thread at

00:02:49.810 --> 00:02:54.830
a time. So concurrency patterns built into
these languages are patched in at best. And

00:02:54.830 --> 00:02:59.860
so working in highly parallel, highly concurrent
applications like Google often runs into can

00:02:59.860 --> 00:03:04.910
be a little bit challenging when working in
these three languages. So enter go, What does

00:03:04.910 --> 00:03:09.100
go bring to the party in order to address
some of these concerns? Well, the first thing

00:03:09.100 --> 00:03:13.130
that we need to understand is gozi, strong
and statically typed language, so it inherits

00:03:13.130 --> 00:03:19.660
that same feature set from Java and c++. So
what do we mean by strong and statically typed

00:03:19.660 --> 00:03:24.660
with strong typing means that the type of
a variable cannot change over time. So when

00:03:24.660 --> 00:03:29.250
you declare a variable a to hold an integer,
it's always going to hold an integer, you

00:03:29.250 --> 00:03:33.390
can't put a Boolean in it, you can't put a
string in it. And static typing means that

00:03:33.390 --> 00:03:37.600
all of those variables have to be defined
at compile time. Now, are there ways around

00:03:37.600 --> 00:03:43.050
that? Yes, go does have features that allow
you to get around its type system, but 99%

00:03:43.050 --> 00:03:46.610
of the time, you're going to be living in
a world that's strong and statically typed.

00:03:46.610 --> 00:03:49.930
And getting all the benefits that come with
that. Now, if you come from languages such

00:03:49.930 --> 00:03:53.879
as Java, then you might be a little concerned
that strong and statically typed languages

00:03:53.879 --> 00:03:58.170
tend to be a little bit verbose. Well, we'll
see as we get into some go syntax, how there's

00:03:58.170 --> 00:04:02.519
been a lot of effort taken to make the compiler
do as much work to understand what you're

00:04:02.519 --> 00:04:06.830
talking about with a variable. So you don't
have to explain to the compiler every time

00:04:06.830 --> 00:04:10.470
what your variable types and things like that
are.

00:04:10.470 --> 00:04:15.830
In addition, go like a lot of recent languages
has a strong focus on the community that supporting

00:04:15.830 --> 00:04:20.939
it. Just because go is an excellent language
does not guarantee success. Because there

00:04:20.939 --> 00:04:25.639
are so many languages out there, that it can
become difficult for a new developer to ramp

00:04:25.639 --> 00:04:31.330
up in any one. As a result, there's a strong
community built up around go that's really

00:04:31.330 --> 00:04:35.580
focused on making sure that the go language
keeps moving forward, and that new developers

00:04:35.580 --> 00:04:40.110
have an easier time as possible ramping up
onto the language. So what are some of the

00:04:40.110 --> 00:04:45.370
key features of the language itself? One of
the first and I would argue most important

00:04:45.370 --> 00:04:51.089
features that go has is a recognition that
simplicity is a feature. So as we go through

00:04:51.089 --> 00:04:54.469
and start learning about the go language,
you're going to run into some features and

00:04:54.469 --> 00:04:58.969
you're going to ask yourself, Well, why doesn't
this exist? Or why don't we have that feature?

00:04:58.969 --> 00:05:03.659
And a lot of the reasons Come back to this
feature. There's a recognition that if the

00:05:03.659 --> 00:05:09.099
go language recognizes simplicity is important,
then that means that we're going to have to

00:05:09.099 --> 00:05:14.199
decide to leave out some other features that
might be very useful, but would add complexity

00:05:14.199 --> 00:05:19.479
to the language. Additionally, go focuses
on extremely fast compile times a lot of modern

00:05:19.479 --> 00:05:24.330
development environments to write code fast
to build it fast and to test it fast and get

00:05:24.330 --> 00:05:28.729
feedback back to the developer as quick as
possible. Well, if you've got a 45 minute

00:05:28.729 --> 00:05:34.349
compile time, it breaks that cycle. And developers
have a very hard time staying in that design

00:05:34.349 --> 00:05:40.229
build test loop. And so go focuses on keeping
those compile times down, even though it's

00:05:40.229 --> 00:05:44.740
going to yield us fully compiled binaries
at the end, go as a garbage collected language,

00:05:44.740 --> 00:05:48.369
which means that you're not going to have
to manage your own memory. Now you can manage

00:05:48.369 --> 00:05:52.680
your own memory. But by and large, the go
runtime is going to manage that for you. And

00:05:52.680 --> 00:05:57.059
the reason for that gets back to this simplicity
argument, there is a recognition that a garbage

00:05:57.059 --> 00:06:01.249
collected language does have challenges when
dealing with certain use cases. For example,

00:06:01.249 --> 00:06:05.279
real time trading systems for stock market
systems have a very hard time when you're

00:06:05.279 --> 00:06:09.539
dealing with garbage collection. However,
the advantages on the developer of not having

00:06:09.539 --> 00:06:13.679
to manage their own memory all the time, were
deemed to be more important. Now, that doesn't

00:06:13.679 --> 00:06:18.449
mean that the delays that a garbage collector
incurs haven't been paid attention to, if

00:06:18.449 --> 00:06:21.449
you go back through the history of the go
language, you'll actually see the past few

00:06:21.449 --> 00:06:26.159
versions have had a huge emphasis on reducing
the amount of time that the application has

00:06:26.159 --> 00:06:30.350
to pause during a garbage collection cycle.
And at this point, they're actually really

00:06:30.350 --> 00:06:34.569
fast, almost to the point that you don't know
that a garbage collection happened, in order

00:06:34.569 --> 00:06:39.300
to address that concern of concurrency go
does have concurrency primitives built right

00:06:39.300 --> 00:06:42.860
into the language. And we'll talk about that
as we go through some of these videos. But

00:06:42.860 --> 00:06:47.029
instead of having a library that we're going
to have to import, in order to work with concurrency,

00:06:47.029 --> 00:06:51.879
we're going to be able to do concurrent development
right there in the base language. Finally,

00:06:51.879 --> 00:06:57.680
go compiles down to a standalone library,
which means when you compile your go application,

00:06:57.680 --> 00:07:01.490
everything is going to be bundled into that
single binary that's related to the go application

00:07:01.490 --> 00:07:06.030
itself. So the go runtime is going to be bundled
in there, any libraries that you're depending

00:07:06.030 --> 00:07:09.649
on, they're going to be compiled in there.
So you don't have to worry about reaching

00:07:09.649 --> 00:07:14.001
out to external libraries and DLLs, and things
like that in order to make your application

00:07:14.001 --> 00:07:20.150
work. And what that gives you is version management
at runtime becomes trivial. Because you simply

00:07:20.150 --> 00:07:25.050
have one binary, you deploy that binary, you
run it, and all of its dependencies are there.

00:07:25.050 --> 00:07:28.529
Now keep in mind, when I say dependencies,
I mean to go dependencies, if you're going

00:07:28.529 --> 00:07:33.169
to build a web application that has HTML,
resources, and CSS, those have to be bundled

00:07:33.169 --> 00:07:38.159
along with the binary, but the binary itself
is standalone and self contained. Okay, the

00:07:38.159 --> 00:07:41.339
next thing that I'd like to do is show you
some of the resources that are available to

00:07:41.339 --> 00:07:45.319
you, as you start to explore the go language.

00:07:45.319 --> 00:07:48.930
One of the most useful resources that you're
going to be able to take advantage of as you're

00:07:48.930 --> 00:07:55.139
ramping up on go, is goes website here@golang.org.
Now, why is it go lang.org? Well, if you take

00:07:55.139 --> 00:07:59.239
a minute to think about a language called
go, that doesn't really lend itself to unique

00:07:59.239 --> 00:08:03.909
search results in Google or Bing. So go lang.org
it is, as a matter of fact, a lot of places

00:08:03.909 --> 00:08:08.180
that you see go mentioned, you're gonna see
it actually described as go Lang, because

00:08:08.180 --> 00:08:11.729
that makes it a little bit more unique when
you're looking for search results. So the

00:08:11.729 --> 00:08:15.229
first thing that you might notice, as we go
into the homepage here is this isn't really

00:08:15.229 --> 00:08:19.599
laid out like a lot of traditional home pages.
This, in my opinion, is very much an engineering

00:08:19.599 --> 00:08:23.939
homepage. So instead of a lot of design aesthetic,
this gets right into the engineering aspects

00:08:23.939 --> 00:08:28.680
and shows you how to start working with the
language. So this yellow box over here is

00:08:28.680 --> 00:08:32.539
going to be your entry point for your first
go application. So if we go ahead and click

00:08:32.539 --> 00:08:37.479
this run button, you see that we almost instantly
get an application sent back to the server,

00:08:37.479 --> 00:08:41.889
it gets compiled, and it gets run for us.
So we can start playing around with go code

00:08:41.889 --> 00:08:45.459
without installing anything on our local machines.
And we're actually going to take advantage

00:08:45.459 --> 00:08:49.260
of that through this first few videos. As
a matter of fact, if I make a small change

00:08:49.260 --> 00:08:56.300
here, so maybe if I will say, Hello, YouTube
peoples and run that again, then I'm saying

00:08:56.300 --> 00:09:01.250
hello to y'all, so Hi. So it's as simple as
that in order to get started with the go program.

00:09:01.250 --> 00:09:05.990
Beside that window, we see this download GO
button. And that's going to take you to resources

00:09:05.990 --> 00:09:09.470
that you're going to be able to use in order
to download the latest go binaries, as well

00:09:09.470 --> 00:09:13.899
as download older versions of the runtime.
And if there's an unpublished version, for

00:09:13.899 --> 00:09:18.470
example, at the time I'm recording this go
1.8 is at RC two, you can go ahead and download

00:09:18.470 --> 00:09:22.410
that install that and check that for bugs
and play around with new features in the language.

00:09:22.410 --> 00:09:25.779
If we come across at the top, we see this
documents link here. And this is going to

00:09:25.779 --> 00:09:29.209
be another critical resource as you're starting
out with the language. As a matter of fact,

00:09:29.209 --> 00:09:33.610
you're going to refer back to this page quite
often. But if you really want to walk through

00:09:33.610 --> 00:09:37.210
on the website, a tour of the go languages,
and I would recommend you go to this Getting

00:09:37.210 --> 00:09:41.399
Started link. This is going to get you started
downloading and installing the go compilers

00:09:41.399 --> 00:09:45.029
and tools and things like that. And you can
see as we navigate there, it's going to show

00:09:45.029 --> 00:09:48.420
you the different architectures that you're
going to be able to use with go and there's

00:09:48.420 --> 00:09:52.810
quite a few and how to get started on each
one of those. If we keep continuing down the

00:09:52.810 --> 00:09:57.970
tour of go is kind of an introduction to the
go language that takes you through a gradual

00:09:57.970 --> 00:10:01.649
introduction. So it's going to start out with
some very simple Apple And then build up more

00:10:01.649 --> 00:10:05.300
and more and more and help you understand
what's going on with go concurrency and things

00:10:05.300 --> 00:10:11.440
like that. Effective go is a very useful article,
especially as you start to mature in your

00:10:11.440 --> 00:10:15.959
understanding of the language, and really
understand how the go language is used. So

00:10:15.959 --> 00:10:18.189
I would encourage you to go into that it's
a pretty lengthy

00:10:18.189 --> 00:10:21.490
read. But you should consider this required
reading if you're actually going to start

00:10:21.490 --> 00:10:24.910
building non trivial go applications. But
we're not going to worry about that right

00:10:24.910 --> 00:10:28.930
now. We got plenty ways to go before we need
to get through all of this stuff. And then

00:10:28.930 --> 00:10:32.600
down here at the bottom is some reference
information. This is more advanced documentation

00:10:32.600 --> 00:10:36.399
that you're probably not going to need right
away. But for example, the command documentation

00:10:36.399 --> 00:10:40.270
gives you a lot of information about the go
tool itself that you're going to use for local

00:10:40.270 --> 00:10:44.000
development with go, there's a lot of things
that the go program does. And this is going

00:10:44.000 --> 00:10:49.070
to help you understand how to navigate that.
The packages link is perhaps where I spend

00:10:49.070 --> 00:10:53.250
the most time on gos website. And this gives
you documentation for all of the libraries

00:10:53.250 --> 00:10:57.800
that are built into go. So when you install
go and you install the go binaries and tools,

00:10:57.800 --> 00:11:01.240
you're going to get all of these libraries
available to you. So just scanning down, you

00:11:01.240 --> 00:11:05.170
can see that we've got different libraries
that are targeted at working with archives,

00:11:05.170 --> 00:11:09.439
we've got some cryptography libraries, database
drivers, continuing to go down, we've got

00:11:09.439 --> 00:11:14.110
some things for working with HTML, and network
traffic. Now, some things that you might find

00:11:14.110 --> 00:11:19.360
missing here are we don't have any GUI libraries.
That's because at this point go really isn't

00:11:19.360 --> 00:11:24.560
focused on the use case of client application
development. So go is really targeted at building

00:11:24.560 --> 00:11:28.420
servers and web applications. And so that's
where a lot of the libraries are going to

00:11:28.420 --> 00:11:33.399
be focused on. There are some projects that
are working on mobile applications using go

00:11:33.399 --> 00:11:37.009
as well as client side applications using
go but they're not officially supported at

00:11:37.009 --> 00:11:40.970
this point. If we come over to the project
link, we're going to find some information

00:11:40.970 --> 00:11:46.019
about history of the project, what releases
have come out and when, as well as some links

00:11:46.019 --> 00:11:51.070
to mailing lists and resources that you can
take advantage of. If you want to keep track

00:11:51.070 --> 00:11:56.490
of the development of go as a language as
well as if you find an issue in the go language,

00:11:56.490 --> 00:11:59.940
you can see some information here on how to
report that issue. And then we've got the

00:11:59.940 --> 00:12:03.230
Help link here. And this is going to be one
of your more important links as you get started

00:12:03.230 --> 00:12:07.370
here because this is going to be your on ramp
into the community. Now the two most active

00:12:07.370 --> 00:12:11.899
in my experience are the go forum, which is
a nice discussion forum that allows you to

00:12:11.899 --> 00:12:15.720
post your questions and get people to answer
back. But if you want something a little bit

00:12:15.720 --> 00:12:20.939
more real time then the gopher slack is a
Slack channel specifically targeted at NGO

00:12:20.939 --> 00:12:25.910
development. And there's multiple sub channels
in there for new developers for library developers.

00:12:25.910 --> 00:12:30.210
Even a lot of the NGO meetup groups have their
own sub channels on the gopher slack. So if

00:12:30.210 --> 00:12:33.889
you want to get on the gopher slack that I
would encourage you to come over here to another

00:12:33.889 --> 00:12:39.269
website called go Lang bridge. And this is
what I consider the on ramp to the NGO community.

00:12:39.269 --> 00:12:43.709
Because NGO Lang bridge is specifically there
to advocate for the go language, and to make

00:12:43.709 --> 00:12:47.730
sure that the community is healthy and strong.
As I said, one of the key aspects of the go

00:12:47.730 --> 00:12:52.509
language is a focus on having an excellent
community. And really, it's go Lang bridge

00:12:52.509 --> 00:12:57.040
and the awesome people that support it, that
are making that happen. So if you scroll down

00:12:57.040 --> 00:13:00.790
a little bit, you can see some links to the
online communities. If you want to join the

00:13:00.790 --> 00:13:04.839
Slack channel, you do have to receive an invite.
So this link here is going to take you to

00:13:04.839 --> 00:13:08.819
the forum that's going to allow you to get
that invitation. And there's no problem getting

00:13:08.819 --> 00:13:12.120
the invitation, the only thing that they asked
you is to read the community guidelines, there

00:13:12.120 --> 00:13:15.690
is a code of conduct that just make sure that
everybody is going to be treated respectfully

00:13:15.690 --> 00:13:19.290
in the community, just to make sure that we're
all here trying to help each other out. And

00:13:19.290 --> 00:13:23.050
the last thing that I want to show you on
the website is this play link here. Now this

00:13:23.050 --> 00:13:27.269
link just flies out an editor. And this is
really nice, because this is available throughout

00:13:27.269 --> 00:13:34.269
the site. So if I come to the packages, and
let's just say I dive into the network package,

00:13:34.269 --> 00:13:37.959
and I'm learning about some network function,
then I can go ahead and pop into the play,

00:13:37.959 --> 00:13:41.999
I can create a real quick proof of concept
go application in order to make sure that

00:13:41.999 --> 00:13:45.699
I understand how that's working. And again,
just like we saw on that homepage, if I click

00:13:45.699 --> 00:13:50.559
run that I can go ahead and execute that.
Now there are some limitations, obviously,

00:13:50.559 --> 00:13:54.029
this application is sent to the back end.
And there are some limitations, you're not

00:13:54.029 --> 00:13:56.850
gonna be able to read the file system at the
back end, for example.

00:13:56.850 --> 00:13:59.970
But a lot of the things that you want to play
around with, you can play around with in this

00:13:59.970 --> 00:14:05.940
online environment. Now another place to get
at this playground is over here at play that

00:14:05.940 --> 00:14:10.439
golang.org. And this is the last thing I want
to show you in this introductory video. So

00:14:10.439 --> 00:14:13.329
this is going to be the environment that we're
going to focus on. And actually, let me make

00:14:13.329 --> 00:14:16.600
that a little bit bigger. So maybe it's a
little easier for you to see. But this is

00:14:16.600 --> 00:14:20.089
going to be the environment that we're going
to focus on as we start to learn the go language.

00:14:20.089 --> 00:14:23.519
So we're going to learn the basics of go application
here, we're going to start playing around

00:14:23.519 --> 00:14:27.100
with how we're going to work with variables
and logic and looping and things like that.

00:14:27.100 --> 00:14:31.041
Now, eventually, we'll get to installing a
local environment. And you can certainly take

00:14:31.041 --> 00:14:34.889
advantage of the other resources on go Lang
website, if you want to get there before I

00:14:34.889 --> 00:14:39.010
create a video on it. But I think that there's
a lot that we can talk about without making

00:14:39.010 --> 00:14:43.290
a commitment to setting up a local development
environment by just going through this playground

00:14:43.290 --> 00:14:47.310
here. So if we take a second look at this
application, we see some of the key aspects

00:14:47.310 --> 00:14:51.930
of any go program. And the first thing that
you see at the top is this statement package

00:14:51.930 --> 00:14:56.949
main. Every go application is structured into
packages. So every go file that you're going

00:14:56.949 --> 00:15:02.269
to have is going to have to declare what package
it's a part of nain is a special package,

00:15:02.269 --> 00:15:07.120
because main is going to be the entry point
of any one of your applications. Down below

00:15:07.120 --> 00:15:11.221
that we have an import statement. And this
is the statement that we're going to use in

00:15:11.221 --> 00:15:16.259
order to import additional libraries. So this
library is called thumped, which Yeah, you

00:15:16.259 --> 00:15:19.810
actually say that in the NGO community, I
can't bring myself to say that. So if I call

00:15:19.810 --> 00:15:23.759
that FMT, I hope that you'll forgive me. But
in the NGO community, you will often hear

00:15:23.759 --> 00:15:28.610
this called thumped. And this is the package
is going to allow us to format strings. So

00:15:28.610 --> 00:15:33.649
you see down below here and our main function,
which is the entry point of our application,

00:15:33.649 --> 00:15:37.970
so the main function in the main package is
always going to be our application entry point.

00:15:37.970 --> 00:15:40.509
And this is going to be where we're going
to contain our first code that's going to

00:15:40.509 --> 00:15:45.759
run in go. So we're going to call into the
FMT library. And we're going to pull out its

00:15:45.759 --> 00:15:50.309
print ln function, and that print ln function
takes one argument, and that argument in this

00:15:50.309 --> 00:15:54.480
case is a string. So we're going to print
out Hello playground. Now if I go ahead and

00:15:54.480 --> 00:15:58.569
run this, then down below at the bottom of
the screen, here, you see Hello, playground

00:15:58.569 --> 00:16:03.209
gets printed out. And then it says program
exited. If we have an error in the application,

00:16:03.209 --> 00:16:07.629
say if I delete this quotation mark and run,
then you're going to get a compiler error

00:16:07.629 --> 00:16:11.779
printed out at the bottom, that's going to
help you debug your application. So this online

00:16:11.779 --> 00:16:15.319
environments going to be very good for you
to get started, because it's going to help

00:16:15.319 --> 00:16:19.790
you through understanding what's going on.
So for example, we see here in line eight,

00:16:19.790 --> 00:16:24.689
it got an unexpected semi colon or new line,
when instead it was expecting a comma or a

00:16:24.689 --> 00:16:28.480
parenthesis. And the reason for that is because
this closing parenthesis actually became part

00:16:28.480 --> 00:16:32.499
of the string. So the line terminated early,
and it didn't have an end to the function

00:16:32.499 --> 00:16:37.360
call. So if we go ahead and re add the quotation
mark, and run, we're good to go. And we've

00:16:37.360 --> 00:16:42.879
got our first start in a go application. So
I hope that this was helpful for you a little

00:16:42.879 --> 00:16:45.990
bit of background in a language that you're
going to be learning I always find is a little

00:16:45.990 --> 00:16:50.490
bit valuable, it helps to understand the motivations
for the creation of the language and the major

00:16:50.490 --> 00:16:54.870
features, in order to understand what problems
that language is going to try and solve and

00:16:54.870 --> 00:17:01.949
how it's going to go about trying to solve
them. What I want to show you is how to get

00:17:01.949 --> 00:17:07.069
started setting up your own local development
environment to program with go. Now I know

00:17:07.069 --> 00:17:11.689
in the last video, I showed you this website
here, and I said that this is what I want

00:17:11.689 --> 00:17:16.589
to use. That is the website it played@golang.org.
And I said that this is the website that I

00:17:16.589 --> 00:17:20.010
want to use in order to show you a lot of
concepts that you're going to need to be familiar

00:17:20.010 --> 00:17:24.939
with with the go language. And that's still
my plan. But as I thought about it, I decided

00:17:24.939 --> 00:17:28.890
that it doesn't really make sense to force
you to use the playground, just because it's

00:17:28.890 --> 00:17:33.159
a really good place for me to demonstrate
concepts. So I want you to have all the tools

00:17:33.159 --> 00:17:37.309
available to you to set up your own local
NGO development environment. So you can play

00:17:37.309 --> 00:17:41.980
around with creating your own applications
as you learn about this wonderful language.

00:17:41.980 --> 00:17:44.550
So the first thing that we're going to need
to do is we're going to need to download and

00:17:44.550 --> 00:17:49.050
install the go language in the go tools itself.
And so in order to get started with that,

00:17:49.050 --> 00:17:52.550
we're going to start over here@golang.org.
And we're going to click on this download

00:17:52.550 --> 00:17:54.350
go link here.

00:17:54.350 --> 00:17:58.179
Now this link is going to take you to all
sorts of different versions of go. But in

00:17:58.179 --> 00:18:01.770
general, if you're getting started, just pick
the latest stable version that's available

00:18:01.770 --> 00:18:05.850
for you, and it's not going to steer you wrong.
Now, if you're a Windows user, then I would

00:18:05.850 --> 00:18:09.750
encourage you to click this MSI link, it's
going to download an installer and go is going

00:18:09.750 --> 00:18:14.960
to be put on your system automatically. However,
if you're using os 10, or Linux, then I would

00:18:14.960 --> 00:18:19.659
recommend that you go to this installation
instructions link here and follow the instructions

00:18:19.659 --> 00:18:23.549
here. Now, you're still going to need to download
the go binaries. But if you scroll down just

00:18:23.549 --> 00:18:26.770
a little bit, you're going to see this command
here. And this is going to give you the tar

00:18:26.770 --> 00:18:30.840
command that you're going to need to use in
order to unpack the go binary and install

00:18:30.840 --> 00:18:35.490
it onto your system. So I've already done
that. And I can show you that by opening up

00:18:35.490 --> 00:18:40.510
a terminal here. And the default location
to put go is in the user directory underneath

00:18:40.510 --> 00:18:46.429
local and then in a folder called go. So if
we look at there, and they look at the contents

00:18:46.429 --> 00:18:50.810
there, I see that I have all the go tools
installed. So with the Windows Installer,

00:18:50.810 --> 00:18:54.630
all it's going to do is it's going to place
these into C colon backslash go. And I would

00:18:54.630 --> 00:18:58.539
strongly encourage you if you can accept these
default locations that you go ahead and do

00:18:58.539 --> 00:19:02.169
that because it's going to make setting up
your environment just a little bit simpler.

00:19:02.169 --> 00:19:06.110
Now after we get go installed, we have a little
bit of configuration in our environment in

00:19:06.110 --> 00:19:10.279
order to be able to use go effectively. So
I'm going to come back to my home directory

00:19:10.279 --> 00:19:15.980
here. And I'm going to make a change to my
bash RC file. Now I'm on Ubuntu. So it's going

00:19:15.980 --> 00:19:20.070
to be in my bash RC file. If you're an LS
10, it's going to be your bash profile. If

00:19:20.070 --> 00:19:24.470
you're in Windows, basically what we're doing
is we're setting environment variables. So

00:19:24.470 --> 00:19:28.130
if I open that up and come down to the bottom,
then I see that I've got the pre generated

00:19:28.130 --> 00:19:31.770
bash script. I'm not going to really worry
about that. But there's a couple of variables

00:19:31.770 --> 00:19:38.220
that we're going to need to set. Hello, everybody,
I need to pause the video here for a second

00:19:38.220 --> 00:19:42.309
and make an important announcement. So as
soon as I originally released this video,

00:19:42.309 --> 00:19:46.050
Dave cainy came in within a couple of minutes
and he expressed a concern about one of the

00:19:46.050 --> 00:19:50.460
things that I'm about to talk about. Now I'm
about to talk about setting a couple of environment

00:19:50.460 --> 00:19:55.760
variables here and showing you how they work.
Now one of those variables is called go route.

00:19:55.760 --> 00:20:00.110
And setting go route has been shown to cause
problems as you move through different versions.

00:20:00.110 --> 00:20:05.240
Go, especially if you've got multiple versions
of the language on your system. So if you

00:20:05.240 --> 00:20:08.790
want more information about that Dave has
a really good blog post here that you can

00:20:08.790 --> 00:20:13.490
go to to learn more information about it.
But for now, please keep in mind, if you're

00:20:13.490 --> 00:20:18.370
able to install go at its default locations,
which on Unix or Mac is going to be slash

00:20:18.370 --> 00:20:23.970
user slash local slash go in on Windows is
going to be C colon, backslash go. If you're

00:20:23.970 --> 00:20:28.690
able to do that, please do that. And then
go ahead and avoid setting go route. Now you

00:20:28.690 --> 00:20:34.049
will need to set the PATH variable to go roots
bin directory in order to access the go executable.

00:20:34.049 --> 00:20:38.110
And you will need to set go path which we're
going to talk about after that. But if you

00:20:38.110 --> 00:20:41.029
can avoid setting the go route environment
variable, it's going to save you a lot of

00:20:41.029 --> 00:20:44.620
heartache. So well, I'm going to show you
how to do that in case you do need to set

00:20:44.620 --> 00:20:49.220
it please avoid that if at all possible. Okay,
at this point, I'm going to resume the video

00:20:49.220 --> 00:20:53.660
and continue talking about the environment
setup. Now the first variable that you're

00:20:53.660 --> 00:20:58.240
going to need to know about is called go route.
Now, if you've installed go to its default

00:20:58.240 --> 00:21:01.750
location, you're not going to need to worry
about this. But if you've decided to install

00:21:01.750 --> 00:21:05.789
go somewhere else, for example, maybe you've
installed it in your home directory, then

00:21:05.789 --> 00:21:09.961
you can go ahead and set go route. And that'll
tell the environment where to go to find the

00:21:09.961 --> 00:21:14.880
go binaries. Now the next thing that we want
to do is we actually want to set a PATH variable

00:21:14.880 --> 00:21:20.200
to the go binaries themselves. So I'm going
to go ahead and export a PATH variable. And

00:21:20.200 --> 00:21:25.149
that'll Of course, start with my existing
path. And then I'm going to add on to that

00:21:25.149 --> 00:21:30.010
go route. And then I'm going to whack on the
path slash bin. So there's quite a few binaries

00:21:30.010 --> 00:21:34.140
that we're going to be using on a regular
basis. And those are in go route slash bin,

00:21:34.140 --> 00:21:37.130
so you're going to want to make sure that
that's part of your path. Now once I do that,

00:21:37.130 --> 00:21:43.480
let me go ahead and save this. And then I
will use the source command in order to get

00:21:43.480 --> 00:21:48.679
my shell to reread the bash RC file. And then
I should be able to test to make sure it goes

00:21:48.679 --> 00:21:54.071
available by typing go and version. And you
can see here I'm running go version 1.8 release

00:21:54.071 --> 00:21:55.390
candidate three.

00:21:55.390 --> 00:21:59.309
Okay, now there's one more thing that we need
to do in order to get our environment fully

00:21:59.309 --> 00:22:04.730
set up. And I'm going to go back into my bash
RC file in order to do that. And that is the

00:22:04.730 --> 00:22:08.610
setting of a second environment variable.
So we have go route. And that's going to tell

00:22:08.610 --> 00:22:12.780
the environment where goes installed. But
we're also going to be downloading a lot of

00:22:12.780 --> 00:22:17.169
packages as we work with go, because we're
going to be taking advantage of libraries

00:22:17.169 --> 00:22:21.159
that other people have published in order
to build our own applications out. So those

00:22:21.159 --> 00:22:25.799
applications as well as our own source code
are not going to be located with the go binaries,

00:22:25.799 --> 00:22:29.840
they're going to be located in a path that
we're going to specify with a another variable

00:22:29.840 --> 00:22:34.230
called go path. Now go path is either one
of the most awesome or one of the most horrible

00:22:34.230 --> 00:22:39.190
things about go because it gives you this
really nice way to specify where you go projects

00:22:39.190 --> 00:22:44.860
are located. However, it does kind of push
you towards having this monolithic repository

00:22:44.860 --> 00:22:48.929
of all these binaries and your applications
tied together. So I'll show you a little bit

00:22:48.929 --> 00:22:53.789
of a hint on how to work with that. But for
now, let's go ahead and set a go PATH variable

00:22:53.789 --> 00:22:58.370
in my home directory. And then I will call
this go lib. Now just like with go route,

00:22:58.370 --> 00:23:02.910
we might have some executable binaries that
are going to be stored in our gopath. So I'm

00:23:02.910 --> 00:23:07.900
going to go ahead and export on our path again.
And we'll start with our existing path. And

00:23:07.900 --> 00:23:13.409
then I want to add on go path slash bin. That
way if we install any libraries that have

00:23:13.409 --> 00:23:17.250
executables, and we will be installing libraries
that have executables, then we're going to

00:23:17.250 --> 00:23:20.470
be able to track that. Now just to show you
real quick what that's going to do. Let me

00:23:20.470 --> 00:23:27.110
go ahead and save this out resource, my bash
RC file. And then I've actually already created

00:23:27.110 --> 00:23:31.429
this folder here called go live. Now if I
go into go lib, and I look at the contents

00:23:31.429 --> 00:23:37.230
of that it's currently empty. But I can change
that by using a tool called go get. So if

00:23:37.230 --> 00:23:43.799
I get a library that's at github.com slash
NSF slash go code. This is historically the

00:23:43.799 --> 00:23:48.770
library that people use to provide autocomplete
functionality in their go applications. So

00:23:48.770 --> 00:23:56.200
if I go ahead and hit Enter, and wait a second,
then go back into my go lib folder. And look,

00:23:56.200 --> 00:24:00.760
now I've got some content here. So if I look
in the bin directory, I've got this go code

00:24:00.760 --> 00:24:06.600
executable. And if I come back to the source
directory, then I see that I've got this GitHub

00:24:06.600 --> 00:24:12.920
comm folder. And inside of that is NSF. And
inside of that is go code. So if I come in

00:24:12.920 --> 00:24:17.500
here, here's all of the source code for the
go code library. So when I'm working with

00:24:17.500 --> 00:24:21.610
go code, it actually downloads the source
code and compiles it into the go code library

00:24:21.610 --> 00:24:25.410
for me. And that's what that go path is going
to do for you. The problem that you might

00:24:25.410 --> 00:24:30.779
run into is that this use of gopath tends
to drive towards monolithic repository. So

00:24:30.779 --> 00:24:33.090
you're going to have go code, you're going
to have your own code, you're going to have

00:24:33.090 --> 00:24:38.870
all sorts of other libraries, all put into
this one location. Now when I create my courses,

00:24:38.870 --> 00:24:42.889
that creates a lot of visual clutter. And
so that isn't exactly the form of gopath that

00:24:42.889 --> 00:24:48.740
I use. What I do is coming back into my bash
RC file is I actually use a capability of

00:24:48.740 --> 00:24:54.330
gopath to create a compound gopath. So instead
of a single path here, I'm actually going

00:24:54.330 --> 00:24:59.529
to re export go path and I'm going to add
on an additional path to this and I'm going

00:24:59.529 --> 00:25:04.750
to add Home mic and code. Now a lot of times
when I'm teaching courses, I only need to

00:25:04.750 --> 00:25:08.440
go pants. And so I've got go live. And that's
going to be where all my third party libraries

00:25:08.440 --> 00:25:12.789
go. And then I'm going to have another folder,
that's going to be what's called by workspace

00:25:12.789 --> 00:25:18.049
location. So let's go ahead and write this
out. We'll source this again. And now I've

00:25:18.049 --> 00:25:23.440
got the full gopath. So if I come into my
NGO lib, and I remove everything from it,

00:25:23.440 --> 00:25:30.170
now it's empty again. So if I go ahead and
go get that repository, again@github.com slash

00:25:30.170 --> 00:25:35.370
NSF slash go code. And now you see that it
actually goes into my go lib folder. If I

00:25:35.370 --> 00:25:40.889
come into my code folder, which I also created
earlier, that's still empty. So the first

00:25:40.889 --> 00:25:45.470
segment of your go path is going to be used
by go get in order to store your files, but

00:25:45.470 --> 00:25:49.950
all of the segments of your go path are going
to be searched for source code. So that's

00:25:49.950 --> 00:25:55.350
going to really help us as we're setting up
our workspace. So speaking of which, that's

00:25:55.350 --> 00:26:00.820
the next thing that I want to do. So a workspace
in go isn't anything special, the only thing

00:26:00.820 --> 00:26:05.930
that you need in order to create a workspace
is to have a single directory called SRC in

00:26:05.930 --> 00:26:11.670
it. So if I add a directory called SRC into
my code folder, then I've got to go workspace.

00:26:11.670 --> 00:26:15.580
Now SRC, as you might expect, is where you're
going to keep your source code. So when I

00:26:15.580 --> 00:26:21.419
set go path to slash home slash Mike slash
code, it's going to look for an SRC directory

00:26:21.419 --> 00:26:25.429
in order to find my source code. Now, there
are two other directories that you might find

00:26:25.429 --> 00:26:29.730
in a workspace that are interesting. And we
found one already when we installed that go

00:26:29.730 --> 00:26:34.410
code library. And that's been. So anytime
we're working with a project and a binary

00:26:34.410 --> 00:26:38.429
is created, it's going to be put into that
bin directory. And that's also why we added

00:26:38.429 --> 00:26:40.080
that bin segment to our path,

00:26:40.080 --> 00:26:45.090
the last directory that you might find in
your workspace is a pkg directory. So for

00:26:45.090 --> 00:26:49.130
compiling something, and it's going to generate
an intermediate binary, which means it's not

00:26:49.130 --> 00:26:53.250
going to be a fully compiled application,
it's going to be an intermediate step. So

00:26:53.250 --> 00:26:57.660
for example, if we're taking a third party
library, and we're integrating that into our

00:26:57.660 --> 00:27:01.450
application, then the pkg directory is where
those intermediate binaries are going to be

00:27:01.450 --> 00:27:05.750
stored. And the reason those are created is
so that they don't have to be recompiled every

00:27:05.750 --> 00:27:10.720
time. So when you compile your go application,
go is going to check to see if any of the

00:27:10.720 --> 00:27:15.310
source files in that directory have changed
since the last time it compiled them. If it

00:27:15.310 --> 00:27:18.450
hasn't, then it's not going to recompile that
package, it's just going to go ahead and link

00:27:18.450 --> 00:27:22.570
them into the binary that it's creating for
you. Okay, so let's go ahead and clear this

00:27:22.570 --> 00:27:27.230
out. Because that's getting a little bit cluttered.
And now let's set up an editor to work with

00:27:27.230 --> 00:27:31.600
go code. Now, there's a lot of editors that
are out there. And so what I'm going to show

00:27:31.600 --> 00:27:36.100
you is just one, but feel free to explore
the option for your favorite editor, because

00:27:36.100 --> 00:27:40.799
there's probably a go plugin for it. And all
of these plugins are really good right now.

00:27:40.799 --> 00:27:44.009
So I'm going to show you the one that I've
been using lately, which is Visual Studio

00:27:44.009 --> 00:27:47.409
code, now might be a little bit surprising
Microsoft, oh my goodness, they're doing all

00:27:47.409 --> 00:27:51.120
this really awesome stuff for the open source
community. But it's really true, one of the

00:27:51.120 --> 00:27:55.549
best development experiences that you're likely
to come across with go is in this Microsoft

00:27:55.549 --> 00:27:56.549
product

00:27:56.549 --> 00:28:00.780
running on Linux. So I've already installed
it. But if you do need to install it, you

00:28:00.780 --> 00:28:03.720
can come here to code Visual Studio Comm.

00:28:03.720 --> 00:28:07.360
It's going to give you the binaries. In this
case, I'm running Ubuntu. So I would download

00:28:07.360 --> 00:28:12.080
this.db file and install that onto my system.
And then I'm going to be able to run that

00:28:12.080 --> 00:28:18.179
by simply typing code in my application launcher,
or I've already set up a shortcut over here

00:28:18.179 --> 00:28:22.059
in my taskbar. So as soon as I run that, I'm
going to be presented with this. Now you can

00:28:22.059 --> 00:28:26.830
see I've already opened up a folder here,
you can open up a folder to your workspace

00:28:26.830 --> 00:28:32.240
by simply file open, and then pick your folder
that you want to be working with. So we're

00:28:32.240 --> 00:28:36.360
going to be working with code. But there is
one setup step that I need to go through before

00:28:36.360 --> 00:28:40.960
Visual Studio code is quite ready to go. And
that is I need to install the plugin that's

00:28:40.960 --> 00:28:44.940
going to allow us to work with go code. And
so if I click this button down here called

00:28:44.940 --> 00:28:48.700
extensions, then I have a list of all sorts
of extensions that I can add in for Visual

00:28:48.700 --> 00:28:54.380
Studio code. Now, right here is the go extension
by Lu COVID. Now there's a couple of go extensions,

00:28:54.380 --> 00:28:58.889
but I would strongly recommend you use this
one here by Luke, because it is really amazing.

00:28:58.889 --> 00:29:03.260
It offers a lot of capability, it really makes
Visual Studio Code of first class environment

00:29:03.260 --> 00:29:07.741
for developing go, okay, and as fast as that
that's been installed. And it was that fast,

00:29:07.741 --> 00:29:11.350
because it's been cashed from earlier. And
then I'm all set and ready to build my first

00:29:11.350 --> 00:29:16.279
go application. So let me go ahead into this
source directory. And I'm going to create

00:29:16.279 --> 00:29:20.270
a folder that's going to contain my source
code. Now your first temptation might be to

00:29:20.270 --> 00:29:24.659
just plug in your source code right here in
your src folder. But I wouldn't recommend

00:29:24.659 --> 00:29:30.270
that the standard structure that you're going
to use in a go application is to mirror where

00:29:30.270 --> 00:29:34.870
your application is going to be in source
control. And that makes it go gettable. So

00:29:34.870 --> 00:29:39.779
in this case, if I was going to keep this
file on GitHub, I would create a folder called

00:29:39.779 --> 00:29:47.160
github.com. And then underneath that, my GitHub
account is vi n si Mk II don't ask long story

00:29:47.160 --> 00:29:51.389
about why I called it that. And then I would
have an application name. So I would call

00:29:51.389 --> 00:29:55.769
this maybe first app, and that's the folder
that I'm going to store my application in.

00:29:55.769 --> 00:30:00.630
And the reason for that is if you think about
if I check this into GitHub, and observatory

00:30:00.630 --> 00:30:05.221
called first app, when I go get that, it's
going to recreate this structure. And so you

00:30:05.221 --> 00:30:09.799
want to create your applications following
that structure. So now I'm ready to create

00:30:09.799 --> 00:30:15.220
my first file, and I will call that main go.
And then I can start adding in my source code.

00:30:15.220 --> 00:30:20.389
So the first thing that I'm going to add is
package main. And then when I save this, oh,

00:30:20.389 --> 00:30:24.419
it looks like I expected something to happen
here. And it's not happening. I think it's

00:30:24.419 --> 00:30:28.190
because yeah, he told me that I needed to
reload the environment. Good. So I'm going

00:30:28.190 --> 00:30:32.500
to go ahead and do that. So I'm going to exit
out of Visual Studio code, and it should kick

00:30:32.500 --> 00:30:36.520
right back off, but it has to initialize the
plugin. So now I see what I was expecting

00:30:36.520 --> 00:30:41.299
to see. And that is that the NGO plugin has
recognized that they don't have all the tools

00:30:41.299 --> 00:30:45.840
that it needs in order to provide me all the
support that it can, because the NGO plugin

00:30:45.840 --> 00:30:50.400
for Visual Studio code is actually like a
lot of the plugins and other languages, it

00:30:50.400 --> 00:30:54.610
takes advantage of these language services,
for example, it's talking to me about go land,

00:30:54.610 --> 00:30:59.240
go lint isn't available on my system. And
so it's not going to be able to provide linting

00:30:59.240 --> 00:31:03.160
capabilities. So basically, the go plugin,
cause up to all these language services. The

00:31:03.160 --> 00:31:07.330
nice thing about that is if you decide to
flip between different editors, your experience

00:31:07.330 --> 00:31:10.740
is pretty much the same, because they're all
relying on the same language services in order

00:31:10.740 --> 00:31:12.669
to provide you the capabilities that you have

00:31:12.669 --> 00:31:19.220
something go ahead and install all. And you
can see there's a pretty long list of

00:31:19.220 --> 00:31:23.830
libraries that it's installing for me. Okay,
and now they're all installed. So that took

00:31:23.830 --> 00:31:28.669
about a minute to install all those dependencies.
So I expect that you'd probably have a similar

00:31:28.669 --> 00:31:33.019
experience in your own environment. Now, before
we start adding anything else, I actually

00:31:33.019 --> 00:31:37.030
put some quotation marks around this package,
that's not going to be correct. And now I'm

00:31:37.030 --> 00:31:41.529
ready to start actually building out my program.
So let me go ahead and put in an import statement

00:31:41.529 --> 00:31:44.450
here. And we haven't talked too much about
imports. But we have mentioned a little bit

00:31:44.450 --> 00:31:50.360
about packages, packages, or how code is organized
into sub libraries inside of NGO. So for example,

00:31:50.360 --> 00:31:54.029
if I want to build a web application, then
I might pull in the net HTTP package that

00:31:54.029 --> 00:31:58.919
you see here, in order to set up my web request
handlers. But for now, I just want to do a

00:31:58.919 --> 00:32:04.169
simple Hello, go example. And so I'm just
going to import the FMT package. But you notice

00:32:04.169 --> 00:32:08.809
that the NGO plugin for Visual Studio Code
gives me autocomplete, so any library that's

00:32:08.809 --> 00:32:13.580
available on my go path is going to be found
here. So now I'm going to create a simple

00:32:13.580 --> 00:32:18.610
function called main. And inside of that,
I'm going to access the FMT package. And notice

00:32:18.610 --> 00:32:23.150
that I get autocomplete functionality here.
So I can go ahead and say I want to call the

00:32:23.150 --> 00:32:28.309
print ln function, and it gives me the signature
for that function. So I can go ahead and add

00:32:28.309 --> 00:32:34.140
that in here. And the I just want to say hello,
go. Okay, so in order to run this, inside

00:32:34.140 --> 00:32:38.620
of Visual Studio code, you do have the ability
by pressing Ctrl backtick, you can open up

00:32:38.620 --> 00:32:42.250
a terminal right here inside of the editor.
And there's a couple of different options

00:32:42.250 --> 00:32:46.120
that I have in order to run my application.
So the first thing that I can do is I can

00:32:46.120 --> 00:32:50.879
use gos run command, as you see here, and
I can give the path all the way through to

00:32:50.879 --> 00:32:56.450
my source code. So if I come and I just keep
tapping through, then I'm going to get source

00:32:56.450 --> 00:33:02.549
slash github.com, slash vianne, si MKE slash
first app slash main.go. So if I run that,

00:33:02.549 --> 00:33:07.000
then it will compile that temporarily, and
run that for me. And it also compile in any

00:33:07.000 --> 00:33:11.289
third party libraries. So the FMT package
was compiled in as well. Now, that's a really

00:33:11.289 --> 00:33:15.320
good way to get a really quick run. Another
way that you have available to you is to use

00:33:15.320 --> 00:33:21.029
go build and go build takes the actual package
path. So all we're going to do here, is compile

00:33:21.029 --> 00:33:27.490
the first app package. Now, if it finds a
main package with a main function, then it's

00:33:27.490 --> 00:33:31.750
going to compile that as an executable, like
you see right here in my home directory. So

00:33:31.750 --> 00:33:37.080
I can go ahead and run that. Now the last
build tool that I have available is go install,

00:33:37.080 --> 00:33:42.730
go install is actually expecting to be pointed
to a package that has an entry point. And

00:33:42.730 --> 00:33:46.571
it's going to install that into your bin folder.
So let's go ahead and see that work. So we'll

00:33:46.571 --> 00:33:53.450
go to github.com, my username for GitHub,
and then first app again. So notice I'm using

00:33:53.450 --> 00:33:59.600
the package address, I'm not using the folder
path. If I run that, notice, I don't get anything

00:33:59.600 --> 00:34:04.470
in my main directory. But if I come into this
bin folder here, now I've got first app over

00:34:04.470 --> 00:34:09.389
here. So if I come back to my terminal, bin
slash first app, run that I get Hello, go

00:34:09.389 --> 00:34:12.710
printed out again. Okay, so the last thing
that I want to show you if I come back over

00:34:12.710 --> 00:34:16.430
to the terminal, so you see how we have all
the packages that we're working with locally

00:34:16.430 --> 00:34:20.990
over here in this code directory. If I come
to the first element of my go path, which

00:34:20.990 --> 00:34:25.630
is go lib, and look at that, you'll see that
this is starting to become a pretty busy place

00:34:25.630 --> 00:34:30.420
here. Because now I've got three source folders.
And if I come into GitHub comm, you'll see

00:34:30.420 --> 00:34:35.220
that I've got quite a few packages. So now
all of these third party dependencies aren't

00:34:35.220 --> 00:34:39.870
cluttering up my main workspace. They're all
in this go lib folder, and then I can focus

00:34:39.870 --> 00:34:45.030
on my development in my code folder. Now the
last place that you're going to see packages

00:34:45.030 --> 00:34:50.180
is over in the NGO installation directory.
So if I look in that folder, you see here

00:34:50.180 --> 00:34:55.470
that I have this directory called source.
So the ghost source code itself is in fact

00:34:55.470 --> 00:35:02.400
a valid go workspace. So if I come in here
look If the folders in here, you see, these

00:35:02.400 --> 00:35:07.540
are exactly the go standard library. So here's
FMT. Here. You see if I scroll down a little

00:35:07.540 --> 00:35:13.270
bit the net package, if I go into the net
package, you'll see that that contains the

00:35:13.270 --> 00:35:18.690
HTTP package. If I come into the HTTP package,
and list those contents, you see all of the

00:35:18.690 --> 00:35:23.550
source codes for all of the modules that you
can see over here at go. Lang Comm. So if

00:35:23.550 --> 00:35:34.710
I follow that through, over here, scroll down
to net, and HTTP, you see all of the capabilities

00:35:34.710 --> 00:35:39.190
that are available in here? Well, all of those
are provided by this source code here. So

00:35:39.190 --> 00:35:43.380
if you have any questions about how any one
of those libraries work, or how something's

00:35:43.380 --> 00:35:47.620
configured, you can jump right into the source
code and see how it's all put together. Over

00:35:47.620 --> 00:35:51.090
the last couple of videos, we've laid some
foundation by talking about the history and

00:35:51.090 --> 00:35:55.521
the features of go and working through setting
up the local development environment. What

00:35:55.521 --> 00:35:58.930
today is the day that we're going to start
a discussion about the go language itself

00:35:58.930 --> 00:36:03.221
by discussing how to work with variables.
So in order to fully cover how to work with

00:36:03.221 --> 00:36:07.160
variables, there's several topics that we're
going to need to cover. We're going to start

00:36:07.160 --> 00:36:11.080
by learning how to declare variables. Then
we'll move into a discussion about how go

00:36:11.080 --> 00:36:16.540
considers read declaration variables. And
this concept of shadowing. After that, we'll

00:36:16.540 --> 00:36:18.321
talk about visibility, where we're going

00:36:18.321 --> 00:36:23.330
to learn how we can control what aspects of
our program can see a variable that we create,

00:36:23.330 --> 00:36:27.440
then we'll talk about naming conventions.
And finally, we'll wrap up with a brief discussion

00:36:27.440 --> 00:36:32.430
about how to convert variables from one type
to another. Okay, so let's go ahead and get

00:36:32.430 --> 00:36:37.860
started. So I'm going to be using the playground
in order to host our conversation. That way,

00:36:37.860 --> 00:36:41.340
you can follow along whether you've set up
a local development environment, or just want

00:36:41.340 --> 00:36:45.191
to follow along online. So as you can see,
when we first load up the playground, we've

00:36:45.191 --> 00:36:49.610
got this one statement program, which is just
printing out the string hello playground to

00:36:49.610 --> 00:36:53.590
the bottom of the screen, when I click this
run button here. Now this statement can only

00:36:53.590 --> 00:36:57.900
ever do one thing because we're passing in
a string literal. And similarly, if I pass

00:36:57.900 --> 00:37:03.520
in the number, say 42, and run it, then we
print 42 out. Now no matter what we send to

00:37:03.520 --> 00:37:07.730
this print ln function, it's only going to
ever do that one thing. So in order to provide

00:37:07.730 --> 00:37:12.490
a little bit more flexibility to our application,
we're going to introduce variables. So there's

00:37:12.490 --> 00:37:15.560
actually three different ways to declare variables
and go and we're going to go through each

00:37:15.560 --> 00:37:20.400
one of those. And then we'll talk a little
bit about where you might use each format.

00:37:20.400 --> 00:37:24.860
So the first thing that we can do is actually
declare the variable itself. And that'll be

00:37:24.860 --> 00:37:27.890
done using this kind of a statement. So we're
going to start with the var keyword, then

00:37:27.890 --> 00:37:31.820
we're going to have the name of the variable
and the type of the variable. Now if you come

00:37:31.820 --> 00:37:34.910
from another strongly typed language, this
might look a little bit backwards, because

00:37:34.910 --> 00:37:39.790
you might be expecting to see something like
int i. Well, that's not actually how go works.

00:37:39.790 --> 00:37:43.730
And if you think about it, the way gos structures,
things actually looks more like how you read

00:37:43.730 --> 00:37:48.170
it. So I'm going to declare a variable called
I that's going to be of type integer. So the

00:37:48.170 --> 00:37:52.101
way you declare variables and go, it's pretty
much the same way that you speak. And so it

00:37:52.101 --> 00:37:55.130
might look a little bit odd when you first
start working with it. But it very quickly

00:37:55.130 --> 00:37:59.170
becomes intuitive. Now that we have our variable
declared, we can go ahead and assign a value

00:37:59.170 --> 00:38:03.940
to it. And we'll do that simply with the equals
operator. So once we have that set, we can

00:38:03.940 --> 00:38:09.120
go ahead and replace this with an AI, run
it and we print the value 42 out. And since

00:38:09.120 --> 00:38:14.750
variables in go can vary, we can go ahead
and change the value of that to say 27. When

00:38:14.750 --> 00:38:19.360
we run again, we get the value 27 printed
out. So now even though the statement can

00:38:19.360 --> 00:38:24.460
only ever do one thing at a time, the program
that runs up above this FORMAT statement can

00:38:24.460 --> 00:38:29.010
actually influence the value that's printed
out to the console. Okay, so let's go ahead

00:38:29.010 --> 00:38:33.550
and get rid of this, and then explore another
way to initialize this variable. Because one

00:38:33.550 --> 00:38:37.850
of the things that we trying to do and go
is we want to keep things simple. So if we

00:38:37.850 --> 00:38:41.900
need multiple lines, then we'll go ahead and
do that. But we don't want anything to be

00:38:41.900 --> 00:38:47.270
more verbose than we have to. So we can actually
combine these two lines in one like this.

00:38:47.270 --> 00:38:52.000
So we can initialize the variable i as an
integer and assign the value 42 in the same

00:38:52.000 --> 00:38:56.340
line. So if we go ahead and run this, then
no big surprise, we get the value 42 printed

00:38:56.340 --> 00:39:01.430
out. Now, this is actually still making us
work a little bit harder than we need to.

00:39:01.430 --> 00:39:06.430
Because since we're assigning the value 42
to this, the go compiler can actually figure

00:39:06.430 --> 00:39:11.770
out what data type it needs to have. So we
can go ahead and tell it to figure this out

00:39:11.770 --> 00:39:17.580
for us by replacing all this text with this
text here. So if we just say I and then use

00:39:17.580 --> 00:39:23.140
this colon equal operator and the value 42,
and run this, then we get this really nice

00:39:23.140 --> 00:39:29.460
concise way of setting things up. Now, where
are you going to need each one of these? Well,

00:39:29.460 --> 00:39:34.670
let me go ahead and add them back in so we
can talk about them. So we'll set var I integer

00:39:34.670 --> 00:39:43.690
i equals 42. And then we'll use var j integer
equals 27. And then we'll set up K and that's

00:39:43.690 --> 00:39:44.690
going to be equal to

00:39:44.690 --> 00:39:46.770
99.

00:39:46.770 --> 00:39:49.860
So we have these three different formats.
So when are you gonna want to use each one

00:39:49.860 --> 00:39:54.010
of these? Well, the nice thing about this
first format is there are going to be times

00:39:54.010 --> 00:39:58.930
when you want to declare a variable but you're
not ready to initialize it yet. So for example,

00:39:58.930 --> 00:40:02.810
if you want to declare variable in the scope
of this main function, and then you have a

00:40:02.810 --> 00:40:06.250
loop or something like that, that sets up
a local variable scope. And that's where the

00:40:06.250 --> 00:40:10.710
variable is actually going to be assigned,
then you can go ahead and use this first syntax.

00:40:10.710 --> 00:40:15.110
The second syntax is valuable, if go doesn't
have enough information to actually assign

00:40:15.110 --> 00:40:20.710
the type that you really want assign to it.
So to show that, let me go ahead and add another

00:40:20.710 --> 00:40:24.410
print statement here. And I'm going to need
to come up these other lines out in order

00:40:24.410 --> 00:40:29.460
to make things happy for us. So let me go
ahead and change this print ln to a print

00:40:29.460 --> 00:40:32.640
F. And what this is going to do is it's going
to allow us to provide a formatting string

00:40:32.640 --> 00:40:37.350
and print things out that way. So we'll print
out the value, and then I'll print out the

00:40:37.350 --> 00:40:42.930
type of the variable, and then I'll pass in
j twice. And so if I run this, then we get

00:40:42.930 --> 00:40:48.230
the value 27. And no big surprise, it's an
integer. But what if we want this to be, for

00:40:48.230 --> 00:40:52.830
example, a floating point number? Well, with
this syntax, it's as simple as just changing

00:40:52.830 --> 00:40:58.390
this to float 32. When we run this, then go
understand that we want to use 27 as a floating

00:40:58.390 --> 00:41:06.200
point number. Now, if we tried that with K,
down here, so let me uncomment the K, switch

00:41:06.200 --> 00:41:12.530
this over to use K and run, then you see that
the number 99 is inferred to be of type integer.

00:41:12.530 --> 00:41:16.640
And we can influence that a little bit by
adding a decimal point. And that's going to

00:41:16.640 --> 00:41:22.110
give a hint, making that a float 64. But there's
no way to use this colon equals syntax to

00:41:22.110 --> 00:41:26.580
initialize a float 32. For example, go is
either going to decide it's an integer type,

00:41:26.580 --> 00:41:31.121
or it's a float 64 type. So if you need a
little bit more control than the second declaration,

00:41:31.121 --> 00:41:35.390
syntax is going to be valuable for you. Now
the next thing that I want to show you is

00:41:35.390 --> 00:41:39.850
how we can declare variables. Now we've been
declaring variables one at a time and inside

00:41:39.850 --> 00:41:44.500
of a function. Well, another way that you
can declare variables is up here at the package

00:41:44.500 --> 00:41:48.990
level. Now when you're doing it at the package
level, you cannot use this colon equals syntax,

00:41:48.990 --> 00:41:54.230
you actually have to use the full declaration
syntax. So we can declare a variable is an

00:41:54.230 --> 00:42:01.260
integer set equal to 42. So that works, come
down, wipe out this code, and then replace

00:42:01.260 --> 00:42:08.270
this with I. And you see that we have the
value 42. And it's of type integer. So just

00:42:08.270 --> 00:42:13.130
like we have before, we can go ahead and tell
it to declare that as a float 32. And the

00:42:13.130 --> 00:42:16.520
compiler recognizes, well, I can make 42 a
floating point number, that's not going to

00:42:16.520 --> 00:42:21.930
be a problem at all. Now, of course, if you
try something like this, the compiler has

00:42:21.930 --> 00:42:25.430
no idea how to convert the string food to
a floating point number, and so it's going

00:42:25.430 --> 00:42:29.170
to fail on you. Another thing that we can
do at the package level is we can actually

00:42:29.170 --> 00:42:34.350
create a block of variables that are declared
together. And to show you why that's valuable.

00:42:34.350 --> 00:42:38.520
Let me just drop in some variables that we
can play around with. Okay, so as you can

00:42:38.520 --> 00:42:42.330
see, I've got a little bit of Doctor Who has
a brain here, and say I'm writing a program

00:42:42.330 --> 00:42:45.980
that's going to print out some information
about the doctor's companions. So here we

00:42:45.980 --> 00:42:50.030
got a variable actor name, that's going to
be Elisabeth Sladen, then we got her companion

00:42:50.030 --> 00:42:54.900
name, which doctor she worked with, and what
season she was on. So by declaring these variables

00:42:54.900 --> 00:42:58.580
like this, things are actually a little bit
cluttered. Because again, we want things in

00:42:58.580 --> 00:43:03.120
go to be as clear and concise as possible.
So all these var keywords are actually cluttering

00:43:03.120 --> 00:43:08.811
things up a little bit. So what we can do
instead of this is actually wrap this whole

00:43:08.811 --> 00:43:17.590
section with a VAR block. And then we can
actually get rid of the use of this var keyword.

00:43:17.590 --> 00:43:21.140
And now all of these variables are going to
be declared because they're inside of this

00:43:21.140 --> 00:43:25.700
var block. And we can actually show that they're
related somehow. Now they don't have to be

00:43:25.700 --> 00:43:30.600
related. That's a design decision. But we
can do that. So if we had another set of variables

00:43:30.600 --> 00:43:34.670
that were related to a different context.
So say, for example, we had a counter, and

00:43:34.670 --> 00:43:38.730
that was going to be an integer initialized
to zero, then we can have multiple variable

00:43:38.730 --> 00:43:42.541
blocks at the package level. And that's just
going to allow you to organize your application

00:43:42.541 --> 00:43:46.230
a little better, and keep your code a little
bit cleaner. Now the next thing that I want

00:43:46.230 --> 00:43:51.100
to show you and let me just drop in some code
here is how variables work when you're trying

00:43:51.100 --> 00:43:52.710
to read Eclair them.

00:43:52.710 --> 00:43:56.820
So you can see in this application, we're
declaring the variable i up here in the package

00:43:56.820 --> 00:44:01.630
scope, then I'm declaring it here inside of
the main function, and then I'm re declaring

00:44:01.630 --> 00:44:07.080
it here on line 11. Now, if I try and run
this, I'm actually going to get an error.

00:44:07.080 --> 00:44:12.280
And the error comes on line 11 here, because
there's no new variables here. So I can reassign

00:44:12.280 --> 00:44:19.680
the value of i 13. But I can't declare a new
variable here. And that's because the variables

00:44:19.680 --> 00:44:24.180
already declared on line 10. And you can't
declare the variable twice in the same scope.

00:44:24.180 --> 00:44:29.490
However, if I get rid of this line, notice
that the application runs just fine, and uses

00:44:29.490 --> 00:44:34.720
the value 42. So even though I is declared
twice in my application, once at the package

00:44:34.720 --> 00:44:40.090
level, and once inside of the main function,
that's okay. And what happens is that the

00:44:40.090 --> 00:44:44.790
variable with the innermost scope actually
takes precedence. So this is called shadowing.

00:44:44.790 --> 00:44:47.330
So the package level is still available,

00:44:47.330 --> 00:44:50.530
but it's being hidden by the declaration in
the main function. And I can actually show

00:44:50.530 --> 00:44:54.000
that by copying this line up here

00:44:54.000 --> 00:44:59.461
and running this. And now you see I get 27,
which is the package level scope. Then I create

00:44:59.461 --> 00:45:04.700
the shadow Variable setting equal to 42. And
when I print out I again, then I get the new

00:45:04.700 --> 00:45:09.830
value of i. Now another interesting thing
about variables in go is that they always

00:45:09.830 --> 00:45:14.580
have to be used. So let me just drop in this
example here. And let's walk through it. So

00:45:14.580 --> 00:45:18.790
I'm declaring a variable, I'm setting it equal
to 42, then I'm instantiating, a variable

00:45:18.790 --> 00:45:24.870
j, setting it equal to 13. But I'm only using
i. So what happens when I run this? Well,

00:45:24.870 --> 00:45:29.490
if I do, I actually get yelled at, because
j is declared and not used. And this is one

00:45:29.490 --> 00:45:33.980
of the things that's going to keep your go
applications nice and clean. If you have a

00:45:33.980 --> 00:45:39.300
local variable that's declared and not used,
then that's actually a compile time error.

00:45:39.300 --> 00:45:43.910
And the reason that's really valuable is as
your application grows and evolves, and new

00:45:43.910 --> 00:45:48.480
features are added and old features are deprecated,
you're very likely to end up with some old

00:45:48.480 --> 00:45:53.350
code hanging around inside of your functions.
Well, if any of your old code or variables

00:45:53.350 --> 00:45:57.340
and those variables are no longer used, then
the compiler is going to detect that for you

00:45:57.340 --> 00:46:00.930
see that you can make sure that you can clean
those out. Now another important thing to

00:46:00.930 --> 00:46:04.940
know about when you're working with variables
is how to name them. And there's actually

00:46:04.940 --> 00:46:09.450
two sets of rules that you're going to need
to keep track of. One is how naming controls

00:46:09.450 --> 00:46:14.660
visibility of the variable and go. And the
other is the naming conventions themselves.

00:46:14.660 --> 00:46:18.970
So notice that I've been creating lowercase
variables. Well, that actually isn't always

00:46:18.970 --> 00:46:23.240
the case in NGO, because if I'm declaring
a variable, and let's just declare it at the

00:46:23.240 --> 00:46:29.800
package level, and I declared as an integer,
with the name I, and I go ahead and work with

00:46:29.800 --> 00:46:35.140
that, then that lowercase variable name actually
means that this variable is scoped to this

00:46:35.140 --> 00:46:39.110
package. Now, this is a main package. And
so this doesn't really matter so much. But

00:46:39.110 --> 00:46:44.240
when we get into working with packages, this
becomes extremely important. So lowercase

00:46:44.240 --> 00:46:48.470
variables are scoped to the package, which
means anything that consumes the package,

00:46:48.470 --> 00:46:55.290
can't see it and can't work with it. But if
I switch to an uppercase letter, then that's

00:46:55.290 --> 00:47:00.250
what's going to trigger the go compiler to
expose this variable to the outside world.

00:47:00.250 --> 00:47:03.930
So it's a very simple naming convention. And
there's really only three levels of visibility

00:47:03.930 --> 00:47:08.800
for variables in go. If you have it at the
package level, and as lowercase is scoped

00:47:08.800 --> 00:47:14.180
to the package, so any file in the same package
can access that variable. If it's uppercase

00:47:14.180 --> 00:47:19.590
at the package level, then it's export at
the front of package and it's globally visible.

00:47:19.590 --> 00:47:23.850
And the third scope is block scope. So when
we have this main function here, it's actually

00:47:23.850 --> 00:47:29.530
establishing a block scope. So when we declare
this variable I write here on line 10, that

00:47:29.530 --> 00:47:35.070
variable is scoped to the block. And so that's
never visible outside of the block itself.

00:47:35.070 --> 00:47:38.930
Now beyond that, it's important to understand
the naming conventions in go, and there's

00:47:38.930 --> 00:47:43.440
a couple rules that we need to follow. The
first is that the length of the variable name

00:47:43.440 --> 00:47:48.930
should reflect the life of the variable. So
for example, in this example, we're declaring

00:47:48.930 --> 00:47:54.250
a variable i, and we're using it right away.
So having a very simple variable name is perfectly

00:47:54.250 --> 00:47:58.290
acceptable. And this is going to be especially
true if you're declaring counters and for

00:47:58.290 --> 00:48:03.460
loops and things like that, it's very common
have single letter or very, very concise variable

00:48:03.460 --> 00:48:08.310
names, because the lifespan of that variable
is very small. And the amount of time that

00:48:08.310 --> 00:48:13.280
you have to keep the meaning of that variable
in your head is very small as well. However,

00:48:13.280 --> 00:48:17.520
if you're declaring a variable that you use
for a very long time, then it's best practice

00:48:17.520 --> 00:48:23.850
to use a longer name. So for example, if this
was going to represent the season number that

00:48:23.850 --> 00:48:29.720
our companion was on, so say, season 11. And
we use that throughout this entire main function,

00:48:29.720 --> 00:48:34.430
then we'd want to use a name something like
season number. Now, if you're working with

00:48:34.430 --> 00:48:38.150
a package level variable, and that package
level variable is going to be used in quite

00:48:38.150 --> 00:48:42.670
a few other places, then that's where you're
going to want to use the most verbose variable

00:48:42.670 --> 00:48:46.250
name. Now, you still shouldn't get crazy,
you shouldn't have 50 character long variable

00:48:46.250 --> 00:48:50.780
names if you can avoid it. So keep your names
as short as you can. But make sure that the

00:48:50.780 --> 00:48:56.190
names of those exported or package level variables
are clear enough so that somebody who's outside

00:48:56.190 --> 00:49:00.680
of that source file understands the meaning
of it. The other thing I'd like to talk about

00:49:00.680 --> 00:49:04.750
is how to work with acronyms, because in other
languages, you might see variables like the

00:49:04.750 --> 00:49:11.600
URL, and then maybe this is http google.com.

00:49:11.600 --> 00:49:15.990
You might see a variables name like this.
Well, the best practice and go is actually

00:49:15.990 --> 00:49:20.030
to keep these acronyms as all uppercase. So
if you're working with a variable called the

00:49:20.030 --> 00:49:27.500
URL, the URL should be all uppercase. Similarly,
HTTP and any variables like that. So anytime

00:49:27.500 --> 00:49:31.620
you see an acronym, make sure that that's
all uppercase. And the reason is for readability,

00:49:31.620 --> 00:49:36.510
it's very clear, we're used to seeing URL
and HTTP all put together. So when you read

00:49:36.510 --> 00:49:41.320
this variable, it's very clear that you're
talking about an HTTP. Maybe you're talking

00:49:41.320 --> 00:49:47.090
about an HTTP request that reads a little
bit cleaner than if you go ahead and make

00:49:47.090 --> 00:49:52.100
those lowercase. So just some rules to keep
in mind as you're creating variables. Now

00:49:52.100 --> 00:49:56.230
the next example that I want to show you is
how we can actually convert from one variable

00:49:56.230 --> 00:50:01.551
type to another. So notice that I have two
variables here. I've got variable i on line

00:50:01.551 --> 00:50:06.030
eight, and then I'm declaring as an integer
with the value 42. And then I've got this

00:50:06.030 --> 00:50:10.761
variable j, that's going to be a floating
point number. Now what I want to do is I want

00:50:10.761 --> 00:50:16.020
to actually treat it as a floating point number
and assign that value to J. So the way that

00:50:16.020 --> 00:50:22.040
I do that is using this conversion operator.
So if you look on line 12, it looks like float

00:50:22.040 --> 00:50:26.240
is being used as a function. And in fact,
it is. And this is a conversion function.

00:50:26.240 --> 00:50:31.380
So when I run this program, you see that the
first print statement on line nine, prints

00:50:31.380 --> 00:50:36.800
42, as an integer, the second print statement
still prints the same value 42. But now it's

00:50:36.800 --> 00:50:41.580
been coerced into being a floating point number,
they have to be a little careful with this.

00:50:41.580 --> 00:50:49.640
Because if you go the other way, so for example,
if we go from a float 32 to an integer, and

00:50:49.640 --> 00:50:56.110
then I convert that and run it, it looks like
everything's okay. But keep in mind, a floating

00:50:56.110 --> 00:51:01.230
point number can have a decimal on it. So
now I've actually lost information to the

00:51:01.230 --> 00:51:06.190
conversion. So the important thing about this
is I have to explicitly convert, because if

00:51:06.190 --> 00:51:12.011
I just tried to do this, then I'm actually
going to get a compile time error, because

00:51:12.011 --> 00:51:16.390
go is not going to risk the possibility of
losing information through that conversion.

00:51:16.390 --> 00:51:20.910
So you have to do an explicit conversion,
when you're changing types. That way, it's

00:51:20.910 --> 00:51:24.980
your responsibility to understand if you're
losing information or not. Now, the other

00:51:24.980 --> 00:51:30.250
thing that's important to know is if I decide
to work with strings, it's a very common use

00:51:30.250 --> 00:51:34.660
case, to try and convert an integer into a
string, say, for example, you want to print

00:51:34.660 --> 00:51:40.530
it out to a log file. Well, if I run this,
I get a pretty odd result. The first line

00:51:40.530 --> 00:51:45.551
prints out Okay, 42. And that's an integer,
that's okay. But then I get an asterisk. That's

00:51:45.551 --> 00:51:49.400
of type string, what the heck happened there?
Well, in order to understand that, you have

00:51:49.400 --> 00:51:54.470
to understand how strings work with go, a
string is just an alias for a stream of bytes.

00:51:54.470 --> 00:52:00.000
So what happens when we asked the application
to convert the number 42 into a string is

00:52:00.000 --> 00:52:04.360
it looks for what Unicode character is set
at the value 42. And that happens to be an

00:52:04.360 --> 00:52:07.860
asterisk. So if you want to convert back and
forth between strings and numbers, then you're

00:52:07.860 --> 00:52:13.470
actually going to need to pull in the string
conversion package, which you can find on

00:52:13.470 --> 00:52:18.510
go Lang under packages. If you scroll down
a little bit, you see string conversion here.

00:52:18.510 --> 00:52:21.720
And this is going to expose all sorts of functions
that are going to make it a lot easier to

00:52:21.720 --> 00:52:26.340
convert back and forth between strings and
other data types. So in this case, what we'd

00:52:26.340 --> 00:52:34.470
want to do is use the string conversion packages
I to a function, which converts an integer,

00:52:34.470 --> 00:52:38.440
that's the I two, that's the two and then
to an ASCII string. So if we go ahead and

00:52:38.440 --> 00:52:44.830
run that, now you see that it properly converts
the integer 42 into the string 42, and prints

00:52:44.830 --> 00:52:49.570
it out for us. So if you need to work with
converting between numbers and strings, then

00:52:49.570 --> 00:52:53.710
go ahead and use that string conversion package.
But if you're converting between numeric types,

00:52:53.710 --> 00:52:57.390
just keep in mind, you can't implicitly do
that conversion, you have to explicitly do

00:52:57.390 --> 00:53:03.770
it. And if you need to do that, then you can
go ahead and use the type as a function. Okay,

00:53:03.770 --> 00:53:06.890
so we just covered quite a bit of ground.
So let's go through a summary of what we've

00:53:06.890 --> 00:53:09.220
talked about throughout this video.

00:53:09.220 --> 00:53:14.720
Okay, there's quite a few things to keep in
mind as we're working with variables. So let's

00:53:14.720 --> 00:53:18.150
go through and review what we talked about.
The first thing that we talked about is the

00:53:18.150 --> 00:53:22.270
three different ways to declare variables.
So we saw that we could declare a variable,

00:53:22.270 --> 00:53:26.060
and then initialize it later, we saw that
we can declare it and initialize it at the

00:53:26.060 --> 00:53:30.950
same time. And then we also saw that we can
use this colon equals syntax as a shorthand

00:53:30.950 --> 00:53:35.330
version of declaring and initializing a variable.
And then we let the compiler decide what type

00:53:35.330 --> 00:53:39.930
to assign to that. Now normally, you're going
to use this third version, the only time you're

00:53:39.930 --> 00:53:43.920
really going to use the second version is
when the compiler is going to guess wrong.

00:53:43.920 --> 00:53:47.950
And then the first version is sometimes useful.
If you need to declare the variable in a different

00:53:47.950 --> 00:53:51.710
scope than you're actually going to initialize
it. We then talked about how we can't read

00:53:51.710 --> 00:53:55.830
declare a variable. So within the same scope,
we can't initialize that variable twice, but

00:53:55.830 --> 00:54:00.600
we can continue to reassign values to it,
but we can shadow them. So if we declare a

00:54:00.600 --> 00:54:06.060
variable in a package scope, for example,
we can read declare that in a function scope,

00:54:06.060 --> 00:54:09.900
and that's going to shadow the variable at
the higher level of scope. All variables must

00:54:09.900 --> 00:54:14.510
be used in a go application. So if you declare
a local variable, and that variable isn't

00:54:14.510 --> 00:54:18.960
used in the scope that it's declared or one
of its inner scopes, then that's going to

00:54:18.960 --> 00:54:22.050
trigger a compiler error. And you're going
to have to go back and clean that up before

00:54:22.050 --> 00:54:25.940
your application is going to run. And again,
the reason that that's really nice is as code

00:54:25.940 --> 00:54:30.900
evolves, and it continues to be refactored
and improved over time, and features get retired,

00:54:30.900 --> 00:54:35.070
you don't have all these old variables hanging
around and requiring allocations of memory

00:54:35.070 --> 00:54:39.660
when they're not being used for anything anymore.
We also talked about the visibility rules.

00:54:39.660 --> 00:54:42.630
The first thing that you need to know is when
you're working with package level variables,

00:54:42.630 --> 00:54:47.120
a lowercase first letter means that it's scoped
to the package, which means all of the source

00:54:47.120 --> 00:54:52.090
files that are in the same package have access
to that variable. If you have an uppercase

00:54:52.090 --> 00:54:55.780
first letter, then it's going to be exported
globally, and so anything can work with that

00:54:55.780 --> 00:55:00.830
variable at that point. There is no private
scope. So you can't scope it. variable to

00:55:00.830 --> 00:55:05.920
the source code itself. However, you can scope
a variable to a block by declaring it within

00:55:05.920 --> 00:55:10.580
the block instead of declaring it at the package
level. We also talked about the naming conventions.

00:55:10.580 --> 00:55:14.170
And there are really two naming conventions
that are used Pascal case, which basically

00:55:14.170 --> 00:55:18.420
means you uppercase, the first letter, and
camelcase. So when you're naming variables,

00:55:18.420 --> 00:55:22.370
you don't want to separate the words in the
variables with underscores. You don't want

00:55:22.370 --> 00:55:26.340
to have them all in lowercase, you don't want
to do anything like that. Just use standard

00:55:26.340 --> 00:55:31.660
Pascal or camel casing rules. The only exception
to that is if you're working with acronyms,

00:55:31.660 --> 00:55:35.760
all of the letters in the acronym should be
uppercase. The names of the variables should

00:55:35.760 --> 00:55:40.210
be as short as you reasonably can get them.
So you've got a very short lifespan of the

00:55:40.210 --> 00:55:44.060
variable, say, for example, a counter in a
for loop, then having a one letter variable

00:55:44.060 --> 00:55:48.600
name is perfectly acceptable. However, if
you've got a variable that's got a longer

00:55:48.600 --> 00:55:52.500
lifespan, say, for example, it's used in a
fairly long function, or if it's exported

00:55:52.500 --> 00:55:56.770
from the package, then having a longer more
descriptive variable name is certainly something

00:55:56.770 --> 00:56:00.960
that you should consider. However, please
don't go crazy. Keep those names as brief

00:56:00.960 --> 00:56:05.320
and concise as possible. And the last thing
we talked about are the type conversions and

00:56:05.320 --> 00:56:09.570
how these work a little bit differently than
other languages, a lot of other languages,

00:56:09.570 --> 00:56:13.270
you would have to put the type in params,
and then what you want to convert, in NGO,

00:56:13.270 --> 00:56:17.620
it acts more like a function. If we want to
convert an integer to a floating point 32

00:56:17.620 --> 00:56:21.790
number, then we use float 32 as a function,
and we pass the integer into it, and it's

00:56:21.790 --> 00:56:26.150
going to do the type conversion for us, we
also learned that go does not do implicit

00:56:26.150 --> 00:56:29.750
type conversion. So if you try and take a
floating point number and assign it to an

00:56:29.750 --> 00:56:33.690
integer, goes going to throw a compile time
error for that. And that's because of the

00:56:33.690 --> 00:56:36.980
possibility of losing information through
that conversion. So every time you're going

00:56:36.980 --> 00:56:41.060
to do a type conversion that might lose information,
you're going to have to do that yourself so

00:56:41.060 --> 00:56:44.640
that you're making the decision. And then
you can write whatever tests are required

00:56:44.640 --> 00:56:49.600
in order to make sure that information hasn't
lost. The final thing that we learned is when

00:56:49.600 --> 00:56:53.771
we're working with strings, then type conversions
can start to get a little bit weird. So in

00:56:53.771 --> 00:56:58.110
order to handle the conversion between integers
and strings, and other data types in strings,

00:56:58.110 --> 00:57:02.230
we can use that string conversion package
that offers a series of functions that make

00:57:02.230 --> 00:57:06.130
sure that the conversions happen the way that
we expect them to. In today's video, what

00:57:06.130 --> 00:57:09.590
I want to do is introduce the primitive types
that we have available in the go language.

00:57:09.590 --> 00:57:13.920
Now, we're not going to be talking about every
basic type that you can create. There are

00:57:13.920 --> 00:57:17.210
certainly collections and some more complicated
types. And we'll introduce those a little

00:57:17.210 --> 00:57:21.480
bit later. Today, I want to focus on three
categories of information that we can store

00:57:21.480 --> 00:57:26.910
and go. We'll start by talking about the Boolean
type, then we'll move on to the numeric types.

00:57:26.910 --> 00:57:31.630
And in that category, we have integers, floating
point numbers and complex numbers. And then

00:57:31.630 --> 00:57:35.490
we'll move on to the text types. Okay, so
fairly simple agenda, but we've got a lot

00:57:35.490 --> 00:57:38.531
to cover. So let's go ahead and get started
by talking about how we can work with boolean

00:57:38.531 --> 00:57:44.660
data in go. boolean data is probably the simplest
type of data that we can work with and go.

00:57:44.660 --> 00:57:49.140
And it represents two states, you either have
true or you have false. So in order to show

00:57:49.140 --> 00:57:54.580
you a simple example of working with Boolean
variables, we can create a variable here and

00:57:54.580 --> 00:57:58.380
make it of type bool. So that's the data type
that you're going to use when you're declaring

00:57:58.380 --> 00:58:03.030
a Boolean. And we can set it equal to A values.
So for example, we can set it equal to true,

00:58:03.030 --> 00:58:05.800
and then we can go ahead and print out using
our

00:58:05.800 --> 00:58:10.090
fancy printf statement here, we can print
out the value and type of this Boolean. And

00:58:10.090 --> 00:58:14.400
if we run that, we see that the Boolean true
is in fact got the value true. And its data

00:58:14.400 --> 00:58:21.020
type is Boolean. So we can also initialize
this to false, and run that. And now we see

00:58:21.020 --> 00:58:26.350
false is also a Boolean. Now there's a couple
of uses for Boolean variables in our applications,

00:58:26.350 --> 00:58:31.610
perhaps one of the most common is to use them
as state flags. So for example, say you're

00:58:31.610 --> 00:58:35.480
creating an application and you want to store
whether a user is signed up for notifications

00:58:35.480 --> 00:58:39.290
when a report is generated. Well, you can
use a boolean variable in order to store true

00:58:39.290 --> 00:58:44.060
if they want that report or false if they
don't. The other case. And perhaps the more

00:58:44.060 --> 00:58:49.250
common case for using Boolean and go is as
a result of logical tests. Now, we're not

00:58:49.250 --> 00:58:54.210
ready to talk about logical tests quite yet.
But I can show you how Boolean 's are used

00:58:54.210 --> 00:59:01.110
in those tests. So if we create a simple variable
here, and we use the equals operator to test

00:59:01.110 --> 00:59:05.290
if one equals one, and then create another
variable, and then I want to test if one equals

00:59:05.290 --> 00:59:09.710
two. Now, the double equals operator is called
the equals operator. And that's basically

00:59:09.710 --> 00:59:13.400
checking to see if the item on the left is
equivalent to the item on the right, so one

00:59:13.400 --> 00:59:17.500
obviously equals the number one, and one,
just as obviously doesn't equal the number

00:59:17.500 --> 00:59:22.681
two. So if we print out the value of those
using these two printf statements, then we

00:59:22.681 --> 00:59:28.140
see that a Boolean is actually generated as
a result of this equivalency test. Now when

00:59:28.140 --> 00:59:31.260
we get into talking about logical tests, we'll
see that there are actually quite a few other

00:59:31.260 --> 00:59:35.220
logical tests that we can use. But this is
a very common use case that we have. So we

00:59:35.220 --> 00:59:41.850
see looks like I need to add a new line operator
here, we see that the first operation does

00:59:41.850 --> 00:59:46.590
in fact, generate the Boolean true and the
second operation generates the Boolean false.

00:59:46.590 --> 00:59:50.411
Now the other thing that's important to know
about the primitives is that every time you

00:59:50.411 --> 00:59:56.230
initialize a variable, Ingo, it actually has
a zero value. So we're assigning the value

00:59:56.230 --> 01:00:02.870
of n and m in this example here, but what
happens is If I just do this and print out

01:00:02.870 --> 01:00:07.480
the value of that, well, in some languages,
that would be uninitialized memory, and we

01:00:07.480 --> 01:00:12.190
would have no control over what printed out,
when go, every time you initialize a variable,

01:00:12.190 --> 01:00:17.680
it has a zero value in the zero value for
Boolean is the value false. So you don't have

01:00:17.680 --> 01:00:21.681
to worry about initializing variables every
time. If the zero value is acceptable to you,

01:00:21.681 --> 01:00:26.920
you can certainly leave it like that. So Boolean
is a pretty simple. The next type that I want

01:00:26.920 --> 01:00:30.991
to get into are the numeric types. And these
are a little bit more complicated, because

01:00:30.991 --> 01:00:35.720
of all of the different types of numbers that
we can work with in our applications. Go has

01:00:35.720 --> 01:00:39.890
a rich array of numeric types to choose from.
Now, the first thing that we need to know

01:00:39.890 --> 01:00:45.200
about is the zero value. And the zero value
for all numeric types is going to be zero,

01:00:45.200 --> 01:00:49.980
or the equivalent of zero for that numeric
type. So let's start talking about the integer

01:00:49.980 --> 01:00:54.210
types. So the first type of integers that
we can work with are the signed integers.

01:00:54.210 --> 01:00:58.600
And those have several different data types.
So we have the general int, which is an integer

01:00:58.600 --> 01:01:03.620
of unspecified size. And I say unspecified
because every platform can choose to implement

01:01:03.620 --> 01:01:08.130
it as a different size. Now, the one thing
that you're guaranteed is regardless of your

01:01:08.130 --> 01:01:14.370
environment, and it will be at least 32 bits,
but it could be 64, or even 128 bits depending

01:01:14.370 --> 01:01:18.010
on the system that you're running on. And
this is going to be the default integer type.

01:01:18.010 --> 01:01:23.491
So if we do something like n equals 42, and
then we print out the type of n, then you

01:01:23.491 --> 01:01:28.530
see that we get the value 42. And it's of
type integer. Now, there are other types.

01:01:28.530 --> 01:01:33.700
So we can have eight bit integers, which can
range from negative 128 to 127. We can have

01:01:33.700 --> 01:01:40.760
16 bit integers, which can go from negative
32,007 68, up to 32,007 67, then 32 bit integers,

01:01:40.760 --> 01:01:45.320
which can go from approximately negative to
positive 2 billion. And then if you need a

01:01:45.320 --> 01:01:50.000
really big number, you can go with 64 bit
integers. And those go somewhere between plus

01:01:50.000 --> 01:01:54.110
and minus nine quintillion. So if you need
bigger numbers than that, then you've got

01:01:54.110 --> 01:01:57.570
a very large application that you're working
with. And in that case, you're going to need

01:01:57.570 --> 01:02:01.400
to look into the big package from the math
library, which can handle arbitrarily large

01:02:01.400 --> 01:02:05.520
numbers. So you can't get a number big enough
for the big package to not be able to handle.

01:02:05.520 --> 01:02:09.480
Although working with numbers at large, you're
going to take a bit of a performance hit and

01:02:09.480 --> 01:02:12.760
the numbers aren't going to be quite as easy
to work with is using the primitive types

01:02:12.760 --> 01:02:18.330
that we're talking about here. Now related
to the signed integers are the unsigned integers.

01:02:18.330 --> 01:02:24.680
So we have the value 42 here, and just so
you can see, we can create an unsigned integer.

01:02:24.680 --> 01:02:31.350
And I'll just pick at you and 16 and assign
that the value of 42. And then let's go ahead

01:02:31.350 --> 01:02:36.690
and run that. And you see that now we have
a un 16. So there's an equivalent type of

01:02:36.690 --> 01:02:41.120
unsigned integer for every signed integer,
we have you int eight, which is an unsigned

01:02:41.120 --> 01:02:45.910
eight bit integer which can go from zero to
255. We have a 16 bit unsigned integer and

01:02:45.910 --> 01:02:51.340
a 32 bit unsigned integer. Now, what we don't
have is we don't have a 64 bit unsigned integer.

01:02:51.340 --> 01:02:57.170
But we do have a type byte. And a byte is
an alias for an eight bit unsigned integer.

01:02:57.170 --> 01:03:01.000
And the reason we have that is because the
unsigned eight bit integer is very common,

01:03:01.000 --> 01:03:04.290
because that's what a lot of data streams
are used to encode their data. Now with

01:03:04.290 --> 01:03:08.471
these integer types, and again, unsigned unsigned
integers are basically the same type, we've

01:03:08.471 --> 01:03:13.220
got several different arithmetic operations
that we can do. And these are built into the

01:03:13.220 --> 01:03:17.330
language. So if I just dropped in this example,
here, you see that we've got an integer, a

01:03:17.330 --> 01:03:21.280
set equal to 10. And we've got another integer
be set equal to three. And we're doing the

01:03:21.280 --> 01:03:23.440
basic arithmetic operations that are available
to

01:03:23.440 --> 01:03:24.440
us.

01:03:24.440 --> 01:03:28.740
So we can add, we can subtract, we can multiply,
we can divide, and then this percent sign

01:03:28.740 --> 01:03:33.240
here is actually used for the remainder. So
if I run this, you see that we get 10, plus

01:03:33.240 --> 01:03:38.570
three is 1310, minus three is seven, and so
on. So we get the numbers that we expect,

01:03:38.570 --> 01:03:42.970
then the one that you might not expect is
this a divided by b. So 10 divided by three

01:03:42.970 --> 01:03:46.800
is three, remainder one. And so we get the
result three out, because when you divide

01:03:46.800 --> 01:03:51.150
an integer by an integer, you have to get
an integer result. So the type cannot change

01:03:51.150 --> 01:03:55.100
during the operation. So when we do this,
we're doing what's called integer division,

01:03:55.100 --> 01:03:58.590
and we dropped the remainder. Now, if the
remainder is interesting, that's what this

01:03:58.590 --> 01:04:02.750
remainder operator is for. And then we can
pick up that remainder one out of it. Now,

01:04:02.750 --> 01:04:07.180
just like when we're doing division, we can't
change the type. So dividing an integer by

01:04:07.180 --> 01:04:10.870
an integer can't give us a floating point
number, for example, we're also not allowed

01:04:10.870 --> 01:04:15.830
to add to two integers of different types.
So if we take this as an example, we've got

01:04:15.830 --> 01:04:21.410
the integer, a set equal to 10, and an eight
bit integer set equal to three. And if we

01:04:21.410 --> 01:04:25.600
try and add those together, we're actually
going to get an error. So even though go might

01:04:25.600 --> 01:04:30.040
be able to do that, theoretically, it's very,
very insistent that it's not going to work

01:04:30.040 --> 01:04:34.690
across types without your consent. So in order
to make this work, we would actually have

01:04:34.690 --> 01:04:40.430
to do a type conversion on one of the variables
to convert it into the type of the other.

01:04:40.430 --> 01:04:45.130
So just like we talked about in the last video,
where go is very, very hesitant about implicit

01:04:45.130 --> 01:04:50.590
data conversion. This is another example.
Even though these integers are almost equivalent,

01:04:50.590 --> 01:04:54.320
go is not going to make that assumption for
you, you're going to have to do the type conversion.

01:04:54.320 --> 01:04:58.411
Now a couple of other operations that we have
are called the bit operators. So if I drop

01:04:58.411 --> 01:05:03.060
in this example, we see the full Bit operators
that we have, we've got the AND operator,

01:05:03.060 --> 01:05:08.670
we've got the OR operator, we've got the exclusive
OR operator, and we've got the and NOT operator.

01:05:08.670 --> 01:05:13.080
Now what's going to happen when we run this?
Well, let me just run this first and get these

01:05:13.080 --> 01:05:17.470
results. So you see that if we take a and
b, then we get two, if we take a or b, we

01:05:17.470 --> 01:05:21.800
get 11. And these might not make a lot of
sense. So in order to clear things up a little

01:05:21.800 --> 01:05:25.400
bit, let me put in the binary representation
of these. And then we can walk through what

01:05:25.400 --> 01:05:32.900
these are doing. So 10 is 1010, in binary
three is 0011. Now when we run into an end

01:05:32.900 --> 01:05:37.570
operation, that's going to look for what bits
are set in the first number and the second

01:05:37.570 --> 01:05:42.360
number. So as we can see, we've got four bits
in each one of these numbers that are allocated.

01:05:42.360 --> 01:05:46.250
Actually, these are 32, or 64 bits long, but
I'm ignoring all the zeros at the beginning

01:05:46.250 --> 01:05:50.810
of these numbers. So let's look at the four
digits that matter. So if we look at these,

01:05:50.810 --> 01:05:57.520
then we see actually, if we add these together,
we're going to get 0010. And in binary, that

01:05:57.520 --> 01:06:05.090
is two, so 10, and three equals two. Now if
we do the or, or means if one or the other

01:06:05.090 --> 01:06:11.520
is set, so we get one, because a has the first
bit set, neither one has the second bit set,

01:06:11.520 --> 01:06:15.910
both have the third bits set, so we're going
to include that, and then B has the last bit

01:06:15.910 --> 01:06:22.580
set. So we'll have that. So now we end up
with 1011, which is one plus two plus eight,

01:06:22.580 --> 01:06:28.150
which equals 11. Exclusive OR means either
one has the bit set, or the other does, but

01:06:28.150 --> 01:06:33.730
not both. So in that case, we're going to
do 1001. The only difference between this

01:06:33.730 --> 01:06:39.200
and the OR operation is that third bit where
they're both set to true. And therefore we're

01:06:39.200 --> 01:06:43.250
not going to include that. Now in the end
not that's kind of the opposite of or because

01:06:43.250 --> 01:06:48.520
within not, it's going to be set true only
if neither one of the numbers have the bit

01:06:48.520 --> 01:06:54.040
set. So since the first bit is set in a, we're
not gonna include that, neither one has the

01:06:54.040 --> 01:06:57.660
second bit set, so we're going to include
that both have the third bit set, so we're

01:06:57.660 --> 01:07:02.120
not going to include that. And B has the fourth
bit set. So we're not gonna include that.

01:07:02.120 --> 01:07:07.500
So we get 0100, which is equivalent to the
number eight. And that's how these bit operations

01:07:07.500 --> 01:07:12.190
work. The last example that I have to show
you with integers is what's called bit shifting.

01:07:12.190 --> 01:07:17.630
So when we have this example here, the first
print statement is going to bit shift a left

01:07:17.630 --> 01:07:22.650
three places. And the second is going a bit
shift a right three places. So let's run this

01:07:22.650 --> 01:07:28.010
and see what that's going to do. And so we
get to number 64, and one, so in order to

01:07:28.010 --> 01:07:33.250
understand that, let me go ahead and put in
these values, so we can understand what's

01:07:33.250 --> 01:07:39.170
going on. So eight is really two to the third
power. And when we do bit shifting, we're

01:07:39.170 --> 01:07:42.970
basically adding to that exponent, as long
as we're dealing with the power of two, because

01:07:42.970 --> 01:07:49.540
really, what we're going to do is we're going
to take this to to the third and multiply

01:07:49.540 --> 01:07:57.260
it by two to the third, which is equivalent
to two to the sixth, and two to the six is

01:07:57.260 --> 01:08:05.900
248 1632 64. So that's how we get the 64.
Now, when we bit shift to the right, we're

01:08:05.900 --> 01:08:10.280
going to take our original number, and we're
going to divide it by two to however hard

01:08:10.280 --> 01:08:13.690
we're shifting, so we're going to divide it
by two to the third. And in that case, we're

01:08:13.690 --> 01:08:17.109
going to get two raised to the zero power.
And any number greater than zero raised to

01:08:17.109 --> 01:08:19.299
the zero power is one.

01:08:19.299 --> 01:08:23.719
And so that's how those operations work. The
next data type that I want to talk about are

01:08:23.719 --> 01:08:27.219
the floating point types. So we have a lot
of different integer types. So we can store

01:08:27.219 --> 01:08:31.630
a lot of different size numbers. But with
integer types, we can only store integers,

01:08:31.630 --> 01:08:36.409
so they can be positive or negative integers
or zero, but we can't store decimal numbers.

01:08:36.409 --> 01:08:41.029
So in order to store decimal numbers in go,
we're going to use the floating point numbers.

01:08:41.029 --> 01:08:46.469
Now the floating point numbers in go follow
I triple E 754. Standard. And in that standard,

01:08:46.469 --> 01:08:50.230
we're going to pull out two of the types.
So we've got 32 bit floating point numbers

01:08:50.230 --> 01:08:54.650
and 64 bit floating point numbers. So if you're
working with a 32 bit floating point number,

01:08:54.650 --> 01:08:59.279
you can store numbers between plus or minus
1.18 times 10 to the negative 38, all the

01:08:59.279 --> 01:09:04.679
way up to 3.4 times 10 to the 38. So from
very small numbers to very large numbers.

01:09:04.679 --> 01:09:08.549
If you need even more precision than that,
then you can use a float 64. And that can

01:09:08.549 --> 01:09:14.210
go from plus or minus 2.23 times 10 to the
negative 308th, all the way through 1.8 times

01:09:14.210 --> 01:09:18.989
10 to the 308. So how do we create floating
point numbers? Well, here's some examples

01:09:18.989 --> 01:09:22.679
of how we can do that. So line eight here
shows you how you're going to define your

01:09:22.679 --> 01:09:27.400
flooding point literals almost all the time.
So we're going to declare a variable and set

01:09:27.400 --> 01:09:33.039
it equal to 3.14. And away we go. This next
line here shows that we can use exponential

01:09:33.039 --> 01:09:38.670
notation. So we can use 13.7 times 10 to the
72nd. And that's going to be able to use the

01:09:38.670 --> 01:09:43.639
short form iE 72nd to stand for that 10 to
the 72nd. So if I run this, we're actually

01:09:43.639 --> 01:09:50.210
going to get the final result here, of 2.1
times 10 to the 14th as a floating point 64.

01:09:50.210 --> 01:09:54.330
But notice we didn't get any errors. So all
three of those declarations, syntaxes are

01:09:54.330 --> 01:09:58.440
okay, so that's how we can work with floating
point numbers and show you how you can explicitly

01:09:58.440 --> 01:10:06.570
declare these We can use, let me just do var
and float 32, for example, and initialize

01:10:06.570 --> 01:10:10.429
that. And that's how you're going to declare
a floating point number. Now unfortunately,

01:10:10.429 --> 01:10:15.429
this number is a little big, because we can
only go times 10 to the 38th power. So if

01:10:15.429 --> 01:10:20.010
I comment that line out, things are going
to run properly. If I come back in and make

01:10:20.010 --> 01:10:25.820
this a floating point 64, then we can restore
this number. And that's another thing that's

01:10:25.820 --> 01:10:29.889
important. If you're going to use the initializer
syntax on a decimal, it's always going to

01:10:29.889 --> 01:10:34.659
be initialized to a float 64. So keep in mind,
you can't do arithmetic operations between

01:10:34.659 --> 01:10:40.070
float 64 and float 30 twos. So if you're just
using the initializer syntax, you're going

01:10:40.070 --> 01:10:43.969
to want to make sure that everything's working
as float 64. And if you forget, don't worry

01:10:43.969 --> 01:10:47.679
about it, the compiler will complain at you,
and you can quickly go in there and make sure

01:10:47.679 --> 01:10:51.671
that everything's working properly. Okay.
Now, speaking of arithmetic operations, let

01:10:51.671 --> 01:10:55.870
me jump in a couple of those. And you can
see the arithmetic operations that are available

01:10:55.870 --> 01:11:00.880
with floating point numbers. So if I run this,
we get the expected answers of adding, subtracting,

01:11:00.880 --> 01:11:04.960
multiplying dividing two numbers together.
Now, a couple things to notice here, when

01:11:04.960 --> 01:11:09.550
we divided A by B, we did in fact get a decimal
result, because as long as we're working with

01:11:09.550 --> 01:11:13.040
floating point numbers on both sides, we can
get a floating point result. As a matter of

01:11:13.040 --> 01:11:17.599
fact, we have to get a floating point result.
The other thing to notice, we don't have the

01:11:17.599 --> 01:11:22.110
remainder operator available that is only
available on the integer types. Further, we

01:11:22.110 --> 01:11:26.690
don't have the bitwise operators or the bit
shifting operators. So if you need to work

01:11:26.690 --> 01:11:30.179
with those, you're going to have to work with
the integer types. The last type of numeric

01:11:30.179 --> 01:11:34.159
primitive that we have available in go is
the complex type. And this is really kind

01:11:34.159 --> 01:11:38.550
of exciting because this is fairly rare in
the languages that I've worked with, where

01:11:38.550 --> 01:11:42.579
complex numbers are actually treated as a
first class citizen, and it opens up go to

01:11:42.579 --> 01:11:47.199
be used as a very powerful language for data
science. So if we come in and paste an example,

01:11:47.199 --> 01:11:51.260
you can see a very basic declaration of a
complex number. Now there are two types of

01:11:51.260 --> 01:11:57.400
complex numbers. There's complex 64, and complex
128. And the reason we have that is we're

01:11:57.400 --> 01:12:03.230
basically taking a float 64 plus a float 64,
or a float 32 plus a float 32 for the real

01:12:03.230 --> 01:12:07.390
and imaginary parts. Now here, I've got a
very simple complex number, that's one plus

01:12:07.390 --> 01:12:11.539
two I, if I go ahead and run that, you see
that in fact, it prints out as one plus two

01:12:11.539 --> 01:12:19.650
I and that's complex 64. So goes parser understands
the I literal as an imaginary number, and

01:12:19.650 --> 01:12:24.039
it uses that when you're creating your variable.
Now we can actually go even simpler than that,

01:12:24.039 --> 01:12:28.599
because AI is considered special. And we can
run this with just two AI and we get zero

01:12:28.599 --> 01:12:33.099
plus two I down here and the result. Now what
operations that we have available. Well, we

01:12:33.099 --> 01:12:37.289
can do addition, subtraction, multiplication,
and division again. So I've got two complex

01:12:37.289 --> 01:12:42.769
numbers defined here. If I run this, then
I get the expected result, where the real

01:12:42.769 --> 01:12:47.840
parts are added together, and the imaginary
parts are added together, or subtracted, multiplied,

01:12:47.840 --> 01:12:51.489
divide whatever operation we're applying.
Now, what happens if you need to decompose

01:12:51.489 --> 01:12:55.679
this down. So if I come back to our first
example, here, where we have one plus two

01:12:55.679 --> 01:12:59.889
I, not every operation that I'm going to do
with these numbers is going to need this to

01:12:59.889 --> 01:13:04.630
work as a complex number. So what happens
if I need to get at the real part or the imaginary

01:13:04.630 --> 01:13:09.600
part? Well, in order to do that, we actually
have two built in functions in the language.

01:13:09.600 --> 01:13:15.570
So let me wrap this in here with a call to
the real function. And then I can

01:13:15.570 --> 01:13:19.829
follow that up with its partner, which is
the image function. And what those are going

01:13:19.829 --> 01:13:22.800
to do is those are going to look at the complex
number that you provide. And they're going

01:13:22.800 --> 01:13:27.120
to pull out the real part or the imaginary
part. And these functions work with complex

01:13:27.120 --> 01:13:33.040
64 and complex 128. So if you run this on
the complex 64, then the real and the image

01:13:33.040 --> 01:13:37.239
function are going to give you float 30 twos
out, if you run this on complex 128, it's

01:13:37.239 --> 01:13:41.619
going to give you float 64 is out because
those are the data types used for the components.

01:13:41.619 --> 01:13:49.150
So if we run this, we see that we get float
32 is out. If we convert this to a 128 and

01:13:49.150 --> 01:13:52.739
run this again, then we're going to get float
64 is out. And it's going to break apart that

01:13:52.739 --> 01:13:56.769
complex number into the real and imaginary
part. So we can work with those however, we

01:13:56.769 --> 01:14:01.610
need to know the complement of these two functions
is the complex function. So if you're working

01:14:01.610 --> 01:14:05.210
along in your program, and all of a sudden
you need to make a complex number. How do

01:14:05.210 --> 01:14:10.130
you do that, because you can't use this literal
syntax. So in order to do that, we do have

01:14:10.130 --> 01:14:15.219
another function. And that's the complex function.
And this takes two numbers. The first number

01:14:15.219 --> 01:14:19.090
is the real part. And the second number is
the imaginary part. So let me go ahead and

01:14:19.090 --> 01:14:25.911
wipe out this line. Get rid of these real
calls here, and then run. And now that we

01:14:25.911 --> 01:14:29.679
see that we can take two floating point numbers.
In this case, they're considered to be floating

01:14:29.679 --> 01:14:35.989
point 60 fours because we're making a complex
128. And it creates five plus 12 I for us,

01:14:35.989 --> 01:14:40.090
the last data type that I want to talk about
is the text type. And texting go falls into

01:14:40.090 --> 01:14:45.000
two basic categories. One, I can talk a lot
about the other we're just going to touch

01:14:45.000 --> 01:14:50.320
on. So the first text type that we have available
is a string, and a string. Ingo stands for

01:14:50.320 --> 01:14:55.050
any UTF eight character, so that makes it
very powerful. But that means that strings

01:14:55.050 --> 01:14:59.340
cannot encode every type of character that's
available. For that we need the other text

01:14:59.340 --> 01:15:04.320
type which we'll talk about in a second. But
let's just start by introducing a basic example

01:15:04.320 --> 01:15:08.719
here. So here I've got a string literal, this
is a string, I'm going to print out its value

01:15:08.719 --> 01:15:12.429
and its type. So if I go ahead and run this,
you see that this is a string print out. And

01:15:12.429 --> 01:15:17.349
it's of type string. No big surprise here.
Now one of the interesting aspects of a string

01:15:17.349 --> 01:15:21.889
is I can actually treat it sort of like an
array. Now, we haven't talked about arrays

01:15:21.889 --> 01:15:27.119
yet. But I can actually treat this string
of text as a collection of letters. So if

01:15:27.119 --> 01:15:32.119
I do something like this, I'm actually going
to ask it for the third letter, because arrays

01:15:32.119 --> 01:15:36.750
and go are zero based. So I'm going to look
for the 012. That's the third letter in the

01:15:36.750 --> 01:15:41.550
string, which is the letter II. So if I run
this, I get an interesting result, I get the

01:15:41.550 --> 01:15:46.510
value 105. And that's a un eight. So what
the heck happened there? Well, what's happening

01:15:46.510 --> 01:15:51.699
is that strings and go are actually aliases
for bytes. So we can go ahead and convert

01:15:51.699 --> 01:15:57.410
this guy back, since a byte is just an alias
for a string, and we can get our letter I

01:15:57.410 --> 01:16:03.070
back. Now, strings are generally immutable.
So while I can inspect the second character,

01:16:03.070 --> 01:16:08.309
I can't do something like this, if I tried
to run this program, let me just print out

01:16:08.309 --> 01:16:12.519
the full string here and run this, then I
get an error. And there's actually quite a

01:16:12.519 --> 01:16:16.739
few things wrong with this. The first thing
is I can't assign a string to a byte because

01:16:16.739 --> 01:16:21.099
I'd have to do a conversion. The second thing
is I can't manipulate the value of the string.

01:16:21.099 --> 01:16:24.390
Now with the numeric types, I should do that
there were quite a few operations that we

01:16:24.390 --> 01:16:29.099
can perform with it, there is one arithmetic
or pseudo arithmetic operation that we can

01:16:29.099 --> 01:16:34.260
do with strings, and that is string concatenation.
Or in simpler terms, we can add strings together.

01:16:34.260 --> 01:16:38.010
So in this example, I've got the string s
and the string s two. And as you can see down

01:16:38.010 --> 01:16:41.650
in the printf statement, I'm adding s&amp;s two
together, and then we're going to print out

01:16:41.650 --> 01:16:46.199
the value in the type. So if I run this, you
see that it just merges all the strings together,

01:16:46.199 --> 01:16:50.489
and it gives us the result. Now another thing
that I can do with strings is I can actually

01:16:50.489 --> 01:16:55.659
convert them to collections of bytes, which
in go is called a slice of bytes. So in this

01:16:55.659 --> 01:17:00.420
example, I'm starting with a string, this
is a string, and then I'm going to do a conversion

01:17:00.420 --> 01:17:05.560
to this collection of bytes. And I'm going
to pass the string into that. So if we run

01:17:05.560 --> 01:17:11.409
that, we actually get this as a string comes
out as the ASCII values, or the UTF values

01:17:11.409 --> 01:17:15.860
for each character in that string. And then
you see that the result is a collection of

01:17:15.860 --> 01:17:20.320
UN eights, which is a type alias for bytes.
Now, why would you use this one? It's a very

01:17:20.320 --> 01:17:25.630
good question. A lot of the functions that
we're going to use in go actually work with

01:17:25.630 --> 01:17:30.179
byte slices. And that makes them much more
generic and much more flexible than if we

01:17:30.179 --> 01:17:35.680
work with hard coded strings. So for example,
if you want to send as a response to a web

01:17:35.680 --> 01:17:39.520
service call, if you want to send a string
back, you can easily convert it to a collection

01:17:39.520 --> 01:17:45.139
of bytes. But if you want to send a file back,
well, a file on your hard disk is just a collection

01:17:45.139 --> 01:17:49.099
of bytes, too. So you can work with those
transparently and not have to worry about

01:17:49.099 --> 01:17:53.239
line endings and things like that. So while
in your go programs, you're going to work

01:17:53.239 --> 01:17:57.239
with strings a lot as strings. When you're
going to start sending them around to other

01:17:57.239 --> 01:18:01.099
applications or to other services, you're
very often going to take advantage of this

01:18:01.099 --> 01:18:05.179
ability to just convert it to a byte slice.
Okay, the last primitive data type that we

01:18:05.179 --> 01:18:10.330
have to work with is called a rune. Now a
rune is a little bit different than a string

01:18:10.330 --> 01:18:16.889
type in go. Because we're a string type represent
any UTF eight character, a rune represents

01:18:16.889 --> 01:18:23.340
any UTF 32 character. Now, UTF 32 is a little
bit of a weird animal, because while any character

01:18:23.340 --> 01:18:29.719
in UTF, 32, can be up to 32 bits long, it
doesn't have to be 32 bits long. For example,

01:18:29.719 --> 01:18:35.989
any UTF eight character, which is eight bits
long, is a valid UTF 32 character. So there's

01:18:35.989 --> 01:18:39.849
all sorts of tricks that they have to do in
the encoding of the characters in order to

01:18:39.849 --> 01:18:45.849
know whether the character is one, two or
four bytes long. So that makes things a little

01:18:45.849 --> 01:18:49.800
bit tricky to work with and go. Now we're
not going to get too deep into this subject,

01:18:49.800 --> 01:18:53.409
we're just going to talk a little bit about
what runes are. And then I'm going to point

01:18:53.409 --> 01:18:57.550
you to some things that you can refer to if
you actually need to work with rooms in your

01:18:57.550 --> 01:19:03.849
application. So if we look at this example,
here, we're declaring the room a. Now notice

01:19:03.849 --> 01:19:07.630
the difference here, if we were declaring
a string, we would have double quotes. When

01:19:07.630 --> 01:19:11.910
we're declaring a single room, we use single
quotes. But if I run this, I'm going to get

01:19:11.910 --> 01:19:16.820
an interesting result. Notice I get the value
97. And it's an int 32. Now that might seem

01:19:16.820 --> 01:19:23.260
a little weird. And the reason for this is
because runes are just a type alias for int

01:19:23.260 --> 01:19:29.219
30. twos. So we're strings can be converted
back and forth between collections of bytes.

01:19:29.219 --> 01:19:34.329
Rooms are a true type alias. So when you talk
about a rune and go it is the same thing as

01:19:34.329 --> 01:19:39.269
talking about an integer 32 name, I think,
well, that's just because we're doing some

01:19:39.269 --> 01:19:44.449
implicit initialization here, we're using
that colon equals syntax. So let's specifically

01:19:44.449 --> 01:19:49.670
and explicitly declare this as a rune and
try this again. And we get the same result.

01:19:49.670 --> 01:19:55.369
And again, that's because a rune is an integer
32. Now, you might be feeling a little lost

01:19:55.369 --> 01:20:00.519
here. So if I've got a UTF 32 characters at
how do I work with that. Well, the Answer

01:20:00.519 --> 01:20:06.099
comes from the go API's. So if I jump out
to go lang.org, come into the packages. And

01:20:06.099 --> 01:20:10.639
let me just jump to the strings package. And
then I'll show you this. Notice this function

01:20:10.639 --> 01:20:17.219
here, read rune. So if you're working with
a data stream that's encoded in UTF 32, then

01:20:17.219 --> 01:20:20.269
you have special functions that you're going
to be able to take advantage of, that's going

01:20:20.269 --> 01:20:25.099
to return those values out. So if we do read
byte, which is going to read a single character,

01:20:25.099 --> 01:20:30.119
then we're going to get a bite out and a potential
error. But with read rune go is going to look

01:20:30.119 --> 01:20:34.289
at the byte stream, it's going to pull off
the next room that's available to you the

01:20:34.289 --> 01:20:37.929
size of that room, and then a potential error.
So you're going to have all the information

01:20:37.929 --> 01:20:43.179
you need in order to re encode that integer
32 that you're going to have back into its

01:20:43.179 --> 01:20:47.849
UTF 32 character. So things are a little bit
more tricky when you're working with runes.

01:20:47.849 --> 01:20:51.409
And you're going to have to read into the
API's for the go package that you're working

01:20:51.409 --> 01:20:57.280
with, in order to understand how to work with
them in your application. Okay, so that covers

01:20:57.280 --> 01:21:00.929
the primitive data types that you have to
work with and go, let's go into a summary

01:21:00.929 --> 01:21:04.780
and review what we've talked about in this
video.

01:21:04.780 --> 01:21:07.900
We covered a lot of ground in this video,
and I understand that it might take a little

01:21:07.900 --> 01:21:12.030
bit of time to process this and really understand
all the different options that you have for

01:21:12.030 --> 01:21:16.430
primitive data types and go. Now before we
get into the summary, I do want to let you

01:21:16.430 --> 01:21:20.340
know that a lot of times the default data
types that you're given are going to be perfectly

01:21:20.340 --> 01:21:22.940
fine. So if you're working with Boolean, you're
going to get a Boolean type, if you're working

01:21:22.940 --> 01:21:26.260
with integers, you're going to get that signed
integer type floating point, it's going to

01:21:26.260 --> 01:21:30.559
give you a floating point, 64, and so on.
So you don't have to memorize every single

01:21:30.559 --> 01:21:35.639
data type. If you need a specific data type,
then you can certainly refer to the NGO documentation

01:21:35.639 --> 01:21:39.320
in order to find out what's available for
you. So let's go through and review what we

01:21:39.320 --> 01:21:43.530
talked about. The first thing that we talked
about was the Boolean type of data, we found

01:21:43.530 --> 01:21:48.110
out that it can take two values true or false.
And it's not an alias for other types. So

01:21:48.110 --> 01:21:51.760
in some languages, a Boolean is actually an
alias for an integer. So you might use like

01:21:51.760 --> 01:21:56.880
negative one for true and zero for false when
go Boolean is its own type. So you can't convert

01:21:56.880 --> 01:22:00.530
back and forth between integers and things
like that, you're going to have to work with

01:22:00.530 --> 01:22:04.440
Boolean as their own type. We also talked
about the zero value for a Boolean is the

01:22:04.440 --> 01:22:08.409
value of false. And so if you initialize a
Boolean and don't set a value for it, it's

01:22:08.409 --> 01:22:13.480
going to receive the value false. Then we
talked about the numeric types. And the first

01:22:13.480 --> 01:22:16.670
type that we talked about were the integer
types. And that broke down into two different

01:22:16.670 --> 01:22:21.369
types with the signed integers. And there
are two classes, I guess you could say within

01:22:21.369 --> 01:22:25.480
the sign integer type. There's the INT type,
which has varying size, but a minimum of 32

01:22:25.480 --> 01:22:28.870
bits. And this is going to be the most common
type of integer you're going to deal with

01:22:28.870 --> 01:22:33.070
in your applications. But if you need a little
bit more granularity, or a little bit more

01:22:33.070 --> 01:22:36.659
resolution, or control over how much memory
is assigned to the integer, then you can go

01:22:36.659 --> 01:22:41.510
all the way from int eight, which is an eight
bit integer all the way up to 64 bit integer,

01:22:41.510 --> 01:22:45.769
we also have the unsigned integers where the
signed integers have a plus or minus and so

01:22:45.769 --> 01:22:51.070
they can't store numbers quite so large because
they have to store a plus or minus bit. The

01:22:51.070 --> 01:22:55.340
unsigned integers can store larger numbers,
but they can only ever be positive. And we

01:22:55.340 --> 01:22:59.200
have all the way through an eight bit which
we can use the byte or the UN eight, type

01:22:59.200 --> 01:23:06.920
four, all the way through 32 bit unsigned
integers with the un 32. We have various arithmetic

01:23:06.920 --> 01:23:10.350
operations that we can perform on both integer
types. So we can do addition, subtraction,

01:23:10.350 --> 01:23:14.869
multiplication, division, and that remainder
operation. So remember, division with integers

01:23:14.869 --> 01:23:19.010
is going to give you an integer result. So
you're going to lose that remainder portion.

01:23:19.010 --> 01:23:24.179
So if you need that, you can use that remainder
operator to get it. We also have the bitwise

01:23:24.179 --> 01:23:30.011
operators. So we can do and or Exclusive OR,
and the and not operations. And the zero value

01:23:30.011 --> 01:23:35.070
for any integer type is going to be the literal
value zero. So when you initialize an integer

01:23:35.070 --> 01:23:38.989
type, and don't assign a value to it, that's
going to be equivalent to the value zero,

01:23:38.989 --> 01:23:42.710
you're not just going to get whatever was
in memory when that variable is initialized,

01:23:42.710 --> 01:23:46.130
and you cannot mix types in the same family.
Now, this is going to be true throughout all

01:23:46.130 --> 01:23:50.840
of the numeric types. If you have a un 16,
for example, and a un 32. And you cannot add

01:23:50.840 --> 01:23:54.599
those together, you're going to get a compile
time error. The next numeric type that we

01:23:54.599 --> 01:23:56.000
talked about where the floating point

01:23:56.000 --> 01:23:57.000
numbers,

01:23:57.000 --> 01:24:01.790
so they follow the I triple E 754. Standard,
there's zero value is similar to the integer

01:24:01.790 --> 01:24:05.969
types, the value is zero. And we have two
different versions, we got 32 bit versions

01:24:05.969 --> 01:24:10.000
and 64 bit versions that we can work with.
And we have several different literal styles

01:24:10.000 --> 01:24:14.099
that we can use to initialize them. So we
can use a pure decimal like 3.14, we can use

01:24:14.099 --> 01:24:19.559
exponential notation, for example, 13 e 18,
or two e 10. And it doesn't matter if that

01:24:19.559 --> 01:24:25.320
e is upper or lowercase, or you can do mixed.
So for example, 13.7 e 12 is a perfectly acceptable

01:24:25.320 --> 01:24:29.630
way to initialize that. We do have addition,
subtraction, multiplication and division that

01:24:29.630 --> 01:24:34.039
we can do with floating point numbers. Now
we don't have the remainder operation, but

01:24:34.039 --> 01:24:37.940
the division operation is going to give us
a true floating point result. So we're not

01:24:37.940 --> 01:24:41.000
going to lose our decimal portion. The final
numeric type that we talked about were the

01:24:41.000 --> 01:24:46.960
complex numbers. The zero value of a complex
number is zero plus zero I and they come in

01:24:46.960 --> 01:24:51.250
64 and 28 bit versions and the reason for
that is the two components, the real and the

01:24:51.250 --> 01:24:56.030
imaginary component are either going to be
floating point 32 or floating point 64. So

01:24:56.030 --> 01:24:59.909
when you add those together, that's where
you get the 64 and 128 bit versions. We have

01:24:59.909 --> 01:25:04.030
Some built in functions that we can work with.
So we can use the complex function in order

01:25:04.030 --> 01:25:08.699
to create a complex number, we can use the
real function in order to get the real component.

01:25:08.699 --> 01:25:12.699
And we can use the match function in order
to get the imaginary component of a complex

01:25:12.699 --> 01:25:16.719
number. Now what the data type that comes
out of that depends on the size of the complex

01:25:16.719 --> 01:25:22.050
number going in. So complex 64 is going to
give you a float 32 out from the real in the

01:25:22.050 --> 01:25:26.530
match function and a complex 128 is going
to give you a float 64 out of the real in

01:25:26.530 --> 01:25:30.710
the match function, we have the same arithmetic
operations as we do for floating point numbers,

01:25:30.710 --> 01:25:35.710
we can do addition, subtraction, multiplication
and division. The final category of primitive

01:25:35.710 --> 01:25:39.809
data that we talked about, or the text types,
and in go, there are really two different

01:25:39.809 --> 01:25:43.920
text types. The most common one that you're
probably going to deal with are strings. No

01:25:43.920 --> 01:25:48.489
Strings are represented as a collection of
UTF eight characters, they're immutable, you

01:25:48.489 --> 01:25:52.809
cannot change the value of a string after
it's been initialized. You can concatenate

01:25:52.809 --> 01:25:57.780
strings together with the plus operator. And
then you can convert them back and forth between

01:25:57.780 --> 01:26:02.989
a collection of bytes with this square bracket
byte syntax and passing in the string that'll

01:26:02.989 --> 01:26:06.510
convert it to a collection of bytes. And you
can convert a collection of bytes back to

01:26:06.510 --> 01:26:11.119
a string by using the string conversion. The
other type we talked about is a rune and a

01:26:11.119 --> 01:26:16.120
rune represents any UTF 32 character. Now
runes are a little bit more complicated to

01:26:16.120 --> 01:26:20.119
work with because of the multi step process
that it takes in order to encode a character

01:26:20.119 --> 01:26:25.820
into the UTF 32 character set. So when we're
working with runes as a primitive type, really

01:26:25.820 --> 01:26:30.289
all we're working with is an alias for an
integer 32. Today, I want to talk about constants

01:26:30.289 --> 01:26:34.579
and how you can use them in your NGO applications.
Now, there are several things that we need

01:26:34.579 --> 01:26:38.260
to talk about with constants. So like we've
been doing, I want to break this down into

01:26:38.260 --> 01:26:42.130
several categories. The first thing that I
want to talk about is how we're going to name

01:26:42.130 --> 01:26:48.010
constants in our NGO applications. Then we'll
talk about type constants, followed by a discussion

01:26:48.010 --> 01:26:52.300
about untyped constants. And we'll talk about
the differences between those two, and the

01:26:52.300 --> 01:26:56.480
options that each one gives us. And then we'll
talk about a method of generating constants

01:26:56.480 --> 01:27:00.429
that are called enumerated constants. And
finally, we'll end our discussion by talking

01:27:00.429 --> 01:27:04.611
about enumeration expressions, which are going
to build upon the concepts that we're going

01:27:04.611 --> 01:27:09.510
to talk about in that first enumeration discussion.
The first thing that I want to talk about

01:27:09.510 --> 01:27:13.309
is how we're going to name our constants.
So all constants are going to be preceded

01:27:13.309 --> 01:27:17.199
with the const keyword, that's going to let
the compiler know that that's what we're trying

01:27:17.199 --> 01:27:21.340
to work with. Now, if you've come from other
languages, you might be expecting that we're

01:27:21.340 --> 01:27:24.999
going to name our constants, something like
this, where we're going to have all uppercase

01:27:24.999 --> 01:27:30.460
letters and separate the words with underscores.
The problem with that is if we do that and

01:27:30.460 --> 01:27:35.510
go, then the first letter is going to be uppercase.
And as you remember, from our discussion on

01:27:35.510 --> 01:27:39.019
variables, if we've got an uppercase first
letter, that's going to mean that the constant

01:27:39.019 --> 01:27:43.329
is going to be exported. And we don't always
want that. So instead of this, we're actually

01:27:43.329 --> 01:27:46.309
going to name our constants the same way that
we named variables.

01:27:46.309 --> 01:27:50.199
So if we had a variable that we wanted to
call my const, and we didn't want to export

01:27:50.199 --> 01:27:54.270
it, then we would start with a lowercase first
letter, or in other words, we would use camel

01:27:54.270 --> 01:27:58.469
casing. And if we did want to export this
symbol, then we would simply change that first

01:27:58.469 --> 01:28:02.369
character to uppercase. Now assuming that
we're going to be working with an internal

01:28:02.369 --> 01:28:06.480
constant, then we're going to switch this
back to a lowercase first letter. And then

01:28:06.480 --> 01:28:10.920
let's talk about how we can create what's
called a typed constant. Now a typed constant

01:28:10.920 --> 01:28:15.579
is created very similarly to a typed variable.
So we can start with the const keyword, then

01:28:15.579 --> 01:28:19.579
the name of our constant, and then we're going
to list the type of the content, and then

01:28:19.579 --> 01:28:24.140
we can set it equal to a value, then if we
want to prove that that worked out the way

01:28:24.140 --> 01:28:28.849
we expected it to, then we can go ahead and
print out the value in the type of the constant.

01:28:28.849 --> 01:28:35.079
And we will do that by using this printf statement
here. And then when we run this, we see that

01:28:35.079 --> 01:28:39.059
the constant is in fact created. It's got
the value 42 that we assigned, and it's got

01:28:39.059 --> 01:28:43.670
the type that we assigned to it. Now the reason
it's a constant and not a variable is it has

01:28:43.670 --> 01:28:48.849
to remain constant. So if we tried to do something
like this, change this to the value 27, then

01:28:48.849 --> 01:28:52.940
the compiler throws an error, because we're
not allowed to change the value of a constant.

01:28:52.940 --> 01:28:57.449
Another characteristic of a constant is that
it has to be assignable at compile time. So

01:28:57.449 --> 01:29:01.969
for example, if I wanted to have a constant
that represented the sine of pi over two,

01:29:01.969 --> 01:29:06.679
then I might be tempted to do something like
this. I'll create a float 64 constant. And

01:29:06.679 --> 01:29:11.079
I'll set it equal to the result of the sine
function from the math library. And I'll pass

01:29:11.079 --> 01:29:16.639
in 1.57, which is approximately pi over two.
And then I can run this right? Well, the problem

01:29:16.639 --> 01:29:21.099
with that is in order to determine the sine
of that value, that actually requires the

01:29:21.099 --> 01:29:25.800
function to execute, which is not allowable
at compile time. And so you can't set your

01:29:25.800 --> 01:29:30.789
constants equal to something that has to be
determined at runtime. And that includes things

01:29:30.789 --> 01:29:34.249
like setting it equal to flags that you pass
into your application, when you run, if you're

01:29:34.249 --> 01:29:38.440
going to do that you can't use a constant
to store that value. Now constants can be

01:29:38.440 --> 01:29:42.539
made up of any of the primitive types that
we talked about in the last video. So if we

01:29:42.539 --> 01:29:45.989
have this example, here, we've got an integer
constant, we've got a string constant, a floating

01:29:45.989 --> 01:29:51.310
point constant and a Boolean constant. And
if we run this, we see that all of those printout

01:29:51.310 --> 01:29:54.630
exactly the way that we expect. We've got
the integer the string, the floating point

01:29:54.630 --> 01:29:58.610
value and the boolean value. Now in an upcoming
video, we're going to talk about the collection

01:29:58.610 --> 01:30:02.570
types and the collection types. are inherently
mutable. So for example, you couldn't create

01:30:02.570 --> 01:30:07.650
an array and declare that to be a constant
type. Arrays are always going to be variable

01:30:07.650 --> 01:30:12.090
types. Now another characteristic that constants
have in common with variables is they can

01:30:12.090 --> 01:30:16.960
be shadowed. So if we create a constant at
the package level, and let's just make this

01:30:16.960 --> 01:30:22.659
an integer 16, and set it equal to the value
27, then we'll delete these guys. And also

01:30:22.659 --> 01:30:27.329
these guys. Now we've got a constant called
a declared at the package level, that's an

01:30:27.329 --> 01:30:31.889
integer 16. And then we got a constant in
the main function, that's also called a and

01:30:31.889 --> 01:30:37.460
it's an integer type. So if we update This
printf statement to print the type of variable,

01:30:37.460 --> 01:30:44.020
we see that the looks like I need to print
my variable twice, we see that the inner declaration

01:30:44.020 --> 01:30:48.830
of the constant wins. So not only can we change
the value of the constant, but we can also

01:30:48.830 --> 01:30:53.560
change the type because the inner constant
shadows that outer constant. And we can prove

01:30:53.560 --> 01:31:00.139
that by commenting this line out, running
again. And we see that the package level constant

01:31:00.139 --> 01:31:03.889
wins. So you want to be a little careful here,
because if you're going to reuse constant,

01:31:03.889 --> 01:31:07.869
it's going to feel like those values are changing.
So I wouldn't recommend that you take advantage

01:31:07.869 --> 01:31:11.440
of this. But if you do get into a situation
where constants aren't evaluating the way

01:31:11.440 --> 01:31:15.920
that you expect them to, this is one possible
reason. Now when we're working with constants,

01:31:15.920 --> 01:31:20.599
they work very similar to variables when we're
using them in operations. So if we bring this

01:31:20.599 --> 01:31:28.519
line back, and set it equal to 42, and then
what I want to do is declare a variable. So

01:31:28.519 --> 01:31:33.780
we'll declare a variable b as an integer,
and set that equal to the value 27. And then

01:31:33.780 --> 01:31:39.590
we can do a plus b. And let's see what happens
when we do that. So if we run that, we in

01:31:39.590 --> 01:31:44.260
fact, get the ability to add a constant to
a variable, and the result is going to be

01:31:44.260 --> 01:31:48.219
a variable. And so since the constant and
the variable are of the same type, we can

01:31:48.219 --> 01:31:52.850
perform the addition operation on there. Now,
our constant is of a different type. For example,

01:31:52.850 --> 01:31:57.620
if we made variable b in 16, and run this,
then we get exactly the same failure that

01:31:57.620 --> 01:32:02.670
we get when we try and add two variables of
different types together. Now, so far, all

01:32:02.670 --> 01:32:06.230
we've been talking about are these type constants,
we're after the constant name, we list the

01:32:06.230 --> 01:32:12.599
type. But we don't have to do that, we can
use the compilers ability to infer the type

01:32:12.599 --> 01:32:17.440
for us. So let's just go ahead and do that
with this example here. When we run this,

01:32:17.440 --> 01:32:23.920
we see that the constant a is inferred to
be an integer with the value 42. Now given

01:32:23.920 --> 01:32:27.599
that, given that the compiler is inferring
the value, what do you think is going to

01:32:27.599 --> 01:32:33.960
happen? If we do something like this, if we
restore that previous example, where we're

01:32:33.960 --> 01:32:39.220
going to add this constant to an integer 16?
Well, in fact, in this case, the operation

01:32:39.220 --> 01:32:43.909
succeeds, which might be a little bit confusing.
But the reason that works is because what

01:32:43.909 --> 01:32:49.300
the compiler is actually doing, when it sees
this constant is it's basically replacing

01:32:49.300 --> 01:32:56.449
every instance. So the way the compiler sees
this program is it sees it like this. So since

01:32:56.449 --> 01:33:02.710
we're taking a literal 42, and adding an int
16 to it, that 42 is interpreted as being

01:33:02.710 --> 01:33:08.690
an integer 16. So the compiler doesn't say,
oh, constant, a equals 42, that's an integer

01:33:08.690 --> 01:33:13.749
and always an integer. Instead, the compiler
is going to look for every time that we use

01:33:13.749 --> 01:33:18.820
the symbol a, and it's going to replace that
with the value of the constant. And so we

01:33:18.820 --> 01:33:23.190
can do these implicit conversions when we're
working with constants, which is something

01:33:23.190 --> 01:33:27.210
that we can't really do when we're working
with variables. The next thing that I want

01:33:27.210 --> 01:33:32.060
to talk about are what are called enumerated
constants. So let me go ahead and start that

01:33:32.060 --> 01:33:36.679
conversation out by wiping out what we have
here, clean up our code just a little bit.

01:33:36.679 --> 01:33:39.949
And then I'm going to do this at the package
level. Because this is where I've seen these

01:33:39.949 --> 01:33:43.869
most commonly applied, you could do these
in a function level, if that made sense in

01:33:43.869 --> 01:33:48.369
your application. So I'm going to declare
a constant a, and I'm going to have that as

01:33:48.369 --> 01:33:52.920
an untyped constant. And I'm going to set
it equal to this special symbol called Iota.

01:33:52.920 --> 01:33:57.710
So when I run this, you see that a is evaluated
to have the value zero, and it's inferred

01:33:57.710 --> 01:34:04.329
to have the type integer. So what is Iota?
Well, Iota is a counter that we can use when

01:34:04.329 --> 01:34:09.559
we're creating what are called enumerated
constants. So in this example, having an enumerated

01:34:09.559 --> 01:34:13.900
constant isn't terribly valuable. But one
of the things that I can do with constants

01:34:13.900 --> 01:34:18.790
is I can actually work with them in a constant
block like this. So when I'm doing this, I

01:34:18.790 --> 01:34:22.980
can create another constant set that equal
to Iota and another constant and set that

01:34:22.980 --> 01:34:29.519
equal to it, let's go ahead and clean up this
because we already know what the type is going

01:34:29.519 --> 01:34:32.860
to be. So we don't need to be printing that
out. And then let's print this command out

01:34:32.860 --> 01:34:39.989
two more times, switching to B, and C. So
now we're using Iota three times and when

01:34:39.989 --> 01:34:45.769
we get the result we actually see Iota is
changing its value as the constants are being

01:34:45.769 --> 01:34:51.420
evaluated. So the first constant that's assigned
has the value of zero than one and then to

01:34:51.420 --> 01:34:56.429
know another special feature that we can take
advantage of with Iota is that if we don't

01:34:56.429 --> 01:35:01.780
assign the value of a constant after the first
one, then the Pilar is going to try and infer

01:35:01.780 --> 01:35:06.630
the pattern of assignments. So in this example,
we would expect to have an error because B

01:35:06.630 --> 01:35:11.699
and C don't have a value assigned. But since
we've established a pattern for how to name

01:35:11.699 --> 01:35:16.760
the constants in this block, when we run,
we actually get the same result. And that's

01:35:16.760 --> 01:35:20.650
because the compiler is going to apply the
same formula. So it's going to apply b equals

01:35:20.650 --> 01:35:27.479
Iota and C equals Iota for us. Now that value
of Iota is scoped to that constant block.

01:35:27.479 --> 01:35:33.150
So we create another constant block. And in
this case, we create a constant called a two

01:35:33.150 --> 01:35:39.360
and set that equal to Iota, copy this line,
bring it down, and print out the value of

01:35:39.360 --> 01:35:45.670
a two, then what we're gonna find is Iota
resets to zero. So Iota is scoped to a constant

01:35:45.670 --> 01:35:50.950
block. And what that lets you do is you can
actually create related constants together,

01:35:50.950 --> 01:35:55.999
ensure that they have different values. And
then if you have another set of related constants,

01:35:55.999 --> 01:36:01.960
you can start another constant block and ensure
that they have unique values, but allow duplication

01:36:01.960 --> 01:36:05.979
between the values in one constant block in
another. So what's an example where you might

01:36:05.979 --> 01:36:11.810
use this? Well, let me just drop in this simple
application. And what we're doing here is

01:36:11.810 --> 01:36:17.999
we're setting up a constant block, where maybe
we're trying to store the specialty of veterinarians

01:36:17.999 --> 01:36:22.420
in a veterinarian clinic so that our narine
could be a cat specialist or a dog specialist,

01:36:22.420 --> 01:36:27.869
or maybe we can take his neck specialist to.
Now as you can see, inside the cost box, I'm

01:36:27.869 --> 01:36:33.670
setting the cat specialist equal to Iota.
And then in the main block, I'm creating a

01:36:33.670 --> 01:36:38.320
variable and setting its value equal to cat
specialist. So if I check to see if the specialist

01:36:38.320 --> 01:36:44.119
type is a cat specialist, then I in fact,
get the value true. Now, that works just fine.

01:36:44.119 --> 01:36:50.369
And this also works if I, for example, use
a dog specialist, assign that specialist type

01:36:50.369 --> 01:36:54.639
to be a dog specialist run that, then that's
going to work out just fine. So everything

01:36:54.639 --> 01:37:00.230
looks really good here, right? And this is
a very common use for enumerated constants.

01:37:00.230 --> 01:37:01.349
However, one thing

01:37:01.349 --> 01:37:05.559
that I would warn you about is what happens
if I declare this variable and don't initialize

01:37:05.559 --> 01:37:11.679
it to a type? Well, if I check to see if it's
dog specialist, I get false, which makes sense.

01:37:11.679 --> 01:37:17.190
But remember, what is the initial value of
Iota? Well, the initial value of Iota equals

01:37:17.190 --> 01:37:21.880
the zero value for an integer. And so in fact,
even though we haven't specified a specialist

01:37:21.880 --> 01:37:27.301
type, it does show up as the value can't specialist.
So what do we do about this, so there's a

01:37:27.301 --> 01:37:34.420
couple of approaches that we can take here.
The first is to use the zero value of the

01:37:34.420 --> 01:37:40.170
constant as an error value. So we can set
this equal to error, then we don't need this

01:37:40.170 --> 01:37:45.369
statement anymore. And now when we check to
see if the specialist type is a cat specialist,

01:37:45.369 --> 01:37:50.199
we get the value false because cat specialists
is equivalent to the integer value one, which

01:37:50.199 --> 01:37:55.570
is no longer the zero value of the integer.
This is a very valuable approach, if you want

01:37:55.570 --> 01:38:01.030
to check to see if a value hasn't been assigned
to a constant yet, so you can specify an error

01:38:01.030 --> 01:38:04.621
specialist. And then you can check to see
if that value is set equal to the zero value

01:38:04.621 --> 01:38:07.790
of that constant. And if it is, you can handle
that error,

01:38:07.790 --> 01:38:08.790
because

01:38:08.790 --> 01:38:13.010
presumably, you expect that to be initialized
in some way. Now, if your application guards

01:38:13.010 --> 01:38:16.989
against that, and there's no reasonable way
for this to happen, then you can take advantage

01:38:16.989 --> 01:38:22.690
of this underscore symbol, which is goes one
and only write only variable. Now what's the

01:38:22.690 --> 01:38:28.059
value of a write only variable? Well, with
Iota, we have to have a zero value, we always

01:38:28.059 --> 01:38:32.900
have to start with zero. But if we don't care
about zero, then we don't have any reason

01:38:32.900 --> 01:38:36.420
to assign the memory to it. So we can use
this underscore symbol. And we'll see this

01:38:36.420 --> 01:38:40.690
in quite a few places in our go applications.
And basically, what that tells the compiler

01:38:40.690 --> 01:38:44.500
is yes, I know you're going to generate a
value here, but I don't care what it is go

01:38:44.500 --> 01:38:49.190
ahead and throw that away. So if we run our
application, again, everything works just

01:38:49.190 --> 01:38:54.600
fine. But in this case, we can't actually
get at the zero value of this constant block.

01:38:54.600 --> 01:38:59.400
Now the ability to create it lists of enumerated
constants with a Oda is very valuable. But

01:38:59.400 --> 01:39:03.769
things don't actually stop there. And the
reason is, remember, the value of a constant

01:39:03.769 --> 01:39:08.309
has to be able to be determined at compile
time, but there are some operations that go

01:39:08.309 --> 01:39:15.059
is going to allow us to do for example, we
can do addition. So if we do this and run,

01:39:15.059 --> 01:39:22.510
then we get false again. But what happens
if we print out the value of kept specialist

01:39:22.510 --> 01:39:28.190
if we do that, and we're going to have to
remove this line, then in fact, that expression

01:39:28.190 --> 01:39:34.060
got evaluated. So the first line line eight
is evaluated to Iota plus five, which is zero

01:39:34.060 --> 01:39:40.510
plus five, the next line cat specialist, Iota
increments, and the formula repeats. So cat

01:39:40.510 --> 01:39:44.499
specialist is equal to the value six, dog
specialist is seven, and snake specialist

01:39:44.499 --> 01:39:49.690
is eight. So this can be valuable if you need
some kind of a fixed offset. Now a common

01:39:49.690 --> 01:39:54.719
use case for this is to use the bit shifting
operators because anything that we can apply

01:39:54.719 --> 01:39:59.610
to our primitive type, we can apply here as
long as it's not a function expression. So

01:39:59.610 --> 01:40:04.289
we can do addition, subtraction, multiplication
and division, we can do remainder operations,

01:40:04.289 --> 01:40:08.780
we can do the bitwise operations. And we can
do bit shifting, which is one of the more

01:40:08.780 --> 01:40:13.940
interesting use cases that we can take advantage
of. And the reason is because we don't have

01:40:13.940 --> 01:40:18.940
the ability to raise two powers because raising
two powers and go is a function in the math

01:40:18.940 --> 01:40:25.519
package. So we can't do that in our constant
evaluations. But by bit shifting, we can raise

01:40:25.519 --> 01:40:29.780
things to the power of two, because every
time you shift the number one level, you're

01:40:29.780 --> 01:40:34.070
actually multiplying it by two. So we have
this example here. And I actually stole this

01:40:34.070 --> 01:40:39.519
from the effect of go article on golang.org.
So what we have here is we have an example

01:40:39.519 --> 01:40:44.969
of a constant block that's giving you constants
that are equivalent to kilobyte, megabyte,

01:40:44.969 --> 01:40:49.349
gigabyte, terabyte, petabyte, and so on. So
down here, in our main program, what I've

01:40:49.349 --> 01:40:54.429
done is initialize the file size to some arbitrary
value. And then I've got this printf statement.

01:40:54.429 --> 01:40:58.100
And this is basically going to format a result
to print two decimal places, and then the

01:40:58.100 --> 01:41:03.420
literal string GB afterward. So this string
here is basically saying I'm expecting to

01:41:03.420 --> 01:41:07.620
format a floating point number, and I'm going
to give it two decimal places, this GB is

01:41:07.620 --> 01:41:11.690
a literal GB, that's going to be printed in
the result. And then we've got the value that's

01:41:11.690 --> 01:41:17.499
going to be used to fill this in. And that's
going to be file size divided by the GB constant.

01:41:17.499 --> 01:41:21.210
Now you notice this constant block is set
equal to one, and then we're going to bit

01:41:21.210 --> 01:41:26.830
shift that value 10 times Iota. So the first
time we're going to bit shift 10 times one,

01:41:26.830 --> 01:41:30.480
so we're basically going to multiply this
by two to the 10th. And then we're going to

01:41:30.480 --> 01:41:35.230
multiply by two to the hundreds for the megabyte,
and then two to the 1004, gigabyte, and so

01:41:35.230 --> 01:41:41.900
on. So when we run this, we get a really convenient
way to format an arbitrary file size into

01:41:41.900 --> 01:41:46.170
a human readable format. And in the effective
go article, it actually shows you how to put

01:41:46.170 --> 01:41:50.380
a switch block, which we haven't talked about.
So you can make a decision about which constant

01:41:50.380 --> 01:41:54.210
you're going to use based on the size of the
incoming value. So here, we get this nice

01:41:54.210 --> 01:42:02.060
way to format this relatively difficult number
to read to be the very easily read 3.73 gigabytes.

01:42:02.060 --> 01:42:06.690
Now another thing that can be very valuable
to do is using bit shifting in order to set

01:42:06.690 --> 01:42:13.010
Boolean flags inside of a single byte. So
if I paste this example in, we can see an

01:42:13.010 --> 01:42:16.639
example of that. So let's just say that we've
got an application and that application has

01:42:16.639 --> 01:42:21.979
users and those users have certain roles.
So inside of this constant block, here, I'm

01:42:21.979 --> 01:42:25.920
defining various roles that we can have. So
for example, you might be an admin, you might

01:42:25.920 --> 01:42:30.099
be at the headquarters or out in the field
somewhere, you might be able to see the financials

01:42:30.099 --> 01:42:34.480
or see the monetary values. And then there
may be some regional roles. So can you see

01:42:34.480 --> 01:42:39.199
properties in Africa, can you see properties
in Asia, Europe, North America, or South America.

01:42:39.199 --> 01:42:44.070
So in order to define these constants, what
I'm doing is I'm setting the value to one

01:42:44.070 --> 01:42:51.539
bit shifted biota. So the first constant is
admin is one bit shifted zero places, so it's

01:42:51.539 --> 01:42:57.699
a literal one, the second one is one bit shifted
one place, that's two, and then four, and

01:42:57.699 --> 01:43:00.310
then eight, and then 16, and so on.

01:43:00.310 --> 01:43:05.780
So what I have is each one of these constants
is going to occupy one location in a byte.

01:43:05.780 --> 01:43:10.729
So down here in the main program, I'm defining
the roles in a single byte. And I'm oaring

01:43:10.729 --> 01:43:16.510
together is admin can see financials and can
see Europe now if you remember, oaring, is

01:43:16.510 --> 01:43:21.469
going to be set to true if one of the values
is true, or the other one. So his admin has

01:43:21.469 --> 01:43:27.659
the binary representation of 0000001. I think
that's enough zeros, seven zeros, followed

01:43:27.659 --> 01:43:34.039
by one can see financials is going to end
up with 100, can see Europe is going to end

01:43:34.039 --> 01:43:40.579
up with the value 100000. And so when we order
those all together, we're going to get this

01:43:40.579 --> 01:43:47.769
byte that has these three flags set to true.
So when we run this, we see that we've encoded

01:43:47.769 --> 01:43:53.150
eight access roles for user into a single
byte of data. So we're able to store this

01:43:53.150 --> 01:43:57.949
information extremely efficiently. So if I
want to see for example, if this user is an

01:43:57.949 --> 01:44:05.090
admin, I can go ahead and print his admin,
and then print out the value. And then in

01:44:05.090 --> 01:44:09.329
order to determine if that's valid or not,
then I can do a little bit of bitwise mathematics

01:44:09.329 --> 01:44:15.659
here. So I can take the constant is admin,
and that with the roles, and what that's going

01:44:15.659 --> 01:44:20.110
to do is that's going to apply what's called
a bit mask. So only the bits that are set

01:44:20.110 --> 01:44:24.849
in the is admin constant, and our roles are
going to be left as true, which means if we're

01:44:24.849 --> 01:44:29.280
an admin, we're going to have the value one
set at that first bit. And then I can compare

01:44:29.280 --> 01:44:35.630
that to the is admin constant. So when I run
this, if we have the admin role, then we're

01:44:35.630 --> 01:44:39.571
going to get the value true. Now, if I check
something that I don't have the role, so let

01:44:39.571 --> 01:44:46.790
me go ahead and copy this down. And then let's
just see if they're at the headquarters, so

01:44:46.790 --> 01:44:52.249
we'll put that in here. And it's exactly the
same bitwise operations, we're just changing

01:44:52.249 --> 01:45:00.639
our mask. If we run this, we see that is headquarters
equals false Actually, let me put in my Line

01:45:00.639 --> 01:45:05.440
return here, and then run this again. And
you see that is headquarters equals false.

01:45:05.440 --> 01:45:09.909
So we can very quickly and very efficiently
store a lot of different information about

01:45:09.909 --> 01:45:14.889
what roles and access rights a user might
have, and a simple byte. And having this constant

01:45:14.889 --> 01:45:19.619
defined with a numeration expression makes
it really fast and really efficient and really

01:45:19.619 --> 01:45:23.619
clear in our application. Okay, so let's go
into a summary and review what we've talked

01:45:23.619 --> 01:45:28.789
about in this video. constants are another
one of those foundational elements, that is

01:45:28.789 --> 01:45:32.729
going to be a part of almost every application
you're going to write. Now, the first thing

01:45:32.729 --> 01:45:37.099
that we learned about with constants is that
they're immutable, but they can be shadowed.

01:45:37.099 --> 01:45:42.309
So we can create a constant, we cannot assign
a new value to it. But if we create a constant

01:45:42.309 --> 01:45:47.150
on an inner scope from an existing constant,
then not only can we change the value, but

01:45:47.150 --> 01:45:51.630
we can even change the type, because that
inner scope is going to shadow the outer scope

01:45:51.630 --> 01:45:56.969
constant, they have to be replaceable by the
compiler at compile time, so the value must

01:45:56.969 --> 01:46:01.420
be calculable. So we're not gonna be able
to access functions or command line arguments

01:46:01.420 --> 01:46:05.940
in order to determine the value of the constants
in our application. But we are going to be

01:46:05.940 --> 01:46:10.889
able to do simple expressions like we talked
about in the enumeration section. They're

01:46:10.889 --> 01:46:14.570
named like variables. So if you want to export
the value of the constant outside of your

01:46:14.570 --> 01:46:18.989
package, then you're going to use Pascal casing.
And if you want to leave it as an internal

01:46:18.989 --> 01:46:24.150
value to the package, then you're going to
use camel casing to name that constant. Type

01:46:24.150 --> 01:46:28.989
constants work just like immutable variables.
So you can use them in arithmetic operations,

01:46:28.989 --> 01:46:34.179
you can pass them into functions, but they
can only interoperate with the same type untyped

01:46:34.179 --> 01:46:39.229
constants have a little bit more flexibility.
So they work just like the literals. So if

01:46:39.229 --> 01:46:43.090
you replace that constant throughout your
application with the literal value of that

01:46:43.090 --> 01:46:46.140
constant, that's how it's going to work. So
that's going to allow us to interoperate with

01:46:46.140 --> 01:46:51.510
similar types. So we had the value 42 defined
as an untyped constant. And we could add that

01:46:51.510 --> 01:46:56.579
to an integer 16, we could add that to an
integer, we can add that to a un 16. Any of

01:46:56.579 --> 01:47:02.550
those would work, because the literal 42 will
work in all of those cases. Then we talk about

01:47:02.550 --> 01:47:07.429
the enumeration types that we can work with.
And we learned about the special symbol Iota.

01:47:07.429 --> 01:47:12.550
That allows us to start with as values zero
and increments one time every time we use

01:47:12.550 --> 01:47:16.570
it inside the same const block. Now the one
thing that we have to watch out for is that

01:47:16.570 --> 01:47:21.110
constant values that match the zero values
of variables can cause subtle bugs in your

01:47:21.110 --> 01:47:24.869
application, because you might have logic
that you expect it to initialize the value

01:47:24.869 --> 01:47:29.230
of the constant. And if something happens
and then initialization doesn't occur, then

01:47:29.230 --> 01:47:32.980
you're going to be working with zero value,
which might give you a false match to a constant

01:47:32.980 --> 01:47:33.980
that you're evaluating

01:47:33.980 --> 01:47:38.710
against. Using that Iota operator, we can
actually create what are called enumeration

01:47:38.710 --> 01:47:44.929
expressions. So we can define the value of
the constant dynamically by combining Iota

01:47:44.929 --> 01:47:50.190
with any arithmetic bitwise operation, or
bit shifting operation that's allowable with

01:47:50.190 --> 01:47:54.889
the primitive type that the constant and representing,
I want to talk about the first two collection

01:47:54.889 --> 01:48:00.600
types that we have available and go arrays
and slices. Now, arrays form the basis of

01:48:00.600 --> 01:48:04.639
slices. So I want to start a discussion with
those. And when we talk about arrays, we're

01:48:04.639 --> 01:48:09.019
going to talk about how to create them the
built in functions that go offers us to understand

01:48:09.019 --> 01:48:12.710
what's going on with our arrays. And then
we'll do some exercises working with arrays

01:48:12.710 --> 01:48:17.749
and see how we can use those in our applications,
then we're going to follow the same pattern,

01:48:17.749 --> 01:48:20.749
but we're going to switch over to slices.
So we'll learn the various ways that we can

01:48:20.749 --> 01:48:24.909
create slices, we'll learn the built in functions
that we can use to understand what's going

01:48:24.909 --> 01:48:29.679
on with our slices. And then we'll do some
exercises working with those. Okay, so let's

01:48:29.679 --> 01:48:34.039
go ahead and get started by learning how to
create an array. So the first thing that I

01:48:34.039 --> 01:48:38.579
want to discuss about arrays is the use case
for them. Why do we need them and what are

01:48:38.579 --> 01:48:43.500
they used for? So let me just drop in an example,
let's just say that we're building an application

01:48:43.500 --> 01:48:48.350
that's going to work with the grades of students
in a class. So with that arrays, we're going

01:48:48.350 --> 01:48:51.660
to end up with an application something like
this, we're going to have maybe grade one,

01:48:51.660 --> 01:48:55.570
grade two, grade three, and then we can print
out those grades. So we can go ahead and run

01:48:55.570 --> 01:49:02.469
this. And we see that we get the scores 9785
and 93 printed out. Now this works sort of.

01:49:02.469 --> 01:49:06.239
But we got a lot of problems here, because
our application needs to know exactly how

01:49:06.239 --> 01:49:11.079
many grades we have to work with, at the time
that we're designing the application. And

01:49:11.079 --> 01:49:15.690
working with these grades as a collection
becomes very cumbersome. So enter the array,

01:49:15.690 --> 01:49:20.559
and that's going to solve all of our problems.
So in order to see what an array looks like,

01:49:20.559 --> 01:49:24.539
let's go ahead and delete this code here.
And then we'll create an array, that's going

01:49:24.539 --> 01:49:29.119
to hold the grades for us. Now the way we
declare an array is we're going to start with

01:49:29.119 --> 01:49:32.920
the size of the array. So we're going to use
square brackets and then we're going to have

01:49:32.920 --> 01:49:36.920
an index that's going to be the number of
elements that are array can hold, and then

01:49:36.920 --> 01:49:41.019
the type of data that the array is going to
be designed to store. So an array can only

01:49:41.019 --> 01:49:45.190
store one type of data. So in this case, we're
declaring an array of integers that can hold

01:49:45.190 --> 01:49:49.039
up to three elements. If we wanted to hold
a different type, say we want them to have

01:49:49.039 --> 01:49:53.739
an array of strings, then we would type this
to a string, and so on. So you have to specify

01:49:53.739 --> 01:49:58.150
at the time that you're declaring the array,
what type of data you're going to store. And

01:49:58.150 --> 01:50:03.559
then we can use this initializer syntax To
put in the values for our array, so we can

01:50:03.559 --> 01:50:10.539
put in the same scores that we had before
9785, and 93. And then, if we come into our

01:50:10.539 --> 01:50:15.920
print statement here, and add our grades as
what we're going to print, then we see that

01:50:15.920 --> 01:50:21.260
we have all of the grades printed out together
in this collection called an array. Right

01:50:21.260 --> 01:50:25.590
now, that's a convenient collector. As we
start getting into looping constructs and

01:50:25.590 --> 01:50:29.550
things like that, we're going to really find
that having things grouped into arrays and

01:50:29.550 --> 01:50:33.850
slices and the other collection types is a
very powerful way for us to work with our

01:50:33.850 --> 01:50:38.239
data. Now, another advantage that we have
with working with arrays is the way that they're

01:50:38.239 --> 01:50:43.619
laid out in memory. So if you declare three
different variables and specify their values,

01:50:43.619 --> 01:50:47.539
it's impossible to know how they're going
to be laid out by the go runtime with arrays.

01:50:47.539 --> 01:50:53.449
However, we know by the design of the language
that these elements are contiguous in memory,

01:50:53.449 --> 01:50:58.030
which means accessing the various elements
of the array is very, very fast. So by collecting

01:50:58.030 --> 01:51:02.139
our data together in arrays, not only is it
easier to work with, but it also makes our

01:51:02.139 --> 01:51:06.849
applications generally a little bit faster.
Now one problem that we have in this example

01:51:06.849 --> 01:51:12.010
here is if you look at it, we're actually
declaring the size of the array twice, because

01:51:12.010 --> 01:51:15.909
we have this syntax here, where we're saying
that we're creating a three element integer

01:51:15.909 --> 01:51:20.309
array, but then we're adding three elements
to it. And that's not really required. If

01:51:20.309 --> 01:51:24.860
you're going to be initializing an array literal
like we're doing here, then you can actually

01:51:24.860 --> 01:51:30.179
replace the size with these three dots here.
Basically, what that says is create an array

01:51:30.179 --> 01:51:33.599
that's just large enough to hold the data
that I'm going to pass to you in the literal

01:51:33.599 --> 01:51:37.579
syntax. So in this case, we're going to get
an array that has three elements in it. And

01:51:37.579 --> 01:51:42.420
that's implied by the fact that in this literal
syntax, we've passed three integers to it,

01:51:42.420 --> 01:51:48.139
we can also declare an array that has a certain
size, but has its values zeroed out, by doing

01:51:48.139 --> 01:51:53.330
something like this, if we declare an array
called students, and let's make that a three

01:51:53.330 --> 01:51:57.670
element array that's going to hold strings.
And then let's print out what we have in that

01:51:57.670 --> 01:52:01.729
array. So if we print out, students, make
sure I'm spelling everything correctly and

01:52:01.729 --> 01:52:06.289
run this, then we see that we have an array
that's empty. So we have declared a three

01:52:06.289 --> 01:52:10.639
element array that can hold strings. But obviously,
there's no elements in there right now. So

01:52:10.639 --> 01:52:15.409
in order to specify a value in the array,
we're going to use this syntax, so we're going

01:52:15.409 --> 01:52:19.440
to call upon the array, and then we're going
to tell it which index we want to work with

01:52:19.440 --> 01:52:25.170
within the array. So in this case, we're working
with the zeroeth index of the students array.

01:52:25.170 --> 01:52:28.139
And then let's just assign the name Lisa to
it,

01:52:28.139 --> 01:52:33.099
then we can go ahead and print out our array
again, and run it. And now we see that we

01:52:33.099 --> 01:52:37.920
have, I always forget to add this line return
here, then we see initially we have an array

01:52:37.920 --> 01:52:42.849
of students that's full of empty strings.
In the second instance, we've actually specified

01:52:42.849 --> 01:52:46.999
that first element. Now you may be wondering
why we're starting with the value zero. And

01:52:46.999 --> 01:52:51.440
the reason is related to how arrays are made
up of contiguous blocks of memory. So when

01:52:51.440 --> 01:52:56.209
we talk about students as the name of the
array, what go is going to do is it's going

01:52:56.209 --> 01:53:00.769
to have a pointer or it's going to remember
the location of the beginning of that array.

01:53:00.769 --> 01:53:06.749
And then the index that we pass in this case
zero, is going to tell it how many strings

01:53:06.749 --> 01:53:12.459
to walk forward. So it knows that when it
has a string, a string has a certain length.

01:53:12.459 --> 01:53:17.449
And so it's going to walk that many strings.
So when we pass zero, it's going to be the

01:53:17.449 --> 01:53:22.580
head of the students array moved forward zero
string elements. And so that's going to be

01:53:22.580 --> 01:53:28.719
the first element of our array. So we can
finish this example out, if I drop some code

01:53:28.719 --> 01:53:33.400
in here, we can see what it would take to
fill out this array. So in this case, we got

01:53:33.400 --> 01:53:38.469
the zeroeth element to Lisa, the first element
is Ahmed. And the second element is Arnold.

01:53:38.469 --> 01:53:43.559
So if we print that out, we see the expected
result, where we have Lisa, Ahmed and Arnold.

01:53:43.559 --> 01:53:49.119
And it doesn't matter what order we work with
these, if we flip these around, then we find

01:53:49.119 --> 01:53:52.880
that they do flip around in the array, we
can assign them in any order that we want.

01:53:52.880 --> 01:53:57.269
Now if we want to get add a specific element
in the array, then we can use this square

01:53:57.269 --> 01:54:02.809
bracket syntax again, and dereference the
element from the array. So if we do this,

01:54:02.809 --> 01:54:07.210
and then change our label again. So we're
going to get the second element of the array,

01:54:07.210 --> 01:54:12.370
which is index one, then we can go ahead and
run this. And then we see that the second

01:54:12.370 --> 01:54:16.330
element has the value of Arnold. So we can
use this square bracket syntax in order to

01:54:16.330 --> 01:54:20.800
assign values to the array, as well as to
pull out the values that have been assigned.

01:54:20.800 --> 01:54:24.610
Now another thing that we can do is we can
determine how big the array is. Now, obviously,

01:54:24.610 --> 01:54:29.070
we created the array up on line eight. So
we remember at design time that we created

01:54:29.070 --> 01:54:32.749
this, but there may be a situation where you
need to go back and review the size of the

01:54:32.749 --> 01:54:36.119
array that you're working with. And the way
that we can do that is using the built in

01:54:36.119 --> 01:54:43.860
length function. So if I drop in another print
statement here, and format that, you see that

01:54:43.860 --> 01:54:48.380
we can get the number of students in array
using this built in alien function and passing

01:54:48.380 --> 01:54:52.360
in the array. So if we run this, then we see
that we get the number of students equals

01:54:52.360 --> 01:54:56.130
three and that's going to print out the size
of the array. So if we change the size of

01:54:56.130 --> 01:55:01.730
the array to say five then the results of
printing The array isn't going to change,

01:55:01.730 --> 01:55:06.499
but the size of the array does. Now one thing
that's important to remember is that an array

01:55:06.499 --> 01:55:11.190
can be made up of any type, it just always
has to be the same type for a given array.

01:55:11.190 --> 01:55:14.409
So we've been working with arrays of integers
and arrays of strings. So we've been working

01:55:14.409 --> 01:55:19.179
with primitives. But this example here shows
that we can actually make up arrays have anything

01:55:19.179 --> 01:55:23.590
else. So in this case, we've got an array
of arrays. So let's just say that we're working

01:55:23.590 --> 01:55:27.409
with some linear algebra. And we need the
identity matrix, which is a concept that's

01:55:27.409 --> 01:55:32.989
used pretty often in linear algebra. So this
array here stores a three by three identity

01:55:32.989 --> 01:55:37.820
matrix. So the first row is going to hold
the values 100, the second row is going to

01:55:37.820 --> 01:55:43.260
hold 010. And the third row is going to hold
001. So if we go ahead and print this out,

01:55:43.260 --> 01:55:47.260
then we see that we do in fact, get those
values. Another way to look at this, and maybe

01:55:47.260 --> 01:55:52.170
a little bit easier to see is using this way
here. So we're just going to declare the array

01:55:52.170 --> 01:55:56.750
of arrays, and then we're going to initialize
each one of those rows individually. So this

01:55:56.750 --> 01:56:00.079
reads a little bit cleaner, and might be a
little bit easier for you to understand what's

01:56:00.079 --> 01:56:04.579
going on. And if we run this, we get the exact
same result. Now the last thing that I want

01:56:04.579 --> 01:56:08.830
to talk about with arrays is something that's
a little bit different with arrays and go

01:56:08.830 --> 01:56:14.690
than in other languages. And that is that
arrays are actually considered values. So

01:56:14.690 --> 01:56:18.300
in a lot of languages, when you create an
array, it's actually pointing to the values

01:56:18.300 --> 01:56:21.710
in that array. So if you pass things around,
you're actually passing around the same underlying

01:56:21.710 --> 01:56:27.750
data. But in go, that's not true. When you
copy an array, as we're doing on line nine,

01:56:27.750 --> 01:56:31.890
here, you're actually creating a literal copy.
So it's not pointing to the same underlying

01:56:31.890 --> 01:56:36.380
data is pointing to a different set of data,
which means it's got to reassign that entire

01:56:36.380 --> 01:56:41.199
length of the array. So if I run this, you'll
see what I'm talking about here. So on line

01:56:41.199 --> 01:56:46.050
eight, I assigned an array on line nine, I
created another variable b and assign that

01:56:46.050 --> 01:56:51.630
to a, and then on line 10, I changed the second
element of the array to the value five. And

01:56:51.630 --> 01:56:57.469
what you see is that when I print out the
array, it has the original values 123. But

01:56:57.469 --> 01:57:01.570
B has the new values of 153. So when you're
working with these, you have to be a little

01:57:01.570 --> 01:57:06.460
careful, because copying arrays, especially
when we get into functions, if you're passing

01:57:06.460 --> 01:57:11.349
arrays into a function, go is going to copy
that entire array over. So if you're dealing

01:57:11.349 --> 01:57:14.800
with a three element array, that's not a big
deal, if you've got a million elements in

01:57:14.800 --> 01:57:19.130
your array that could slow your program down
a little bit. So what do you do if you don't

01:57:19.130 --> 01:57:23.400
want to have this behavior? Well, we haven't
talked about it yet. But I want to give you

01:57:23.400 --> 01:57:26.679
a hint right now in order to cover this completely.

01:57:26.679 --> 01:57:31.949
And that is this idea of pointers. So the
way that our program is working right now

01:57:31.949 --> 01:57:38.760
is that the value B is assigned to a copy
of the array. But if we do the address of

01:57:38.760 --> 01:57:42.510
operation, which is this character here, then
what we're saying is B is going to point to

01:57:42.510 --> 01:57:47.719
the same data that he has. Now we'll get into
more detail about what this means later. But

01:57:47.719 --> 01:57:52.980
the long and the short of it is if I run this,
now, A and B are pointing to the same data.

01:57:52.980 --> 01:58:00.199
So A is the array itself, and B is pointing
to a. So when we change the value in line

01:58:00.199 --> 01:58:05.400
10, we're actually changing the same underlying
data for both. So when we print them out,

01:58:05.400 --> 01:58:10.960
we see that the array has changed, as well
as the array that B is pointing to, because

01:58:10.960 --> 01:58:14.699
they happen to be exactly the same array.
Now arrays are very powerful. And there's

01:58:14.699 --> 01:58:19.239
a lot of use cases where you can use arrays
very efficiently. However, the fact that they

01:58:19.239 --> 01:58:25.199
have a fixed size that has to be known at
compile time definitely limits their usefulness.

01:58:25.199 --> 01:58:30.559
So in go, the most common use case for using
arrays is to back something called a slice.

01:58:30.559 --> 01:58:34.840
So let's take a look at a slice. So the first
thing that I want to do is comment out a couple

01:58:34.840 --> 01:58:39.369
more items in this example here. So we'll
comment on this one, this one and this one.

01:58:39.369 --> 01:58:43.230
And then we'll change this over to slice syntax.
So the way we're going to do that is simply

01:58:43.230 --> 01:58:48.860
by eliminating these three dots here. So a
slice is initialized as a literal by just

01:58:48.860 --> 01:58:53.480
using the square brackets, the type of data
we want to store. And then in the curly braces,

01:58:53.480 --> 01:58:57.449
we can pass in the initialized data. So we
go ahead and run this, we see that we get

01:58:57.449 --> 01:59:02.360
the values 123, it looks exactly like an array.
And as a matter of fact, everything we can

01:59:02.360 --> 01:59:06.959
do with an array we can do with a slice as
well, with one or two exceptions. So in order

01:59:06.959 --> 01:59:11.469
to illustrate that, we have the length function
that we talked about with an array, well,

01:59:11.469 --> 01:59:15.730
we have the length function with a slice as
well. So if I run this, we see that we do

01:59:15.730 --> 01:59:20.940
get the length of three. So we initialize
the slice with values 123. So with three elements,

01:59:20.940 --> 01:59:24.659
so the length function gives us a value of
three. Now there's an additional function

01:59:24.659 --> 01:59:28.990
that we have available with slices, and that
is the capacity. And that's because the number

01:59:28.990 --> 01:59:34.949
of elements in the slice doesn't necessarily
match the size of the backing array, because

01:59:34.949 --> 01:59:40.749
the slice is really a projection of that underlying
array. So we can have a very large array and

01:59:40.749 --> 01:59:45.479
only be looking at a small piece of it. Now
if we run this example, we see that the capacity

01:59:45.479 --> 01:59:52.249
function returns the value three. So the underlying
array is exactly the same size as the slice.

01:59:52.249 --> 01:59:56.060
But as we go along here, we'll see how we
can get into situations where the length and

01:59:56.060 --> 01:59:59.440
capacity are different, and why that's a very
good thing.

01:59:59.440 --> 02:00:00.770
Now unlike Like

02:00:00.770 --> 02:00:05.000
arrays, where we have this syntax here, and
we have to use this address of operation in

02:00:05.000 --> 02:00:10.409
order to point to the same data slices are
naturally what are called reference types.

02:00:10.409 --> 02:00:15.429
So they refer to the same underlying data.
So if we run this example, again, remember

02:00:15.429 --> 02:00:20.210
when we ran this with an array, we saw that
B store different data than a when we were

02:00:20.210 --> 02:00:25.239
done. So if we run this, we see that A and
B are actually pointing to the same underlying

02:00:25.239 --> 02:00:30.199
array. And so when we change the value in
B, we get a change in the value in a. So this

02:00:30.199 --> 02:00:33.599
is one thing that you're going to have to
keep in mind when you're working with slices.

02:00:33.599 --> 02:00:37.300
If you got multiple slices pointing to the
same underlying data, you have to keep in

02:00:37.300 --> 02:00:41.920
mind, if one of those slices changes the underlying
data, it could have an impact somewhere else

02:00:41.920 --> 02:00:46.690
in your application. Now, so far, we've only
looked at the literal syntax for creating

02:00:46.690 --> 02:00:50.260
a slice. And that's what we're seeing here
on line eight, there's actually several other

02:00:50.260 --> 02:00:55.330
ways that we can create slices. And that is
illustrated with this example here. So you

02:00:55.330 --> 02:00:59.239
see on line eight, we're creating a slice
that has the values one through 10. And then

02:00:59.239 --> 02:01:04.030
on line nine, we're creating a slice B, and
that's using this bracket with the colon in

02:01:04.030 --> 02:01:08.140
between. And what that's going to do is, it's
basically going to create a slice of all the

02:01:08.140 --> 02:01:12.300
elements of what it's referring to. So it's
going to create a slice of all of the elements

02:01:12.300 --> 02:01:16.959
of a online 10, we're creating a slight C,
and that's going to start with a third element

02:01:16.959 --> 02:01:21.869
of the parent, and copy all the values after
that. So that's going to start with the element

02:01:21.869 --> 02:01:26.809
with index three, which is, of course, the
fourth element and every element after that,

02:01:26.809 --> 02:01:32.630
so this is going to copy four through 10,
into the slice at sea, then on line 11, we're

02:01:32.630 --> 02:01:35.670
going to do the other syntax, and that's going
to copy everything up to

02:01:35.670 --> 02:01:36.670
the sixth

02:01:36.670 --> 02:01:41.539
element. And that's the literal sixth element,
that's not element number seven, that's actually

02:01:41.539 --> 02:01:46.409
the sixth element, which is going to have
the index five. And then on line 12, we actually

02:01:46.409 --> 02:01:50.070
see an inner slice. So we're going to copy
the fourth element through the sixth element

02:01:50.070 --> 02:01:54.249
into our new slice. So let's go ahead and
run this and see what prints out. So we see

02:01:54.249 --> 02:01:58.750
the first line printed out is the original
slice that we have. The second line is the

02:01:58.750 --> 02:02:04.079
copy of that slice that's copying all of the
elements. The third line is going to copy

02:02:04.079 --> 02:02:09.070
the fourth element on so we see the number
four through 10. The fourth line copies everything

02:02:09.070 --> 02:02:13.150
up to the sixth element, so we get the values
one through six. And then the last line printed

02:02:13.150 --> 02:02:17.249
out is a slice from three to six. And so we're
gonna get the elements four, five, and six

02:02:17.249 --> 02:02:21.249
printed out. So that can be a little bit confusing,
because the first number has a slightly different

02:02:21.249 --> 02:02:25.349
meaning than the second number. So basically,
the first number is inclusive, and the second

02:02:25.349 --> 02:02:29.599
number is XClusive. So for example, if we
look at line 12, again, we're going to copy

02:02:29.599 --> 02:02:35.790
from index three, up to but not including
index six. So that's another way that you

02:02:35.790 --> 02:02:40.380
can look at it. Now one thing to keep in mind,
remember what I said that all of these operations

02:02:40.380 --> 02:02:46.090
point at the same underlying data. So if we
take element five, and change that value in

02:02:46.090 --> 02:02:51.699
the a slice and run this again, notice all
of them teams value, because they're all pointing

02:02:51.699 --> 02:02:56.679
to the same underlying array. So each one
of these operations includes the fifth index

02:02:56.679 --> 02:03:01.630
in their results. And each one of those gets
updated to the value of 42. Now another thing

02:03:01.630 --> 02:03:04.850
to know about these slicing operations is
they can work with slices like we're doing

02:03:04.850 --> 02:03:09.139
here, but they can also work with arrays.
So if you remember, if I put these three dots

02:03:09.139 --> 02:03:14.130
in here, it's actually going to turn a into
an array. And if I run this, we get the same

02:03:14.130 --> 02:03:19.889
result. And that's because slicing operations
can have as their source, an array or a slice.

02:03:19.889 --> 02:03:23.460
So whatever type of data you're working with,
as long as it's one of those two, you can

02:03:23.460 --> 02:03:27.959
use these slicing operations. Now the last
way that we have available to us to create

02:03:27.959 --> 02:03:32.630
a slice is using what's called the make function.
And that's a built in function that we have

02:03:32.630 --> 02:03:38.309
to work with. So if I delete all this, and
drop this guy out, we're going to use the

02:03:38.309 --> 02:03:42.809
built in make function. And this takes two
or three arguments. So let's start with two

02:03:42.809 --> 02:03:46.421
arguments. So the first thing we're going
to say is the type of object that we want

02:03:46.421 --> 02:03:51.280
to create. So you can use make for several
different operations. In this case, we're

02:03:51.280 --> 02:03:54.909
going to be talking about making slices. So
in this example, here, we're going to make

02:03:54.909 --> 02:04:00.280
a slice of integers. The second argument is
going to be the length of the slice. So in

02:04:00.280 --> 02:04:04.579
this case, I want to start with three elements.
So now let's just get some information about

02:04:04.579 --> 02:04:09.349
the slice that we created here. And we'll
do that by dropping in a couple of print statements.

02:04:09.349 --> 02:04:12.719
So we'll print out the values of the slice,
the length of the slice and the capacity of

02:04:12.719 --> 02:04:18.321
the slice. So they run this, no big surprise
it zeroed out. So when I create a slice, everything

02:04:18.321 --> 02:04:22.840
gets set to the zero value, which is what
we always expect in go to happen every time

02:04:22.840 --> 02:04:26.909
we initialize a variable, we expect it to
be initialized to zero values. And that's

02:04:26.909 --> 02:04:31.070
true for slices just like it's true for primitives.
When we asked for the length, we get a length

02:04:31.070 --> 02:04:36.070
three, when we ask for the capacity, that's
also set to three. Now we can also pass a

02:04:36.070 --> 02:04:40.840
third argument to the make function, and that's
going to set the capacity. So keep in mind,

02:04:40.840 --> 02:04:45.230
the slice has an underlying array, and they
don't have to be equivalent. So if we run

02:04:45.230 --> 02:04:50.190
this, we see that we've created a slice of
length three, it's got three elements in it,

02:04:50.190 --> 02:04:54.860
but the underlying array has 100 elements
in it. So why would we do that? Well, the

02:04:54.860 --> 02:05:01.090
reason is because unlike arrays, slices don't
have to have a fixed size over there and Life,

02:05:01.090 --> 02:05:06.070
we can actually add elements and remove elements
from them. So in order to show you an example

02:05:06.070 --> 02:05:10.070
of that, let me drop in another example here.
And this is going to start with a slice of

02:05:10.070 --> 02:05:13.939
integers that starts with no elements in it.
So if we go ahead and run this, we see what

02:05:13.939 --> 02:05:18.670
we expect, we see an empty slice length of
zero capacity of zero. Now, if I want to add

02:05:18.670 --> 02:05:23.670
an element to this slice, I can use the built
in append function. So this takes two or more

02:05:23.670 --> 02:05:28.300
arguments, the first is going to be the source
slice that we're going to be working with.

02:05:28.300 --> 02:05:32.080
So I'm going to start with a and I'm going
to add an element to it. And in this case,

02:05:32.080 --> 02:05:37.869
all I want to do is add the number one to
it. And then let's go ahead and print out

02:05:37.869 --> 02:05:42.019
the value of the slice the length of the slice
and the capacity of the slice again. So if

02:05:42.019 --> 02:05:46.929
I go ahead and run this, we see that in the
second operation, we have a value one stored

02:05:46.929 --> 02:05:53.079
in there, we have the length of one, and notice
the capacity is two. So that's kind of interesting.

02:05:53.079 --> 02:05:58.840
What happened here is when we initialize a
slice to the value a go assigned a memory

02:05:58.840 --> 02:06:03.619
location for the slice. And since it didn't
have to store anything, it basically created

02:06:03.619 --> 02:06:09.449
an underlying array of zero elements for us.
As soon as we added an element, obviously,

02:06:09.449 --> 02:06:13.969
it couldn't fit in a zero element array. So
it had to assign an array for us. So what

02:06:13.969 --> 02:06:18.979
go does is it copies all of the existing elements,
in this case, nothing to a new array that's

02:06:18.979 --> 02:06:24.229
got a larger size. So when we reassigned,
it actually did create a new array, this one

02:06:24.229 --> 02:06:25.229
has a capacity of

02:06:25.229 --> 02:06:30.499
two, and then it put the value one into that
array. Now, when we're dealing with small

02:06:30.499 --> 02:06:34.530
slices like this, things are pretty cheap
and pretty easy, even if you're resizing the

02:06:34.530 --> 02:06:39.909
array quite a few times. However, as things
get very large, these copy operations become

02:06:39.909 --> 02:06:44.539
very expensive. And that's why we have that
three parameter make function. That way, if

02:06:44.539 --> 02:06:48.650
we know the capacity is going to be somewhere
around 100 elements, you can go ahead and

02:06:48.650 --> 02:06:52.630
start there. And that way, as you're appending
elements and building up the slicer, you're

02:06:52.630 --> 02:06:56.840
not constantly copying the underlying array
around. Now, if you remember, when I said

02:06:56.840 --> 02:07:01.809
the append function can take two or more arguments.
The reason for that is this is what's called

02:07:01.809 --> 02:07:06.709
a variadic function. So everything after the
first argument is going to be interpreted

02:07:06.709 --> 02:07:12.179
as a value to append to the slice passed in
the first argument. So if we have this example,

02:07:12.179 --> 02:07:18.150
here, we're actually going to append the values
234 and five to the slice returned by A. So

02:07:18.150 --> 02:07:23.199
if we run this guy, we see that we get the
elements one through five created there, and

02:07:23.199 --> 02:07:28.340
the length is five, like we might expect.
But now the capacity is eight knots not fixed

02:07:28.340 --> 02:07:33.800
in stone, how go resize of the arrays. But
generally, what I've seen it does is once

02:07:33.800 --> 02:07:38.440
it fills up the underlying array with a slice,
when you add the next element, it's going

02:07:38.440 --> 02:07:42.539
to create a new array, and it's actually going
to double the size from the previous array.

02:07:42.539 --> 02:07:45.999
So if we start with an empty slice, we see
that the array would initially be of size

02:07:45.999 --> 02:07:52.960
zero, then we'll go to 248 1632, and 64 elements.
So that's something else to be aware of, if

02:07:52.960 --> 02:07:56.409
you're just over one of those powers of two,
you can actually end up with a lot of memory

02:07:56.409 --> 02:07:59.989
consumed that you're never going to be using.
So again, if you have the ability to come

02:07:59.989 --> 02:08:04.610
up with a decent first estimate, then that's
going to be beneficial to you. Now one common

02:08:04.610 --> 02:08:08.849
situation that you're going to run into is
if you have a slice of elements, and another

02:08:08.849 --> 02:08:12.300
slice of elements, and you want to concatenate
them together, so you want to have another

02:08:12.300 --> 02:08:16.530
slice created that has all of the elements
of the first slice, and all of the elements

02:08:16.530 --> 02:08:20.909
of the second slice. So you might want to
do something like this, if I convert this

02:08:20.909 --> 02:08:26.459
over to a literal slice, you might want to
run a command something like this. Well, this

02:08:26.459 --> 02:08:29.699
unfortunately, is not going to work. If I
go ahead and run this, you'll see that we're

02:08:29.699 --> 02:08:34.459
going to get go complaining to us. And that's
because the second argument to the append

02:08:34.459 --> 02:08:39.949
function has to have the type of the slice.
So go can only accept integers here. It can't

02:08:39.949 --> 02:08:45.579
accept a slice of integers. But we do have
a way around this. So I don't know what it's

02:08:45.579 --> 02:08:49.659
called an NGO in JavaScript, they would call
this the spread operator, where if you have

02:08:49.659 --> 02:08:55.039
three dots after the slice, it's actually
going to spread that slice out into individual

02:08:55.039 --> 02:09:00.150
arguments. So if we run this, this is going
to work. And it works exactly the same as

02:09:00.150 --> 02:09:03.510
if this weren't a slice at all, it's basically
going to take this slice and decompose it

02:09:03.510 --> 02:09:09.449
into looking something like this. So these
work exactly the same way. But it's a convenient

02:09:09.449 --> 02:09:13.619
feature to know about if you have slices and
you want to concatenate them together. Now,

02:09:13.619 --> 02:09:17.940
some other common operations that you might
do with slices are stack operations. So let's

02:09:17.940 --> 02:09:20.979
just say that we're treating our slices a
stack, and we want to be able to push elements

02:09:20.979 --> 02:09:25.709
onto the stack and pop elements off of the
stack. And things like that, with the append

02:09:25.709 --> 02:09:29.510
function is going to allow us to push elements
onto the stack. But how do we pop elements

02:09:29.510 --> 02:09:33.250
off? Well, we have a couple of different ways
that we want to do this. If we want to do

02:09:33.250 --> 02:09:37.020
what's called a shift operation, which means
we want to remove the first element from the

02:09:37.020 --> 02:09:41.190
slice, then we can do this operation here.
And what this is going to do is it's going

02:09:41.190 --> 02:09:45.699
to create a new slice that starts at index
one, which has the value two in this example,

02:09:45.699 --> 02:09:50.239
and takes everything else from that. So if
we go ahead and print out the value of b,

02:09:50.239 --> 02:09:53.989
we'll see that that has the elements two through
five. Now if you want to trim an element off

02:09:53.989 --> 02:09:58.539
of the end, then you're going to have to use
a different syntax here. So we want all of

02:09:58.539 --> 02:10:02.439
the initial elements. So we're going to start
with a colon, and then we'll use that length

02:10:02.439 --> 02:10:06.270
operation, figure out the length of the slice.
But remember, that's going to return the number

02:10:06.270 --> 02:10:10.329
that's too large, we actually want to remove
an element off. So let's go ahead and do length

02:10:10.329 --> 02:10:14.519
minus one. And this will have the values one
through four in it. So it's pretty easy to

02:10:14.519 --> 02:10:17.829
remove an element from the beginning of the
slice or the end of the slice. But what happens

02:10:17.829 --> 02:10:19.729
if you want to remove an element from the
middle?

02:10:19.729 --> 02:10:23.909
Well, here, things get a little bit hairy.
Because what we have to do is we actually

02:10:23.909 --> 02:10:28.619
have to concatenate two slices together, the
first slice is going to be all the elements

02:10:28.619 --> 02:10:32.440
up to where we want to remove the element.
So in this case, we can take the first two

02:10:32.440 --> 02:10:37.750
elements, by doing a slice of a, and passing
in colon two for this slice that we want to

02:10:37.750 --> 02:10:42.270
create, then we have to concatenate to that
all of the element after the index we want

02:10:42.270 --> 02:10:46.979
to remove. So in this case, we're removing
that middle element. So we'll take from three

02:10:46.979 --> 02:10:51.949
on and then we have to use this spread operation
in order to spread things out so that the

02:10:51.949 --> 02:10:56.519
append function is happy. So let's go ahead
and run this and then get my syntax correct

02:10:56.519 --> 02:11:01.540
here. And now we see that we've got the elements
124, and five. So we've successfully removed

02:11:01.540 --> 02:11:06.130
an element from the slice, they have to be
a little bit careful here. because keep in

02:11:06.130 --> 02:11:10.300
mind, we're working with references to the
same underlying array. Because these are all

02:11:10.300 --> 02:11:14.820
slicing operations, there's one underlying
array and everything is being done on that

02:11:14.820 --> 02:11:19.150
underlying array. So just to show you the
havoc that we've created here, let me go ahead

02:11:19.150 --> 02:11:23.849
and print the value of a out here, and then
print the value of a out afterwards and go

02:11:23.849 --> 02:11:29.079
ahead and run that. And you see we start out
with the elements 12345. Like we might expect,

02:11:29.079 --> 02:11:33.130
we do our slicing operation, removing the
elements from the middle, we get 1245, which

02:11:33.130 --> 02:11:38.630
was what we might expect. But then when we
print a out, things look a little weird, because

02:11:38.630 --> 02:11:44.980
we have that slice that V represents which
is 1245, our three is completely gone, and

02:11:44.980 --> 02:11:49.429
five is duplicated. So this is something to
be very sensitive about. If you're going to

02:11:49.429 --> 02:11:53.530
be removing elements from the inside of a
slice using a command like we have on line

02:11:53.530 --> 02:11:58.280
10, make sure that you don't have any other
references to that underlying array. Otherwise,

02:11:58.280 --> 02:12:02.159
you're going to get some unexpected behavior.
So what do you do if you have a situation

02:12:02.159 --> 02:12:05.389
like this, and you really, really need a to
stay the same, and you really, really need

02:12:05.389 --> 02:12:09.489
B to change? Well, unfortunately, we don't
have the tools to work with this right now.

02:12:09.489 --> 02:12:13.420
Because what we're going to need to do is
to use a loop to create a copy of that slice

02:12:13.420 --> 02:12:17.380
that doesn't point to the same underlying
array, and then you can make the manipulation.

02:12:17.380 --> 02:12:20.749
So when we get to the looping section, we'll
show you how to do loops. And then you'll

02:12:20.749 --> 02:12:24.630
have all the tools that you need in order
to handle that situation. For now, the only

02:12:24.630 --> 02:12:29.580
thing I can say is be aware of this behavior.
And if you get into a situation like this,

02:12:29.580 --> 02:12:31.670
understand that you're going to have to do
a little bit of research in order to make

02:12:31.670 --> 02:12:37.090
sure that your application responds correctly.
Okay, so that covers what I want to talk about

02:12:37.090 --> 02:12:42.860
with the raising of slices. Let's head into
a summary and review what we've talked about.

02:12:42.860 --> 02:12:47.189
arrays and slices are very common in NGO applications.
And I think you're going to see them all over

02:12:47.189 --> 02:12:51.189
the place as you start to work more and more
with the language. So I hope that this conversation

02:12:51.189 --> 02:12:55.490
has really helped you understand what arrays
and slices are and some basics about how you

02:12:55.490 --> 02:13:00.010
can work with them. We started our discussion
by talking about arrays. And we learned how

02:13:00.010 --> 02:13:04.510
there are collections of items with the same
type. So you can't create an array that has

02:13:04.510 --> 02:13:08.389
strings and integers and things like that
all of the types have to be the same, but

02:13:08.389 --> 02:13:12.600
does collect them all together. And as we
start to get into conversations about looping

02:13:12.600 --> 02:13:16.610
and things like that, we're going to find
how we get some very powerful tools that we

02:13:16.610 --> 02:13:22.289
can work with, when we're basing our data
on arrays and slices. They are fixed size.

02:13:22.289 --> 02:13:27.209
So when you create an array, you have to specify
at compile time how big that array is. And

02:13:27.209 --> 02:13:32.100
it can never change. So you can't make them
smaller, and you can't make them larger. There

02:13:32.100 --> 02:13:36.110
are three different ways that we can declare
an array, we can do the literal style, like

02:13:36.110 --> 02:13:39.760
you see on this first line, where we're going
to specify the number of elements and then

02:13:39.760 --> 02:13:44.429
we use a literal that's going to initialize
those elements. However, we do have a shorthand

02:13:44.429 --> 02:13:48.469
notation that uses three dots instead of that
first size. And that's going to be a little

02:13:48.469 --> 02:13:52.189
bit more robust in your application design.
Because if you run into a situation where

02:13:52.189 --> 02:13:55.389
you need to add another literal, you don't
have to remember to update the size of the

02:13:55.389 --> 02:14:00.050
array, it's going to update automatically.
We also have this third syntax where we can

02:14:00.050 --> 02:14:04.340
declare a zero data array. In this case, we're
going to declare an array of three integers,

02:14:04.340 --> 02:14:08.050
each one of those integers is going to start
with the value zero. We also talked about

02:14:08.050 --> 02:14:12.820
how arrays are zero based. So we're going
to be counting from the head of the array.

02:14:12.820 --> 02:14:17.389
So the first element in the array has the
index zero, the second element has the index

02:14:17.389 --> 02:14:23.030
one, and so on. So in this example, if we
asked for the index one of array, we're going

02:14:23.030 --> 02:14:27.079
to get the value three out, we have the Len
function that's going to return the size of

02:14:27.079 --> 02:14:32.030
the array in case you need to know that some
other place in your application. And you want

02:14:32.030 --> 02:14:36.590
to have a way to be able to handle that robustly.
That's not relying on the fact that you know,

02:14:36.590 --> 02:14:40.489
at design time how big that array is, you
can use the Le n function to interrogate the

02:14:40.489 --> 02:14:45.330
size of the array. Anytime you're moving the
array around, it's going to copy the underlying

02:14:45.330 --> 02:14:50.179
data. So if you have a three element array,
and you assign that to another variable, all

02:14:50.179 --> 02:14:53.460
three elements are going to be copied to a
new location in memory and you're going to

02:14:53.460 --> 02:14:58.280
be working with an independent copy. So that
can cause some unexpected behaviors because

02:14:58.280 --> 02:15:02.439
if you change that copied array unexpected
changes to be reflected back in the initial

02:15:02.439 --> 02:15:06.460
array, that won't happen. And it can be very
expensive because all that memory has to be

02:15:06.460 --> 02:15:08.159
allocated a second time.

02:15:08.159 --> 02:15:11.679
Then we moved on to discuss slices and how
they're very similar to arrays. As a matter

02:15:11.679 --> 02:15:16.939
of fact, they're backed by an array. So every
slice that you see, under the covers, go has

02:15:16.939 --> 02:15:21.249
an array that's holding all of that data for
you. There are several creation styles, we

02:15:21.249 --> 02:15:25.999
saw that we can create a slice by slicing
an existing array or another slice, we have

02:15:25.999 --> 02:15:29.850
the literal style that we can use, which is
very similar to the array literal, except

02:15:29.850 --> 02:15:34.429
for we just leave those three dots out, because
the size of the slice is dynamic. And so it

02:15:34.429 --> 02:15:39.320
can be determined at runtime, we also saw
how we can use the make function. So if we

02:15:39.320 --> 02:15:42.690
pass two arguments to the make function, the
first is going to be the type of slice that

02:15:42.690 --> 02:15:46.269
we want to create. So in this example, we're
going to create a slice of integers. And the

02:15:46.269 --> 02:15:50.900
second parameter is going to determine the
length and the initial capacity of the slice.

02:15:50.900 --> 02:15:55.050
If we need a capacity that's different than
the initial length, then we can pass a third

02:15:55.050 --> 02:15:59.269
parameter into the make function. And that's
going to allow us to specify a capacity independent

02:15:59.269 --> 02:16:04.429
of that initial length, the Len function returns
the length of the slice itself, whereas the

02:16:04.429 --> 02:16:09.239
capacity function returns the length of the
underlying array. So if for some example,

02:16:09.239 --> 02:16:13.679
you want to control the resizing of the slice,
you can go ahead and do that. And use that

02:16:13.679 --> 02:16:17.400
capacity to function to understand when you're
starting to get to your limits, you can also

02:16:17.400 --> 02:16:21.059
use the append function to add an element
to the slice. And what that's going to do

02:16:21.059 --> 02:16:25.350
is it's going to take in a parent slice, and
it's going to take in one or more elements

02:16:25.350 --> 02:16:29.949
to add to that slice. Now through the course
of that append operation, you can add elements

02:16:29.949 --> 02:16:33.940
that exceeds the capacity of the underlying
array. If that happens, then you are going

02:16:33.940 --> 02:16:37.950
to trigger a copy operation. And all of those
elements are going to have to be copied to

02:16:37.950 --> 02:16:42.551
a new location. So be aware of that. If you're
dealing with large slices of data, and you

02:16:42.551 --> 02:16:46.640
end up resizing, a lot of times your application
performance can suffer, you might want to

02:16:46.640 --> 02:16:51.380
think about using that three parameter make
function, in order to set the capacity of

02:16:51.380 --> 02:16:55.540
the slice close to where you need it to be.
When you're passing slices around in your

02:16:55.540 --> 02:17:00.320
application. Keep in mind that assigning a
new value to an existing slice actually points

02:17:00.320 --> 02:17:05.720
to the same underlying array. So if you manipulate
the slice in one location, it's actually going

02:17:05.720 --> 02:17:10.500
to affect all the other slices that are pointing
to that same underlying data. So we talked

02:17:10.500 --> 02:17:14.670
about an example where we created a slice
and removed the middle element out of it.

02:17:14.670 --> 02:17:18.630
And we saw how that actually affected the
initial slice, and could cause some behavior

02:17:18.630 --> 02:17:22.920
that we weren't expecting. I want to complete
the discussion, I started in the last video

02:17:22.920 --> 02:17:26.920
by talking about the two remaining collection
types that are available and go. And those

02:17:26.920 --> 02:17:32.020
types are mapped in structs. So we'll start
our discussion by talking about maps, we'll

02:17:32.020 --> 02:17:36.380
talk about what they are, how we can create
them, and then how we can manipulate the data

02:17:36.380 --> 02:17:40.600
within the maps, then we'll move on to the
struct data type, we'll talk about what they

02:17:40.600 --> 02:17:44.750
are, how we can create them, then we'll move
on to the naming conventions that we're going

02:17:44.750 --> 02:17:48.929
to have to be aware of as we're working with
structs, then we'll talk about a concept called

02:17:48.929 --> 02:17:53.480
embedding, and how we can use that to have
a struct that we're creating inherit a lot

02:17:53.480 --> 02:17:57.610
of functionality from a base struct, then
we'll finish our discussion of structs by

02:17:57.610 --> 02:18:02.320
talking about a concept called tags, and how
we can use tags to provide some additional

02:18:02.320 --> 02:18:07.170
information about the fields within our structs
to help the consumers of objects created from

02:18:07.170 --> 02:18:11.480
the struct get additional information about
how that field is intended to be used. Okay,

02:18:11.480 --> 02:18:16.540
so let's begin our discussion by talking about
what maps are and how we can use them. So

02:18:16.540 --> 02:18:19.590
the first thing that we're going to need to
get our heads around when we're talking about

02:18:19.590 --> 02:18:23.920
maps is what exactly a map is. And I think
the easiest way to show you what a map is,

02:18:23.920 --> 02:18:28.860
is by showing you a map. So we have an example
here of a variable called state populations.

02:18:28.860 --> 02:18:34.930
And this represents a map of US state names
over to the population within those states.

02:18:34.930 --> 02:18:40.081
So what we see here is a map is going to take
some kind of a key, in this case, the state

02:18:40.081 --> 02:18:44.760
names, and it's going to map that over to
some kind of a value, in this case, the population

02:18:44.760 --> 02:18:49.820
of that state. So what this provides us is
a very flexible data type. When we're trying

02:18:49.820 --> 02:18:53.070
to map one key type over to one value type.

02:18:53.070 --> 02:18:55.940
Now there's a couple of constraints we're
going to have to keep in mind. As you can

02:18:55.940 --> 02:19:02.000
see up in the Declaration on line eight, we're
going to map one key type to one value type.

02:19:02.000 --> 02:19:06.040
So all of the keys in this map have to be
of type string, and all of the values have

02:19:06.040 --> 02:19:10.810
to be of type integer. Now we can use a lot
of different types for the keys. And we can

02:19:10.810 --> 02:19:15.750
use any type for the value. But when we declare
a map, that type has to be consistent for

02:19:15.750 --> 02:19:20.020
every key value pair within the map. So if
we run this, we can see an example of what

02:19:20.020 --> 02:19:23.990
a map looks like when we print it. And it's
not the best output in the world, but we can

02:19:23.990 --> 02:19:27.980
get an idea of what's going on. So we see
that we get the key value pairs printed out.

02:19:27.980 --> 02:19:32.320
So we get California, Texas, Florida, New
York, Pennsylvania, Illinois, and Ohio. So

02:19:32.320 --> 02:19:36.720
one thing that I just alluded to is that we
have a lot of options with the key type, but

02:19:36.720 --> 02:19:40.881
we don't have an infinite number of options.
So the basic constraint on the keys when you're

02:19:40.881 --> 02:19:46.050
creating a map is they have to be able to
be tested for equality. Now most of the types

02:19:46.050 --> 02:19:50.930
that we're working with can do that. So Boolean
can be tested for equality, all of the numeric

02:19:50.930 --> 02:19:55.240
types, strings, pointers, interfaces, structs
arrays, and this thing we haven't talked about

02:19:55.240 --> 02:20:00.200
called channels. All of those can be tested
to see if one instance of for example For

02:20:00.200 --> 02:20:04.811
a string variable is equivalent to another
one. However, there are some data types that

02:20:04.811 --> 02:20:10.101
cannot be used for equivalency checking. And
those are slices, maps and other functions.

02:20:10.101 --> 02:20:15.871
So for example, if we create a map called
m, and we'll make that a map of, say we want

02:20:15.871 --> 02:20:22.331
to map slices of integers over two strings.
And we'll use the literal syntax for that,

02:20:22.331 --> 02:20:27.141
and then we print that out, then you would
expect a map to print out. But in fact, we

02:20:27.141 --> 02:20:30.930
get an error because we've got an invalid
key type because a slice cannot be a key to

02:20:30.930 --> 02:20:36.811
a map. However, if we had an index here, then
it turns it into an array. And now we do get

02:20:36.811 --> 02:20:40.630
a successful printout, of course, the map
is empty. So we don't see anything, we just

02:20:40.630 --> 02:20:45.080
see this empty map right here. But we were
successfully able to create the map, because

02:20:45.080 --> 02:20:49.631
an array is a valid key type, but a slice
is not. So what are the different ways that

02:20:49.631 --> 02:20:53.960
we can create a map? Well, you see, the first
way here, this is the literal syntax, and

02:20:53.960 --> 02:20:58.091
this is going to probably be the most common
way you're going to see maps created. So we

02:20:58.091 --> 02:21:01.630
just need to declare the type of map. And
we're going to do that using this syntax that

02:21:01.630 --> 02:21:06.120
we see here on line eight, where we're going
to start with the map keyword in square brackets,

02:21:06.120 --> 02:21:09.821
we're going to list the type of the key, and
then after the square brackets, we're going

02:21:09.821 --> 02:21:14.021
to list the type of the value. Another way
that we can do this is we can use the built

02:21:14.021 --> 02:21:18.240
in make function again. Now we first saw the
make function when we were talking about slices.

02:21:18.240 --> 02:21:23.430
But we can use that once again here. So if
I copy this variable up here, and I set this

02:21:23.430 --> 02:21:27.771
equal to the result of calling the make function,
and we're going to tell it what type of map

02:21:27.771 --> 02:21:32.220
we want to make. So we're going to use the
map keyword again, the key is type string,

02:21:32.220 --> 02:21:37.090
the value is type integer. And now we can
go ahead and remove this colon. And if we

02:21:37.090 --> 02:21:42.750
run this, we have to remove our m again from
our print statement. Now if we run it, we

02:21:42.750 --> 02:21:47.080
get the same value printed out. So this is
a common way that you can work with maps,

02:21:47.080 --> 02:21:51.021
if you don't have at the time that you're
declaring the variable, the entries that you're

02:21:51.021 --> 02:21:54.530
going to want to put in it. So for example,
if you're populating the map within a loop,

02:21:54.530 --> 02:21:59.200
you might use this syntax. Now another option
that you have with the make is it will take

02:21:59.200 --> 02:22:04.130
a second parameter. So if I run that like
this, then that works. However, I wasn't able

02:22:04.130 --> 02:22:08.820
to find the intention for this. So this is
available. But it doesn't seem to affect the

02:22:08.820 --> 02:22:12.681
length of the map that's created, the map
is always going to be the length of the number

02:22:12.681 --> 02:22:16.260
of elements in it, but it might have some
effect under the covers. If you find that

02:22:16.260 --> 02:22:20.410
what that's for, please leave a comment down
below. So that I can learn along with you

02:22:20.410 --> 02:22:24.430
know, let me go ahead and remove this because
I don't know what it's there for. And I haven't

02:22:24.430 --> 02:22:28.980
seen that very commonly used and run this
again. And we can see that we're back to where

02:22:28.980 --> 02:22:33.230
our map used to be. Now how are we going to
manipulate the values in our map? Well, the

02:22:33.230 --> 02:22:37.550
first thing that we can do is we can pull
out one single value from the map by using

02:22:37.550 --> 02:22:43.490
the square brackets and typing in the value
of the key. So the key can be provided either

02:22:43.490 --> 02:22:48.000
as a variable or as I'm doing here as a literal.
So if I go ahead and run this, we see that

02:22:48.000 --> 02:22:52.260
we get the population of Ohio is 11 point
6 million people. So we can interrogate the

02:22:52.260 --> 02:22:57.960
values of our map. Using this syntax here.
We can also add a value to our map using a

02:22:57.960 --> 02:23:03.990
very similar syntax. So we call on the state
populations variable. And I add a key. In

02:23:03.990 --> 02:23:09.751
this case, let me add the next largest state,
which is Georgia. And it as of 2016, had a

02:23:09.751 --> 02:23:18.710
population of 10,310,371. Now I can pull that
value back out, run this. And we see that

02:23:18.710 --> 02:23:23.391
we get that value printed out of our map.
If we print the entire map out, we see right

02:23:23.391 --> 02:23:28.110
here, Georgia gets added in here. Now, something
you might have noticed, let me do this, I'm

02:23:28.110 --> 02:23:33.511
going to copy this print line here, put it
above where we added the Georgia key. And

02:23:33.511 --> 02:23:37.040
notice the ordering is different. And this
is going to be a very important thing to keep

02:23:37.040 --> 02:23:39.880
in mind as you're iterating through maps later
on,

02:23:39.880 --> 02:23:45.580
the return order of a map is not guaranteed.
So even though we declared California, Texas,

02:23:45.580 --> 02:23:50.130
Florida, New York, Pennsylvania, Illinois,
Ohio, and then added Georgia, this is not

02:23:50.130 --> 02:23:54.400
like a slice, a slice or an array would return
those elements in exactly the same order we

02:23:54.400 --> 02:24:00.080
provided them. In a map, everything is stored
in a way that cannot guarantee the order upon

02:24:00.080 --> 02:24:05.050
returning. So even though we just added one
entry here, it completely changed how everything

02:24:05.050 --> 02:24:08.670
was organized within the map, and we get it
a little bit different output. Now another

02:24:08.670 --> 02:24:12.870
thing that I want to show you is that we can
delete entries from the map. So we can do

02:24:12.870 --> 02:24:17.881
that using the built in delete function. The
first is the map that we want to delete from,

02:24:17.881 --> 02:24:21.561
and then we need to provide the key that we
want to delete. So if we go ahead and delete

02:24:21.561 --> 02:24:27.271
Georgia back out, it wasn't there very long.
But if we run it looks like I need to add

02:24:27.271 --> 02:24:34.780
my s here. Now if we run it, we see that ga
is no longer part of our map. So we can add

02:24:34.780 --> 02:24:39.250
by just calling on the map providing a new
key and value. We can delete using the built

02:24:39.250 --> 02:24:44.831
in delete function, and we can interrogate
a value from the map using those square brackets.

02:24:44.831 --> 02:24:50.410
Now, an interesting thing about deleting is
if I asked for the value of that key again,

02:24:50.410 --> 02:24:55.271
what do you think I'm going to get? So we
see here in the output, Georgia is no longer

02:24:55.271 --> 02:24:59.170
part of the map. So you might expect some
sort of error to be raised. Well, in fact,

02:24:59.170 --> 02:25:04.961
if I run this We get the value zero out. Now
that should cause you some concern, because

02:25:04.961 --> 02:25:09.650
does Georgia have a population of zero? Or
is it missing from our map? Did I just misspell

02:25:09.650 --> 02:25:17.061
the key? What's going on? So for example,
if I fat finger, Ohio, and I forget the I

02:25:17.061 --> 02:25:22.131
and run this, I get a value zero. Well, did
everybody move out of Ohio? What happened?

02:25:22.131 --> 02:25:26.421
What with what we know right now, there's
no way for us to really now. So there's another

02:25:26.421 --> 02:25:32.200
way that we can interrogate our map. And that
is using what's called the comma. Okay, syntax.

02:25:32.200 --> 02:25:36.021
So with doing what we know, right now, we're
basically doing this, we're calling state

02:25:36.021 --> 02:25:42.200
populations. And we're asking for the key,
Ohio, and I'll continue that misspelling.

02:25:42.200 --> 02:25:45.201
And then we're printing out the value of that
population variable, and we get the value

02:25:45.201 --> 02:25:52.110
zero. Well, we can also add an optional comma,
okay, here. And when we do this, let's go

02:25:52.110 --> 02:25:56.570
ahead and add that okay, variable to the output
and see what that's going to do. So notice

02:25:56.570 --> 02:26:02.240
that this prints out the value false. So the
okay is false if the key was not found within

02:26:02.240 --> 02:26:06.721
our map, but if we add the eye back in and
correct our spelling, we see that we get the

02:26:06.721 --> 02:26:10.530
value true out. So if you're in a situation
where you're not sure if the key is in the

02:26:10.530 --> 02:26:15.690
map or not, then you can use this comma, okay,
syntax. As a matter of fact, if you just want

02:26:15.690 --> 02:26:20.141
to check for presence, then we can use that
right on the operator again, in order to throw

02:26:20.141 --> 02:26:24.341
away the actual value. And then we just get
the okay variable printed back out. Now, there's

02:26:24.341 --> 02:26:29.080
nothing magic about the variable name, okay.
But it is conventional to use, okay, and you

02:26:29.080 --> 02:26:33.271
go programs when you're using it for this
kind of a test. The next thing that I want

02:26:33.271 --> 02:26:37.221
to show you about maps is we can in fact,
find out how many elements are in them. So

02:26:37.221 --> 02:26:42.000
we can do that using the built in Le n function.
So if I go ahead and run that, we see that

02:26:42.000 --> 02:26:47.721
we get the value seven, and we have let's
see 12345 yet we have got seven states declared

02:26:47.721 --> 02:26:51.660
in our map right now. So if we added another
state back in, then the length function would

02:26:51.660 --> 02:26:57.880
return eight. The other thing that's interesting
to know is that just like slices, when you

02:26:57.880 --> 02:27:01.761
have multiple assignments to a map, which
is especially important when you're passing

02:27:01.761 --> 02:27:07.690
maps into functions, the underlying data is
passed by reference, which means manipulating

02:27:07.690 --> 02:27:12.261
one variable that points to a map is going
to have an impact on the other one, so I can

02:27:12.261 --> 02:27:18.090
demonstrate that by creating another variable
called SP, and set that equal to state populations.

02:27:18.090 --> 02:27:23.761
And then let's go ahead and delete poor Ohio
out of SP, it always seems to get left out.

02:27:23.761 --> 02:27:30.880
And then we can print out SP and print out
state populations. So if I run this, we see

02:27:30.880 --> 02:27:35.271
that in our first result, we don't have the
entry Ohio anymore. And then our second

02:27:35.271 --> 02:27:39.530
print statement, which is the original map,
Ohio has been removed from there as well.

02:27:39.530 --> 02:27:43.960
So if you start passing maps around and you
start manipulating the data within that map,

02:27:43.960 --> 02:27:48.660
keep in mind, you can have side effects on
the calling functions or any other place where

02:27:48.660 --> 02:27:53.630
that map is referred to. Because manipulating
the map in one place is going to have impacts

02:27:53.630 --> 02:27:57.490
on every other place to use. So the final
collection type that I want to talk about

02:27:57.490 --> 02:28:02.450
today is called a struct. Now at first, you
might not think of a struct as a collection

02:28:02.450 --> 02:28:07.160
type. But go with me on this, if I drop in
an example, we see here an example of a struct.

02:28:07.160 --> 02:28:10.970
Now I'm in kind of a doctor who frame of mind
today. So we're going to run with an example

02:28:10.970 --> 02:28:14.101
that's talking about some information about
one of the doctors from Doctor Who. So if

02:28:14.101 --> 02:28:18.431
I go ahead and run this, we can see that we're
getting information on the third doctor, the

02:28:18.431 --> 02:28:23.050
actor's name is john Pertwee, we see some
of his companions listed out here. So the

02:28:23.050 --> 02:28:27.740
reason I call this a collection type is look
at the declaration or the struck on line seven

02:28:27.740 --> 02:28:33.260
through 11. What we have here is a list of
field names. So we've got number, actor name

02:28:33.260 --> 02:28:39.141
and companions as field names, and then a
type associated with that field. So the doctor

02:28:39.141 --> 02:28:44.590
number is an integer, the actor name is a
string, and the companions is a slice of strings.

02:28:44.590 --> 02:28:51.090
So what the struct type does is it gathers
information together that are related to one

02:28:51.090 --> 02:28:55.570
concept, in this case, a doctor. And it does
it in a very flexible way. Because we don't

02:28:55.570 --> 02:28:59.681
have to have any constraints on the types
of data that's contained within our struct,

02:28:59.681 --> 02:29:04.840
we can mix any type of data together. And
that is the true power of a struct. Because

02:29:04.840 --> 02:29:09.681
all of the other collection types we've talked
about have had to have consistent types. So

02:29:09.681 --> 02:29:14.500
arrays always have to store the same type
of data slices have the same constraint. And

02:29:14.500 --> 02:29:18.201
we just talked about maps and how their keys
always have to have the same type. And their

02:29:18.201 --> 02:29:22.200
values always have to have the same type within
the same map. When a struct we can have our

02:29:22.200 --> 02:29:26.900
fields describe any type of data that we want.
So we can have structs that contain other

02:29:26.900 --> 02:29:31.021
structs, anything that we want. So while in
a lot of ways, structs are the simplest type

02:29:31.021 --> 02:29:35.351
of collection that we're going to be talking
about. They're also one of the most powerful.

02:29:35.351 --> 02:29:39.910
So we see down here in the main function,
how we can create a struct and I'm using the

02:29:39.910 --> 02:29:43.730
declaration syntax, where I'm using named
fields. So we're going to create a variable

02:29:43.730 --> 02:29:47.641
called a doctor. And we're going to use this
literal syntax. So we list the type of the

02:29:47.641 --> 02:29:52.860
struct doctor, we use the curly braces like
we do with every other literal definition.

02:29:52.860 --> 02:29:57.601
And then I have a list of the field names
colon and the value. So number colon three

02:29:57.601 --> 02:30:02.120
after name colon, john Pertwee, and then campaign
To set equal to this slice of strings now

02:30:02.120 --> 02:30:06.860
notice that when I'm setting something equal
to a slice, I do actually have to tell go,

02:30:06.860 --> 02:30:11.471
what kind of collection type, I'm initializing
for that, and then down here on line 23, I

02:30:11.471 --> 02:30:15.391
go ahead and print the entire value of the
struct out. And you see that I get the values

02:30:15.391 --> 02:30:19.181
printed out, I see three, john Pertwee, and
then the three companions that john Pertwee

02:30:19.181 --> 02:30:24.641
had, in his time as the doctor. Now if we
want to interrogate one value from a struct,

02:30:24.641 --> 02:30:29.561
then we're going to use what's called the
dot syntax. So if we ask for the actor name

02:30:29.561 --> 02:30:33.800
of this struct, then we're going to put a
dot after the variable name, put in the field

02:30:33.800 --> 02:30:38.681
name. And when we run this, we see that we
get john Pertwee out. So we can work with

02:30:38.681 --> 02:30:42.960
the struct as a whole, or we can start drilling
down. As a matter of fact, we can drill down

02:30:42.960 --> 02:30:49.110
through the structure. So if we ask for the
companions, we can get that out, certainly.

02:30:49.110 --> 02:30:54.130
But this is a slice like any other slice.
So if I just want the second item in the collection,

02:30:54.130 --> 02:30:59.690
I can get Joe grant out by interrogating the
slice that gets returned by asking for the

02:30:59.690 --> 02:31:03.870
companions field. Now another way that we
can instantiate our struct is using what's

02:31:03.870 --> 02:31:08.761
called a positional syntax. So here, I'm listing
the field names, but it don't have to. So

02:31:08.761 --> 02:31:14.181
if I go ahead and take these out, and take
this out, so I print the entire struct out,

02:31:14.181 --> 02:31:19.440
then I get exactly the same result as I got
the first time. Now, this is valid go syntax,

02:31:19.440 --> 02:31:23.720
I would encourage you not to use it, though.
And the reason for that is it can become a

02:31:23.720 --> 02:31:27.740
maintenance problem. So for example, let's
just say that this is our struct, and this

02:31:27.740 --> 02:31:31.950
is checked into source control, and everybody's
happy with it. But then let's say we have

02:31:31.950 --> 02:31:36.110
a change request Comm. And we're going to
add a list of the episodes that each doctor

02:31:36.110 --> 02:31:39.811
appeared in. So that's going to be another
slice of strings. And that gets added right

02:31:39.811 --> 02:31:40.811
here.

02:31:40.811 --> 02:31:44.792
Well, if we use the positional syntax and
try and run this, we've got a problem. Because

02:31:44.792 --> 02:31:49.101
go doesn't know how to map the fields that
we provided into the initializer. Because

02:31:49.101 --> 02:31:53.541
there's three values provided in the initializer.
And there's four values in the struct. So

02:31:53.541 --> 02:31:57.841
we have to find every place that we have one
of these declared with the positional syntax.

02:31:57.841 --> 02:32:02.090
And we have to add, for example, a placeholder
or populated or something. So we go ahead

02:32:02.090 --> 02:32:07.021
and run this and everything's working again.
But now, what happens if another change comes

02:32:07.021 --> 02:32:13.851
along, and somebody does this? Now they've
changed the order of the fields. When we run

02:32:13.851 --> 02:32:21.340
this, everything looks fine. But when I asked
for the doctor's companions, again, I get

02:32:21.340 --> 02:32:26.322
an empty slice, because the positional syntax
requires the fields to be declared in the

02:32:26.322 --> 02:32:30.771
correct order, much better for us to go ahead
and add in the field names. So let me drop

02:32:30.771 --> 02:32:36.330
those in real fast here. Now when I run this,
I get the expected results out. And notice

02:32:36.330 --> 02:32:39.881
what the field names syntax, I don't even
have to have it in the same order as they're

02:32:39.881 --> 02:32:44.760
declared in the struct go is going to figure
out how to map the data from the initializer

02:32:44.760 --> 02:32:49.990
over into the object that's created by using
those field names. The other advantage that

02:32:49.990 --> 02:32:53.630
I have is, if I don't have any information
about the episodes at this point in my program,

02:32:53.630 --> 02:32:59.450
I actually can ignore the fact that that field
exists. And what this means is I changed the

02:32:59.450 --> 02:33:04.530
underlying struct without changing the usage
at all, which makes my application a little

02:33:04.530 --> 02:33:10.070
bit more robust and change proof. So while
it is possible for you to use the positional

02:33:10.070 --> 02:33:14.480
syntax, I would strongly recommend you do
not use it unless you've got a very short

02:33:14.480 --> 02:33:19.311
lived struct. We'll talk about anonymous structs
here in a second. And in those situations,

02:33:19.311 --> 02:33:22.860
positional declaration might make sense because
that struct is not going to live for very

02:33:22.860 --> 02:33:27.480
long. However, I would strongly recommend
anytime you're taking the time to declare

02:33:27.480 --> 02:33:31.271
a type, like we're doing here on line seven,
then you're generally going to be better served

02:33:31.271 --> 02:33:35.320
by using field names explicitly instead of
the positional syntax. Okay, the next thing

02:33:35.320 --> 02:33:39.370
I want to talk about are naming conventions.
So as you can see, here, I've got my type

02:33:39.370 --> 02:33:43.940
declared as Doctor with a capital D, and the
fields declared as lowercase. So the rules

02:33:43.940 --> 02:33:47.870
in this situation, follow the rules for any
other variable and go, if we start with a

02:33:47.870 --> 02:33:52.220
capital letter, it's going to be exported
from the package. If we start with a lowercase

02:33:52.220 --> 02:33:56.891
letter, it's going to be internal to the package.
So in this case, I can work with all of the

02:33:56.891 --> 02:34:01.601
fields, because I'm declaring the doctor type
in my main package. And so my main function,

02:34:01.601 --> 02:34:06.070
which is also in the main package has access
to it. However, nothing in any other package

02:34:06.070 --> 02:34:10.221
would have access to this. So it would be
able to see that there is a doctor struct,

02:34:10.221 --> 02:34:14.410
but it wouldn't see any field names. So if
I did want to publish these out, so anything

02:34:14.410 --> 02:34:19.750
can use them, I would have to go ahead and
capitalize these field names, of course, or

02:34:19.750 --> 02:34:24.700
have to capitalize them in my declaration
as well. And then when I run I get the exact

02:34:24.700 --> 02:34:29.540
same result that I got before. So I forgot
to change this variable as well go ahead and

02:34:29.540 --> 02:34:33.570
run that, and I get the expected result out.
So generally, we're going to follow the same

02:34:33.570 --> 02:34:38.000
convention as we do with any other variable.
uppercase is going to export lowercase is

02:34:38.000 --> 02:34:43.120
going to import, you should use Pascal casing
and camel casing, you shouldn't have underscores

02:34:43.120 --> 02:34:47.510
and things like that in your field names or
in your struct names. Now if you notice here

02:34:47.510 --> 02:34:52.610
on line seven, I have explicitly created a
type called a struct. And that's going to

02:34:52.610 --> 02:34:55.700
be a very common way that you're going to
see struct to use. You see you're going to

02:34:55.700 --> 02:34:59.420
define a type and then everywhere you need
to use that struct, you can just refer to

02:34:59.420 --> 02:35:04.010
it by its type. But we don't have to do that.
And there are some situations where you might

02:35:04.010 --> 02:35:08.471
see a program like this. So on line eight,
we're declaring what's called an anonymous

02:35:08.471 --> 02:35:14.660
struct. So instead of setting up a type, and
saying, doctor, and that's going to be a struct,

02:35:14.660 --> 02:35:17.910
and that's going to have a single field called
name, that's going to take a string. We're

02:35:17.910 --> 02:35:23.591
condensing all of that into this single declaration
right here. Now, I can't use this anywhere

02:35:23.591 --> 02:35:26.940
else, because it's anonymous. And so it doesn't
have an independent name that I can refer

02:35:26.940 --> 02:35:32.160
to it. But I can certainly use this just fine.
So let me go ahead and delete this. And then

02:35:32.160 --> 02:35:37.400
notice I'm using the initializer syntax right
here. So we got two sets of curly braces,

02:35:37.400 --> 02:35:41.500
it's very important to remember what each
one is doing. So the first set of curly braces

02:35:41.500 --> 02:35:46.311
is paired to the struct keyword. And it's
defining the structure of the struct. The

02:35:46.311 --> 02:35:50.480
second is the initializer. And it's what's
going to provide data into the struct. So

02:35:50.480 --> 02:35:54.360
if we run this application, we see that we
do get the struct with the value john Pertwee

02:35:54.360 --> 02:35:59.000
printed out and everything's gonna work just
fine. Now, when are you going to use this,

02:35:59.000 --> 02:36:03.181
this is going to be used in relatively few
situations, basically, you're going to use

02:36:03.181 --> 02:36:07.010
this in situations where you need to structure
some data in a way that you don't have in

02:36:07.010 --> 02:36:11.530
a formal type. But it's normally only going
to be very short lived. So you can think about

02:36:11.530 --> 02:36:16.420
if you have a data model that's coming back
in a web application, and you need to send

02:36:16.420 --> 02:36:21.061
a projection or a subset of that data down
to the client, you could create an anonymous

02:36:21.061 --> 02:36:23.940
struct in order to organize that information.

02:36:23.940 --> 02:36:26.590
So you don't have to create a formal type
that's going to be available throughout your

02:36:26.590 --> 02:36:29.500
package for something that might be used only
one time.

02:36:29.500 --> 02:36:35.341
Now, unlike maps, structs are value types.
So if I take this example here, and let's

02:36:35.341 --> 02:36:40.740
just use the same basic manipulation that
we've been doing with all of these collections,

02:36:40.740 --> 02:36:44.410
so I'm going to create another struct, and
I'm going to assign it to the value of my

02:36:44.410 --> 02:36:48.190
current struct, and then I'm going to manipulate
the value of that name field. So I'm going

02:36:48.190 --> 02:36:53.460
to create another doctor called Tom Baker.
And then let's see what happens when we print

02:36:53.460 --> 02:36:58.800
both of these doctors out. So as you can see,
even though I copied another doctor from a

02:36:58.800 --> 02:37:03.511
doctor, and change the value, the values remain
independent. So a doctor still has the name

02:37:03.511 --> 02:37:08.891
john Pertwee, another doctor has the name
Tom Baker. So unlike maps, and slices, these

02:37:08.891 --> 02:37:13.671
are referring to independent datasets. So
when you pass a struct around in your application,

02:37:13.671 --> 02:37:17.330
you're actually passing copies of the same
data around. So if you've got structs, that

02:37:17.330 --> 02:37:21.220
are very, very large, keep in mind, you're
creating a copy every time you're manipulating

02:37:21.220 --> 02:37:26.660
this. Now, just like with arrays, if we do
want to point to the same underlying data,

02:37:26.660 --> 02:37:31.550
we can use that address of operator. And when
we run this, we have in fact, both variables

02:37:31.550 --> 02:37:37.601
pointing to the same underlying data. A doctor
is the struct itself. Another doctor is a

02:37:37.601 --> 02:37:42.740
pointer to the struct. So when we manipulate
its name field, we're actually manipulating

02:37:42.740 --> 02:37:47.230
the Name field of the a doctor struct. The
next thing that I want to talk to you about

02:37:47.230 --> 02:37:52.450
in go is a concept called embedding. Now,
you may have heard in your research on the

02:37:52.450 --> 02:37:56.900
go language that go doesn't support traditional
object oriented principles. So for example,

02:37:56.900 --> 02:38:00.300
we don't have inheritance, and oh, my goodness,
how am I going to create my program if I don't

02:38:00.300 --> 02:38:04.710
have inheritance available? Well, let me show
you what go has, instead of an inheritance

02:38:04.710 --> 02:38:10.820
model. It uses a model that's similar to inheritance
called composition. So where inheritance is

02:38:10.820 --> 02:38:16.580
trying to establish the is a relationship.
So if we take this example here, if we were

02:38:16.580 --> 02:38:20.660
in a traditional object oriented language,
we wouldn't want to say that a bird is an

02:38:20.660 --> 02:38:26.190
animal, and therefore a bird has a name a
bird has an origin, a bird has also bird things

02:38:26.190 --> 02:38:31.471
like its speed, and if it can fly or not,
go doesn't support that model. But instead,

02:38:31.471 --> 02:38:36.050
it supports composition through what's called
embedding. So right now we see that animal

02:38:36.050 --> 02:38:40.980
and bird are definitely independent structs,
there's no relationship between them. However,

02:38:40.980 --> 02:38:47.940
I can say that a bird has animal like characteristics
by embedding an animal struct in here like

02:38:47.940 --> 02:38:53.620
this. So I've just embedded the struct itself,
I haven't provided a name. Now, if I did something

02:38:53.620 --> 02:38:59.570
like this, then how to have a named field
in the bird called animal. But I'm not doing

02:38:59.570 --> 02:39:04.920
that I'm doing this. So I'm just saying embed
the animal struct right into the bird struct.

02:39:04.920 --> 02:39:10.160
Now how can I use this? Well, let me drop
in a new main function here. And then you

02:39:10.160 --> 02:39:14.780
can see, so I'm creating an instance of a
bird. And then I'm initializing the variables.

02:39:14.780 --> 02:39:19.000
So name is going to be E mu origin is going
to be Australia, the speed is 48 kilometers

02:39:19.000 --> 02:39:24.660
an hour, and it cannot fly. So if I print
this out, I see that other than a little bit

02:39:24.660 --> 02:39:28.540
of a strange syntax with that inner type,
I see that I have all of my fields defined,

02:39:28.540 --> 02:39:34.610
it's a matter of fact, I can come in here
and dig into any one of those animal fields.

02:39:34.610 --> 02:39:39.311
And everything worked exactly like I would
expect them to so it kind of looks like bird

02:39:39.311 --> 02:39:43.590
is inheriting the properties of animal. But
really what's happening here is there's some

02:39:43.590 --> 02:39:50.250
syntactic sugar go is handling the delegation
of the request for the Name field automatically

02:39:50.250 --> 02:39:55.320
to the embedded animal type for you. So if
you try and pass these around and look to

02:39:55.320 --> 02:40:01.101
see if the bird is a type of animal, it is
not bird is still an issue. Independent struct

02:40:01.101 --> 02:40:05.620
that has no relationship to an animal other
than the fact that it embeds it. So it's not

02:40:05.620 --> 02:40:10.900
a traditional inheritance relationship where
a bird is an animal. Instead, it's a composition

02:40:10.900 --> 02:40:17.360
relationship, which is answering the question
has a, so a bird has an animal, or has animal

02:40:17.360 --> 02:40:22.521
like characteristics is how we would say it
in this example. But it is not the same thing

02:40:22.521 --> 02:40:27.120
as an animal, they cannot be used interchangeably.
In order to use data interchangeably, we're

02:40:27.120 --> 02:40:31.420
going to have to use something called interfaces,
which we'll talk about a little bit later.

02:40:31.420 --> 02:40:35.960
Now we can see in this example, that if we
declare the type, and we initialize the variables

02:40:35.960 --> 02:40:39.811
afterward, everything's pretty clear, we can
just treat all of the fields as if they're

02:40:39.811 --> 02:40:43.910
owned by the bird struct. And we don't have
to worry about the internal structure of the

02:40:43.910 --> 02:40:48.431
struct. And that's very intentional. However,
if we're going to use the literal syntax,

02:40:48.431 --> 02:40:51.830
we do have to know a little bit about the
birds internal structure. So let me drop in

02:40:51.830 --> 02:40:56.200
this code here, clean up our formatting a
little bit, and then remove these lines here.

02:40:56.200 --> 02:41:02.090
So this is declaring exactly the same object,
we're going to have an E mu from Australia,

02:41:02.090 --> 02:41:08.160
the speed is actually going to be 48 kilometers
an hour, and can fly is going to be false.

02:41:08.160 --> 02:41:12.670
But notice what I have to do here, I have
to explicitly talk about the internal animal

02:41:12.670 --> 02:41:18.200
struct. So when I'm working with the literal
syntax, I have to be aware that I'm using

02:41:18.200 --> 02:41:22.422
embedding. But if I just declare the object
and manipulate it from the outside, I don't

02:41:22.422 --> 02:41:28.061
have to be aware of it at all. Now, when should
you use embedding? Well, I will say Generally,

02:41:28.061 --> 02:41:32.580
if you're talking about modeling behavior,
embedding is not the right choice for you

02:41:32.580 --> 02:41:37.041
to use. When we get into methods, we will
see that embedding will allow behaviors or

02:41:37.041 --> 02:41:42.070
methods to carry through into the type that
has the embedding. However, the fact that

02:41:42.070 --> 02:41:47.470
we can't use them interchangeably, is a very
severe limitation. Generally, it's much better

02:41:47.470 --> 02:41:53.041
to use interfaces when you want to describe
common behavior. So when is embedding a good

02:41:53.041 --> 02:41:57.990
idea? Well, if you're offering a library,
for example, and let's just say you're making

02:41:57.990 --> 02:42:03.040
a web framework, and you've got a very sophisticated
base controller, in that case, you might want

02:42:03.040 --> 02:42:08.000
to use consumers of your library to embed
that base controller into their custom controllers,

02:42:08.000 --> 02:42:11.771
so that they can get useful functionality
out of it. In that case, you're not talking

02:42:11.771 --> 02:42:16.480
about polymorphism. And the ability to interchangeably
use objects, you're just trying to get some

02:42:16.480 --> 02:42:21.461
base behavior into a custom type. And in that
case, embedding makes sense. The last thing

02:42:21.461 --> 02:42:26.101
that I want to talk about with structs is
a concept called tags. So let me just drop

02:42:26.101 --> 02:42:30.160
in another example program here that we can
work with. This is a simpler version of what

02:42:30.160 --> 02:42:33.811
we had before, because we don't need to structs
for this conversation. So we're just going

02:42:33.811 --> 02:42:37.240
to have a simple animal struct with the name
of the origin fields. And then what I want

02:42:37.240 --> 02:42:43.230
to do is I want to add what's called a tag
in order to describe some specific information

02:42:43.230 --> 02:42:47.730
about this name field. So let's say for example,
that I'm working with some validation framework.

02:42:47.730 --> 02:42:51.590
So let's just say that I'm working within
a web application, and the user is filling

02:42:51.590 --> 02:42:55.851
out a form and two of the fields are providing
the name and the origin. And I want to make

02:42:55.851 --> 02:42:59.950
sure that the name is required and doesn't
exceed a maximum length. So I can do that

02:42:59.950 --> 02:43:04.480
with a tag that looks something like this.
So the format of a tag is to have backticks

02:43:04.480 --> 02:43:09.091
as the delimiters of the tag, and then we
have these space delimited key value pairs.

02:43:09.091 --> 02:43:13.410
So my first field is going to be required.
So I'm going to say that the Name field is

02:43:13.410 --> 02:43:19.271
required. And then I've got a max length argument,
which in this case, is set to 100 characters.

02:43:19.271 --> 02:43:22.480
So the value of the tag is arbitrary, you
could actually put any string that you want

02:43:22.480 --> 02:43:26.470
in here, but this is the conventional use
within go, we're going to use space delimited

02:43:26.470 --> 02:43:31.381
sub tags. And then if you do need a key value
relationship, then you're going to use a colon

02:43:31.381 --> 02:43:35.790
to separate the key and the value. And then
the value is typically put in quotation marks.

02:43:35.790 --> 02:43:39.721
So now that we have this, how do we get at
it? Well, the way that we're going to get

02:43:39.721 --> 02:43:44.561
at it is using gos reflection package. So
there's no straightforward way from an object

02:43:44.561 --> 02:43:48.900
to get at the tags of a field, you have to
use reflection in order to get that, unfortunately,

02:43:48.900 --> 02:43:53.021
go makes this pretty easy. So the first thing
that I need to do is I need to get the type

02:43:53.021 --> 02:43:59.670
of an object that I'm working with. So I get
that using the reflect packages type of function.

02:43:59.670 --> 02:44:03.750
And I have to pass in an object to this. So
I will just initialize an empty animal to

02:44:03.750 --> 02:44:09.101
get them that and then I can grab a field
from that type, using the types field by name

02:44:09.101 --> 02:44:12.891
method, and then passing in the name. In this
case, I want the name name. And now I can

02:44:12.891 --> 02:44:20.360
get at the tag by asking for the tag property
of the field. So if I run this, we see that

02:44:20.360 --> 02:44:24.340
I do in fact, get that tag out. Now, what
do I do with that? Well, that's really up

02:44:24.340 --> 02:44:29.860
to my validation framework to figure out all
tags do is provide a string of text and something

02:44:29.860 --> 02:44:34.740
else has to figure out what to do with that.
So this tags value is meaningless to go itself,

02:44:34.740 --> 02:44:38.101
we're then going to have to have some sort
of a validation library that's going to have

02:44:38.101 --> 02:44:42.650
to parse this figure out that yes, required
is part of the tag. And then it's going to

02:44:42.650 --> 02:44:46.511
have to decide well, if required is there
and then I'm going to apply this logic making

02:44:46.511 --> 02:44:51.420
sure the string is non empty or whatever makes
sense in our use case. Okay, so that finishes

02:44:51.420 --> 02:44:55.851
up what I have to talk about with maps and
structs. Let's go into a summary and review

02:44:55.851 --> 02:45:00.130
what we've talked about. In this video we
talked about the two remaining collections

02:45:00.130 --> 02:45:03.521
types that are available and go, we talked
about maps, and we talked about structs. And

02:45:03.521 --> 02:45:07.241
when we talked about maps, we learned that
they are collections of value types that can

02:45:07.241 --> 02:45:12.650
be accessed by keys, they can be created as
literals, or via the make function, and members

02:45:12.650 --> 02:45:17.940
are accessed via the square bracket key syntax,
we can check for the presence of an element

02:45:17.940 --> 02:45:24.620
within a map using this comma, okay syntax.
So we can ask for the value at a comma, okay,

02:45:24.620 --> 02:45:29.110
and what the map is going to return is the
value type as well as a Boolean, that's going

02:45:29.110 --> 02:45:33.721
to indicate if the value was found or not.
Now, if the value wasn't found, your value

02:45:33.721 --> 02:45:38.641
variable is going to be the zero value of
the value type in that map. So for example,

02:45:38.641 --> 02:45:42.740
if you've got a map of strings to strings,
and the element isn't found, you're going

02:45:42.740 --> 02:45:46.940
to get an empty string returned out, if you've
got a map of string to integers, for example,

02:45:46.940 --> 02:45:50.950
you're going to get the value zero. If you
have multiple assignments to the same map,

02:45:50.950 --> 02:45:54.811
they all point to the same underlying data.
So they're what are called reference types,

02:45:54.811 --> 02:45:59.061
which means that if you manipulate the data
in a map in one location, any other variables

02:45:59.061 --> 02:46:03.300
that are pointing to that same map are going
to see that change as well. We then went on

02:46:03.300 --> 02:46:09.280
to talk about the struct type, and how they're
a collection of disparate data types. So whereas

02:46:09.280 --> 02:46:14.900
arrays and slices and maps are all collecting
the same data type together, a struct is unique

02:46:14.900 --> 02:46:20.910
in that it collects any type of data together.
So you've got a common field name. But those

02:46:20.910 --> 02:46:26.320
fields can point to any valid data structure
within go. They're keyed by name fields, which

02:46:26.320 --> 02:46:31.030
generally follow the syntax of any valid variable,
including whether they export it or not. So

02:46:31.030 --> 02:46:35.380
if you capitalize the name of the field, then
that's going to be exported from the package.

02:46:35.380 --> 02:46:39.010
If you leave it lowercase, then that's going
to be kept internal to the package. They're

02:46:39.010 --> 02:46:44.330
normally created as types. But we can create
anonymous structs if we need to. And again,

02:46:44.330 --> 02:46:49.601
common use cases for this are very short lived
structs, such as generating a JSON response

02:46:49.601 --> 02:46:54.960
to a web service call, that's only used one
time. structs are value types. So if I assign

02:46:54.960 --> 02:46:59.760
a variable to an existing struct, then all
of the struct values are going to be copied

02:46:59.760 --> 02:47:03.771
over to create a brand new struct. So if I
manipulate a struct in one location, it's

02:47:03.771 --> 02:47:08.130
not going to affect any other variables in
your application. We don't have an inheritance

02:47:08.130 --> 02:47:13.150
system within go. But we can use composition
using what's called embedding. So when we

02:47:13.150 --> 02:47:17.790
want to embed one struct within another, we
just list the type of the struct, and we don't

02:47:17.790 --> 02:47:22.860
give it a field name. Go is then going to
automatically interpret that for us and delegate

02:47:22.860 --> 02:47:27.971
any calls for fields or methods in the containing
struct down to the embedded struct. If that

02:47:27.971 --> 02:47:31.070
top level struct doesn't contain a member
with that name, we

02:47:31.070 --> 02:47:35.120
also learned a little bit about tags and how
they can be added to struct fields to describe

02:47:35.120 --> 02:47:39.930
that field in some way. So there's a lot of
different use cases. For this. The JSON package

02:47:39.930 --> 02:47:44.980
uses this to provide ways to map field names
from NGO field names, which are typically

02:47:44.980 --> 02:47:49.460
uppercase to follow JSON conventions, which
are typically lowercase. We also saw that

02:47:49.460 --> 02:47:54.130
we can use this, for example, to pass information
into a validation framework. And that framework

02:47:54.130 --> 02:47:58.800
could generate errors. If we need fields to
be required, or have rules about their length

02:47:58.800 --> 02:48:03.280
or things like that, I want to start a discussion
about the tools that go makes available to

02:48:03.280 --> 02:48:08.971
control the flow of execution in our applications.
In today's video, we're going to focus on

02:48:08.971 --> 02:48:13.640
two of these tools, the if statement and the
switch statement. We'll start a discussion

02:48:13.640 --> 02:48:17.110
by talking about if statements. And we'll
talk about all of the different ways that

02:48:17.110 --> 02:48:21.480
we can use them in our applications. And we're
going to specifically focus on the various

02:48:21.480 --> 02:48:25.771
operators that are often associated with working
with if statements. And we'll go through what

02:48:25.771 --> 02:48:30.570
those are and how you can use them. And then
we'll talk about the relatives of the if statement.

02:48:30.570 --> 02:48:35.130
And those are the if else statement. And the
if else if statement. We'll then move on to

02:48:35.130 --> 02:48:39.340
talk about switch statements. And we'll start
that conversation with some simple use cases

02:48:39.340 --> 02:48:44.650
for switch statements. We'll then talk about
cases with multiple tests, how we can follow

02:48:44.650 --> 02:48:48.480
through from one case to another in our switch
statements. And then we'll talk about this

02:48:48.480 --> 02:48:52.671
special version of a switch called a type
switch. So let's go ahead and jump in and

02:48:52.671 --> 02:48:57.820
start learning about if statements. In order
to start our discussion about if statements,

02:48:57.820 --> 02:49:01.910
I want to start as simply as we can. So if
you look at this application here, it's got

02:49:01.910 --> 02:49:05.970
just about the simplest if statement that
I could come up with. So we're going to start

02:49:05.970 --> 02:49:09.891
with the if keyword as you see here on line
eight. And then we're going to have an expression

02:49:09.891 --> 02:49:13.230
that generates some kind of a Boolean result.
And that's actually where we're gonna spend

02:49:13.230 --> 02:49:16.660
a lot of time when we're talking about if
statements is how to generate these Boolean

02:49:16.660 --> 02:49:21.240
results. In this case, I'm just using the
literal true, which is the simplest Boolean

02:49:21.240 --> 02:49:26.540
result that we can come up with. And then
inside of these curly braces here, I've got

02:49:26.540 --> 02:49:31.351
the code that's going to execute if that Boolean
test returns true. So in this case, since

02:49:31.351 --> 02:49:35.200
we're using a literal true, then the test
is always going to pass. And when I run this

02:49:35.200 --> 02:49:39.471
application, I see that I get this test is
true printed out in the results here, if I

02:49:39.471 --> 02:49:43.641
change this to a literal false, and we see
that we don't get any output from the application

02:49:43.641 --> 02:49:47.921
because the code inside of the curly braces
is not executed. Now, one thing to keep in

02:49:47.921 --> 02:49:53.510
mind if you're coming to go from another language,
is you may be expecting this to be valid syntax.

02:49:53.510 --> 02:49:57.370
Well, if we try and run this, we actually
are going to get a syntax error because one

02:49:57.370 --> 02:50:01.171
of the design decisions that was made with
go is that You're never allowed to have a

02:50:01.171 --> 02:50:05.101
single line block evaluated as the result
of an if statement. So you always have to

02:50:05.101 --> 02:50:10.260
use curly braces, even if you only have one
line to execute. Now, this style of this statement

02:50:10.260 --> 02:50:14.880
has the Boolean test right here. And that's
the only thing after the if clause. There's

02:50:14.880 --> 02:50:19.040
actually another style that's very commonly
used in the go language. And that's what I

02:50:19.040 --> 02:50:25.170
would call the initializer syntax. So as you
see here on line 17, we've got a call into

02:50:25.170 --> 02:50:29.830
a map that's pulling out the value from a
map, and it's pulling out the okay variable.

02:50:29.830 --> 02:50:35.021
And then notice I've got this semi colon,
and then the Boolean result listed here. So

02:50:35.021 --> 02:50:40.400
this part here, this first part of the if
statement, is the initializer. So the initializer

02:50:40.400 --> 02:50:45.101
allows us to run a statement and generate
some information that's going to set us up

02:50:45.101 --> 02:50:49.330
to work within the F block. So in this case,
I'm generating a Boolean result by interrogating

02:50:49.330 --> 02:50:53.710
the map. And then I'm using that as the test
to see if the code inside the if block should

02:50:53.710 --> 02:50:59.860
execute or not, I also have access to the
pop variable that I'm creating right here

02:50:59.860 --> 02:51:04.660
inside of the F test, and that variable is
going to be scoped to the block. So if I execute

02:51:04.660 --> 02:51:09.760
this, you see that I get the population of
Florida printed out, no problem there. If

02:51:09.760 --> 02:51:15.530
I try and work with that variable outside
of here, and printed out again, I'm going

02:51:15.530 --> 02:51:19.760
to get an undefined error, because the pop
of variables is only defined within the scope

02:51:19.760 --> 02:51:24.550
of that if statement. The next thing that
I want to talk about with if statements are

02:51:24.550 --> 02:51:28.440
the comparison operators that we have. I mean,
obviously, as long as we can generate pure

02:51:28.440 --> 02:51:33.120
Boolean values, things are going to be pretty
simple. But that's a pretty limited benefit,

02:51:33.120 --> 02:51:36.650
because in a lot of applications, we need
to do some kind of a comparison in order to

02:51:36.650 --> 02:51:41.540
determine if the branch should execute or
not. So let me drop in this example here.

02:51:41.540 --> 02:51:44.881
And let's just say that we're building some
kind of a number guessing game. Now to keep

02:51:44.881 --> 02:51:48.230
things as simple as possible. This is going
to be a pretty simple number guessing game,

02:51:48.230 --> 02:51:50.891
because we're going to hard code the value
that we're going to guess. And we're going

02:51:50.891 --> 02:51:53.630
to hard code our guests. So we're not going
to have a user interface involved here at

02:51:53.630 --> 02:51:57.471
all. And we're not going to randomly generate
the number that way, it's very clear what

02:51:57.471 --> 02:52:01.320
the application is doing. So right now what
we have is we've got the number that we're

02:52:01.320 --> 02:52:05.620
going to try and guess we've got our guests
here on line nine. And then we've got a couple

02:52:05.620 --> 02:52:10.320
of tests. So in line 10, we're checking to
see if the guess is less than the numbers.

02:52:10.320 --> 02:52:15.130
So this is the first comparison operator that
we're looking at. This is the less than operator,

02:52:15.130 --> 02:52:20.070
we also have the greater than operator and
the equality operator. So if we run this with

02:52:20.070 --> 02:52:24.230
the guests of 30, and a number of 50, we're
going to get the value to low printed out

02:52:24.230 --> 02:52:28.620
because this first test evaluates to true.
And the second and third test evaluate to

02:52:28.620 --> 02:52:34.330
false. If I change my guest to 70, and run,
then the second test evaluates to true and

02:52:34.330 --> 02:52:38.370
the first and third evaluate to false. And
as you might expect, if I put in a guess of

02:52:38.370 --> 02:52:43.320
50, and run this, then I finally got it. So
this is the basics of a number guessing game,

02:52:43.320 --> 02:52:47.351
all you need to do is wrap this in loops,
which we'll talk about in a future video and

02:52:47.351 --> 02:52:51.400
add a little bit of a user interface and you've
got your first game written in the go language.

02:52:51.400 --> 02:52:54.891
Now there's some other operators that we have
available. And it's a little hard to justify

02:52:54.891 --> 02:52:58.470
getting them into this example. So I'm just
going to go ahead and dump them here. And

02:52:58.470 --> 02:53:02.690
then we can take a look at them. So this first
test is called the less than or equal operator.

02:53:02.690 --> 02:53:06.160
So it's going to check to see if number is
less than or equal to guess the second is

02:53:06.160 --> 02:53:10.070
the greater than or equal to operator. And
the third is the not equal operator. So if

02:53:10.070 --> 02:53:14.860
I go ahead and run this, you see that we are
less than or equal to because we're exactly

02:53:14.860 --> 02:53:19.500
on the number we are also greater than or
equal to, and we fail the non equal t test.

02:53:19.500 --> 02:53:25.200
So we get true true false printed here, if
we go with 30. Again, we're going to get false

02:53:25.200 --> 02:53:33.040
true true. And if we go with 70, we're going
to get true false true. So these are the six

02:53:33.040 --> 02:53:37.250
different comparison operators that you're
typically going to use in your applications.

02:53:37.250 --> 02:53:41.500
And these work with all numeric types. They
don't however, work with things like string

02:53:41.500 --> 02:53:44.540
types. So if you're going to work with string
types, typically what you're going to work

02:53:44.540 --> 02:53:49.160
with is the equality operator or the non equality
operator. And that goes for any kind of reference

02:53:49.160 --> 02:53:53.460
type as well. Now the next thing that I want
to do in this example is add in some kind

02:53:53.460 --> 02:53:57.920
of simple validation. So if you imagine that
we've got some kind of a simple user interface

02:53:57.920 --> 02:54:01.880
where the user is asked to enter a number
on the keyboard, and then we're going to use

02:54:01.880 --> 02:54:06.000
that as our guests, then we're going to need
some way to validate that number to make sure

02:54:06.000 --> 02:54:09.811
that for example, they don't enter negative
five. So to do that, we can add another logical

02:54:09.811 --> 02:54:16.380
test. But we can also combine multiple tests
together using what are called logical operators.

02:54:16.380 --> 02:54:21.300
So let me drop this code in here. And you
can see our first logical operator. So this

02:54:21.300 --> 02:54:26.870
code here is conducting two tests, it's checking
to see if the guest is less than one. Or if

02:54:26.870 --> 02:54:31.870
the guest is greater than 100. And if it is,
then we're going to print out a message here,

02:54:31.870 --> 02:54:37.920
we can also put a guard around our actual
game code, checking to see if the guess is

02:54:37.920 --> 02:54:43.130
greater than or equal to one. And this is
the AND operator less than or equal to 100.

02:54:43.130 --> 02:54:47.650
So this first test case is going to execute
if the guess is out of range. So if we enter

02:54:47.650 --> 02:54:52.180
negative five, for example, then we're going
to run this and we see that the guests must

02:54:52.180 --> 02:54:57.851
be within one and 100. If we enter a number
that's within range, then everything executes

02:54:57.851 --> 02:55:03.101
like we expect it to and this code on line
11,000 execute. So this first operator here

02:55:03.101 --> 02:55:07.891
is called the OR operator. And this is checking
to see if the test on the left is true, or

02:55:07.891 --> 02:55:11.811
the test on the right is true. So obviously,
we can't have the guest less than one and

02:55:11.811 --> 02:55:16.430
greater than 100 at the same time, but one
or the other could be true. And if one of

02:55:16.430 --> 02:55:20.251
those is true, then we're going to have an
invalid guess. And it makes sense to print

02:55:20.251 --> 02:55:24.340
out a message to the user saying that this
other operator that we see here is called

02:55:24.340 --> 02:55:29.061
the AND operator. And it evaluates to true
if both the test on the left and the test

02:55:29.061 --> 02:55:34.800
on the right evaluate to true. So if we had
a guest, for example of 105, then this code

02:55:34.800 --> 02:55:39.470
is gonna evaluate to true because it is greater
than or equal to one. But this code is not

02:55:39.470 --> 02:55:45.811
because 105 is not less than or equal to 100.
So with an and test, both cases have to be

02:55:45.811 --> 02:55:51.480
true, unlike an or test, we're only one of
the two has to be true. So a guess of 105

02:55:51.480 --> 02:55:55.351
is going to print out our error message. And
it is not going to execute the code within

02:55:55.351 --> 02:56:00.261
this if statement here. The other logical
operator that we have is called the NOT operator.

02:56:00.261 --> 02:56:02.750
And what that's going to do is it's going
to take a Boolean, and it's going to flip

02:56:02.750 --> 02:56:08.940
it to the other side. So if I take and just
as a simple example, if I take and print the

02:56:08.940 --> 02:56:12.490
value true out, then we're going to get the
value true printed out here at the end of

02:56:12.490 --> 02:56:18.021
our program. If I put the NOT operator, which
is just an exclamation point, and run that,

02:56:18.021 --> 02:56:22.820
then the true becomes false. Similarly, if
I put this in front of a false, the false

02:56:22.820 --> 02:56:26.440
becomes true. And I can just prove that false
is really false

02:56:26.440 --> 02:56:31.110
by taking that away, and false is false. So
those are the three logical operators that

02:56:31.110 --> 02:56:34.570
we have. We've got the OR operator, which
is the double pipe that you see here on line

02:56:34.570 --> 02:56:38.561
10. We've got the and operation which is the
double ampersand, which you see here on line

02:56:38.561 --> 02:56:43.650
13. And then we have the knot operation, which
reverses a Boolean result. And that's done

02:56:43.650 --> 02:56:48.090
simply using the exclamation point. The other
interesting thing to know about working with

02:56:48.090 --> 02:56:52.811
logical operators, is a concept called short
circuiting. So in order to show you that,

02:56:52.811 --> 02:56:56.840
I'm actually going to have to jump ahead and
add a custom function here. And we haven't

02:56:56.840 --> 02:57:01.561
talked about this. So let me just give you
a simple of an explanation as possible. So

02:57:01.561 --> 02:57:06.561
I've got a function down here between line
27 and 30, called return true, that's gonna

02:57:06.561 --> 02:57:10.730
return a Boolean result. Now in order to make
sure that we know that it executed, I'm printing

02:57:10.730 --> 02:57:15.650
out returning true here, and then I am returning
the true value. So what happens when we call

02:57:15.650 --> 02:57:20.301
this function is it's just going to be replaced
with the Boolean true in our application code.

02:57:20.301 --> 02:57:25.900
Now, up here in line 10, I've changed our
or test to include this return true. And this

02:57:25.900 --> 02:57:30.671
doesn't make sense in our demo example. But
I'm doing this just to show you how this works.

02:57:30.671 --> 02:57:35.061
So in this case, we're ordering three tests
together. So what's going to happen is go

02:57:35.061 --> 02:57:39.261
is going to evaluate these guys, it's going
to generate a result. And it's going to take

02:57:39.261 --> 02:57:43.700
that result, and it's going to order it against
this guy. So basically, it's going to evaluate

02:57:43.700 --> 02:57:47.511
all of them. And only one of those has to
be true in order to generate a validation

02:57:47.511 --> 02:57:51.521
message. So as you might expect, if we run
this like this, we're going to get returning

02:57:51.521 --> 02:57:56.030
true because the guest is not less than one.
So we're going to check this value, this returns

02:57:56.030 --> 02:58:00.561
true. And so we're going to evaluate if it's
greater than 100. None of those are truths

02:58:00.561 --> 02:58:04.670
or or statement fails. And then we're going
to drop down and we're going to execute this

02:58:04.670 --> 02:58:09.320
code down here. Like we might expect, if we
generate an invalid value. So if we put a

02:58:09.320 --> 02:58:14.610
negative five, then well, let's just run it
and we'll see what happens. So if we run this,

02:58:14.610 --> 02:58:19.900
we get the validation message. The guests
must be within one and 100. Well, that's okay.

02:58:19.900 --> 02:58:23.920
But what happened to our return true? If you
remember, this function is supposed to print

02:58:23.920 --> 02:58:28.700
returning true out, and it didn't. So what
happened? Well, what happened is a concept

02:58:28.700 --> 02:58:34.330
called short circuiting. So as soon as one
part of an or test returns true, then go doesn't

02:58:34.330 --> 02:58:38.511
need to execute any more code, it already
knows that the old test is going to pass.

02:58:38.511 --> 02:58:43.101
So it does what's called short circuiting,
which basically means it's not going to evaluate

02:58:43.101 --> 02:58:47.771
any other part of the or test, it's just going
to move on and say, well, the or test passed,

02:58:47.771 --> 02:58:52.980
and therefore everything works. So in this
case, since guess is less than one, there's

02:58:52.980 --> 02:58:59.210
no reason for go to evaluate these two tests
here. So since this test is a function call,

02:58:59.210 --> 02:59:04.080
it doesn't even execute that function. Now,
if we go the other way, and we go out of range

02:59:04.080 --> 02:59:09.301
high, then this is going to return false.
This is actually going to return true because

02:59:09.301 --> 02:59:12.920
it's hard coded. And actually go isn't even
going to evaluate this because this is going

02:59:12.920 --> 02:59:17.630
to return true. However, this value is going
to fail this test here. So if we run this,

02:59:17.630 --> 02:59:22.351
we see that now we get returning true printed
out. So this is a concept called short circuiting.

02:59:22.351 --> 02:59:26.900
Go is going to lazily evaluate the logical
tests that we put in here. So when we give

02:59:26.900 --> 02:59:31.630
it negative five, since it doesn't need to
evaluate anything after this first test, it

02:59:31.630 --> 02:59:35.940
doesn't. So any function executions are not
going to be evaluated. The same thing happens

02:59:35.940 --> 02:59:41.120
for an and test. If one of the parameters
returns false, then we're going to get a short

02:59:41.120 --> 02:59:45.521
circuiting here. So if we get into a situation
where this is false, go will not even evaluate

02:59:45.521 --> 02:59:49.820
this test here. So for example, with the negative
five, when Google evaluates this, it sees

02:59:49.820 --> 02:59:54.101
that the guest is not greater than or equal
to one. So the ant test has to fail because

02:59:54.101 --> 02:59:59.460
both sides of an ant test have to return true
in order to work and so go is going to exit

02:59:59.460 --> 03:00:03.440
early It's not going to execute this code.
So for the next thing that I want to talk

03:00:03.440 --> 03:00:07.320
about, I want to actually drop back into our
baseline for our test here. And I want to

03:00:07.320 --> 03:00:12.220
talk a little bit about these two if tests.
Now this code obviously works, but it's a

03:00:12.220 --> 03:00:17.160
little bit ugly, right? Because we have this
logic here, guess is less than one or guess

03:00:17.160 --> 03:00:22.671
is greater than 100. And then we have this
expression here. And this is exactly the opposite.

03:00:22.671 --> 03:00:27.340
So this is basically saying, Well, if it's
not less than one or greater than 100, then

03:00:27.340 --> 03:00:32.131
do this other thing. So while this code is
perfectly fine, it becomes a little bit of

03:00:32.131 --> 03:00:37.590
a maintenance nightmare, because really, our
intent is that we want to execute either this

03:00:37.590 --> 03:00:43.720
code or this code. So the way we can do that
a little bit more elegantly and go is by taking

03:00:43.720 --> 03:00:48.591
out all of this and just putting in the keyword
else. So what's going to happen in this situation

03:00:48.591 --> 03:00:54.710
is it's going to evaluate the logical tests.
If these tests return a Boolean true, then

03:00:54.710 --> 03:00:59.521
we're going to print this. Otherwise, we're
going to execute this block here. So in this

03:00:59.521 --> 03:01:04.681
case, if we run this, we see that we get the
value too low. And our logical tests down

03:01:04.681 --> 03:01:11.030
here in line 21. Execute. If we put in the
value negative five, however, then we get

03:01:11.030 --> 03:01:14.840
the same behavior that we had before. But
our code is a lot cleaner, and a lot more

03:01:14.840 --> 03:01:20.320
clear as to our intent. Now related to that
is the situation where we have multiple

03:01:20.320 --> 03:01:23.910
tests that we want to chain together. And
so let me paste in another permutation of

03:01:23.910 --> 03:01:29.291
our little game. And in this case, I've actually
split out the validation logic. So I want

03:01:29.291 --> 03:01:32.630
to check if it's less than one, I want to
print out one message, if it's greater than

03:01:32.630 --> 03:01:37.320
100, I want to print out another message.
Otherwise, I've got a valid value. And to

03:01:37.320 --> 03:01:42.330
do that, I'm using this else if clause. So
basically, what this is doing is it's taking

03:01:42.330 --> 03:01:47.791
an IF test, and then it's chaining on another
if test if this fails. And so what goes is

03:01:47.791 --> 03:01:52.880
going to do is the first logical test that
passes is going to be executed, otherwise,

03:01:52.880 --> 03:01:56.431
it's going to drop down to the else clause.
So with the guests of 30, we would expect

03:01:56.431 --> 03:02:01.521
our else clause to fire. So if we run, we
see that in fact it does. If we put in a value

03:02:01.521 --> 03:02:06.011
of negative five, then we would expect this
first statement to run and it does. And if

03:02:06.011 --> 03:02:10.470
we put in a value that's too high, then we
see that we get the second validation message

03:02:10.470 --> 03:02:15.170
printed out. And those are the three different
ways that we have to create if statements.

03:02:15.170 --> 03:02:19.010
So we've got the simple if statement, that's
just if and if that evaluates to true, then

03:02:19.010 --> 03:02:23.271
the statements inside of the curly braces
are going to execute. We've got if else. So

03:02:23.271 --> 03:02:27.440
we're either going to execute the first set
of code or the second set of code. And then

03:02:27.440 --> 03:02:32.580
we have the if elsif, which we can chain together
with else in order to have very complicated

03:02:32.580 --> 03:02:36.620
branching, so that we can have multiple code
paths execute, depending on how our logical

03:02:36.620 --> 03:02:41.390
tests execute. Now one thing to keep in mind
is through these examples, we've never been

03:02:41.390 --> 03:02:47.120
able to have more than one code path execute.
So even if we did something like this, if

03:02:47.120 --> 03:02:53.851
we did elsif guess is less than one or the
notice both the first test and the second

03:02:53.851 --> 03:02:59.250
test will pass with a value of negative five,
however, goes on and go to execute the first

03:02:59.250 --> 03:03:03.120
branch that has a succeeding test. So we get
the result, the guests must be greater than

03:03:03.120 --> 03:03:07.660
one because this test passed. And so this
test wasn't even evaluated, go immediately

03:03:07.660 --> 03:03:12.471
went in and executed this branch of code and
ignored all of the rest of our if statements.

03:03:12.471 --> 03:03:16.511
Now another thing to keep in mind when you're
working with equality operators, and this

03:03:16.511 --> 03:03:21.450
isn't specific to if checks, but it is something
that's easy to demonstrate with an F check.

03:03:21.450 --> 03:03:25.760
So if I take a look at this example, here,
I've got a floating point number of 0.1. And

03:03:25.760 --> 03:03:29.980
I'm going to check to see if that number is
equal to the number squared, and then I'm

03:03:29.980 --> 03:03:34.050
going to take the square root of it. So if
you get out of pencil and paper, you're going

03:03:34.050 --> 03:03:37.061
to take point one squared, which is going
to be point one, and then you're going to

03:03:37.061 --> 03:03:40.860
take the square root of that, which is going
to be back to point one, right? So this should

03:03:40.860 --> 03:03:48.040
evaluate to true. If we run this, we see that
in fact they are however, if I add in a couple

03:03:48.040 --> 03:03:54.090
of decimal places here and run this, now go
says the results are different. Well, the

03:03:54.090 --> 03:03:58.680
fact is that if you square a number and take
the square root of it, it is the same number.

03:03:58.680 --> 03:04:02.511
So what's going on here? Well, the thing is
go is working with floating point numbers

03:04:02.511 --> 03:04:07.620
and floating point numbers are approximations
of decimal values. They're not exact representations

03:04:07.620 --> 03:04:12.141
of decimal values. And so we have to be very
careful with them. When we're doing comparison

03:04:12.141 --> 03:04:17.870
operations with decimal values, this is generally
not a good idea, the better approach is to

03:04:17.870 --> 03:04:21.811
generate some kind of an error value and then
check to see if that error value is less than

03:04:21.811 --> 03:04:26.141
a certain threshold. So in this case, since
we're taking a floating point number and comparing

03:04:26.141 --> 03:04:31.730
it to a floating point number, what we can
actually do is divided two numbers and subtract

03:04:31.730 --> 03:04:36.280
one. And now what we have is a value that's
close to zero. So if we take the absolute

03:04:36.280 --> 03:04:43.320
value of that, so we'll use the ABS function,
which does that from the math package. And

03:04:43.320 --> 03:04:48.370
then check that to see if it's less than,
for example, point 001. What this is doing

03:04:48.370 --> 03:04:53.450
is saying divide these two numbers, and if
they're within a 10th of a percentage of each

03:04:53.450 --> 03:04:58.180
other, then we're going to consider them to
be the same. So if we run this, then you see

03:04:58.180 --> 03:05:02.390
that the results are the same and we We can
add as many decimal places as we want right

03:05:02.390 --> 03:05:06.400
now. And the errors that are associated with
floating point numbers aren't going to get

03:05:06.400 --> 03:05:10.410
in our way. Now, this isn't a perfect solution,
because you could get two numbers that aren't

03:05:10.410 --> 03:05:15.240
truly the same, and get them to pass this
test. So the key to that is tuning this error

03:05:15.240 --> 03:05:20.740
parameter here, making sure that it's sufficiently
small to catch those cases, but sufficiently

03:05:20.740 --> 03:05:24.820
large, so that the errors introduced with
floating point operations don't affect your

03:05:24.820 --> 03:05:28.841
results. Okay, so the next thing that I want
to talk about are switch statements. So let

03:05:28.841 --> 03:05:33.410
me start that conversation by dropping in
an example. And we'll see a basic switch statement.

03:05:33.410 --> 03:05:39.320
So a switch statement is a kind of special
purpose if statement. So where if statement

03:05:39.320 --> 03:05:43.521
has a logical test and runs a block of code
if that test is true, and then you can add

03:05:43.521 --> 03:05:48.141
an elsif to run a second test and another
elsif. And as many else ifs as you want. A

03:05:48.141 --> 03:05:51.860
lot of times in application development, we
run into a set of comparison operations that

03:05:51.860 --> 03:05:55.860
are very similar to one another. So a lot
of times it's more efficient to use a switch

03:05:55.860 --> 03:05:59.910
instead of an if statement. So we have a simple
example here, we're going to use this switch

03:05:59.910 --> 03:06:04.831
keyword as you might expect. And in this example,
we're going to start with this value here.

03:06:04.831 --> 03:06:08.400
And that's called a tag when we're working
with switch statements. So this is what we're

03:06:08.400 --> 03:06:12.740
going to compare everything against, then
we're going to have a series of cases. And

03:06:12.740 --> 03:06:16.021
you can see here we got case one, and we got
case two. So what's going

03:06:16.021 --> 03:06:22.450
to happen is the value here is going to be
compared to the tag. And if it's true, then

03:06:22.450 --> 03:06:26.490
the statements after the case are going to
execute. If not, then they're not going to

03:06:26.490 --> 03:06:30.650
execute. And just like with if statements,
the first case that passes is going to be

03:06:30.650 --> 03:06:35.920
the one that executes, we also have this default
case down here. And that's going to execute

03:06:35.920 --> 03:06:39.800
if none of our other test cases passed. So
if we go ahead and run this, we see that we

03:06:39.800 --> 03:06:44.311
get to print it out. If we add the value one
here, we get the value one printed out. And

03:06:44.311 --> 03:06:49.710
if we have three, then we get the default
case printed out. So it's a very simple way

03:06:49.710 --> 03:06:54.250
to compare one variable to multiple possible
values for that variable. Now in a lot of

03:06:54.250 --> 03:06:58.340
languages, if you want to compare against
a range, then you'd have to do something like

03:06:58.340 --> 03:07:03.021
this, you'd have case two, you'd have case
three. And then we use what's called falling

03:07:03.021 --> 03:07:07.700
through in order to compare multiple cases
together, well, we don't actually have falling

03:07:07.700 --> 03:07:13.000
through as a default behavior and go, but
what we do have to make up for that is the

03:07:13.000 --> 03:07:18.240
ability to have multiple tests in a single
case. So if I extend this example out here,

03:07:18.240 --> 03:07:22.730
and I say this is going to test one, five,
and 10. And this is going to test two, four,

03:07:22.730 --> 03:07:28.030
and six, then I'm going to say this is going
to print out one, five, or 10. And this will

03:07:28.030 --> 03:07:34.931
print two, four, or six, and then I put in
the value five, and let's just change this

03:07:34.931 --> 03:07:43.601
message to this is going to say another number.
Okay, so if I run this, then I get the first

03:07:43.601 --> 03:07:48.351
case is going to pass because I matched this
second test. So this is going to execute if

03:07:48.351 --> 03:07:53.921
I have the value one, five, or 10. So I can
also get into that same case by passing in

03:07:53.921 --> 03:07:58.640
the value of one, if I pass in the value of
four, then like you might expect, I'm gonna

03:07:58.640 --> 03:08:02.760
have the second case, evaluate. And naturally,
if I pass in an unknown number, then I'm going

03:08:02.760 --> 03:08:07.620
to have the default case execute, just like
I had before with a single test. Now one thing

03:08:07.620 --> 03:08:12.820
we have to be aware of is the test cases do
have to be unique. So if I try and run this,

03:08:12.820 --> 03:08:16.510
where I'm going to have five in the first
case, and in the second case, that's actually

03:08:16.510 --> 03:08:21.430
a syntax error, because you can't have overlapping
cases when you're using this syntax. Now,

03:08:21.430 --> 03:08:26.431
just like with if statements, we don't have
to have a simple tag here, in our switch,

03:08:26.431 --> 03:08:31.250
we can use an initializer, just like you're
seeing here. Now, in this case, the initializer

03:08:31.250 --> 03:08:35.070
doesn't have to generate a Boolean result,
because we're not doing a Boolean test in

03:08:35.070 --> 03:08:39.250
our switch statement up here, the Boolean
test is comparing the second parameter in

03:08:39.250 --> 03:08:43.220
the switch statement to our cases. So in this
case, we're just going to initialize that

03:08:43.220 --> 03:08:47.780
value. So I'm doing some simple math here,
I have set equal to two plus three. So obviously,

03:08:47.780 --> 03:08:50.851
that's going to be five, then I've got the
semi colon and the tag that we're going to

03:08:50.851 --> 03:08:55.490
be testing against. So as you might expect,
when I run this, the first case executes because

03:08:55.490 --> 03:09:00.791
two plus three is five, five is matched by
the first case. And so we get this statement

03:09:00.791 --> 03:09:05.480
printed out. Now another syntax that we have
available to us in switch statements is a

03:09:05.480 --> 03:09:09.841
tankless syntax. So both of the styles that
we've been talking about, we've always had

03:09:09.841 --> 03:09:14.370
a value that we're comparing to our test cases,
where there's actually another syntax, this

03:09:14.370 --> 03:09:19.230
tag list syntax. And this is arguably more
powerful than the tag syntax, although it

03:09:19.230 --> 03:09:23.471
is a little bit more verbose. So in this case,
on line eight, I'm establishing a variable

03:09:23.471 --> 03:09:27.380
which is going to come from some other logic
in my application. And then I've got the switch

03:09:27.380 --> 03:09:32.661
statement that standing all alone and immediately
opening a curly brace. So notice, I don't

03:09:32.661 --> 03:09:38.391
have a tag here. However, my case statements
now I've got full comparison operations. And

03:09:38.391 --> 03:09:42.460
I can use the comparison operators, I can
use the logical operators. So in this case,

03:09:42.460 --> 03:09:47.160
the cases are standing in for the logical
tests that we have in our if statements, they're

03:09:47.160 --> 03:09:51.220
doing exactly the same job. So in our first
case, I'm checking if i is less than or equal

03:09:51.220 --> 03:09:55.230
to 10. And if it is, I'm going to print that
out. And then in our second case, I'm going

03:09:55.230 --> 03:09:58.830
to check if i is less than or equal to 20.
And then of course, we've got the default

03:09:58.830 --> 03:10:04.830
case. If The value falls through. So if I
run this, I see that I do get the code executing,

03:10:04.830 --> 03:10:09.990
which is an interesting thing. And it executes
the first case. Now, why is this interesting?

03:10:09.990 --> 03:10:15.271
Well, if you notice the first case, in the
second case overlap, because 10 is less than

03:10:15.271 --> 03:10:20.380
or equal to 10. It's also less than or equal
to 20. So unlike the tag syntax, we've got

03:10:20.380 --> 03:10:25.820
multiple test cases. And I said they cannot
overlap. When we're using this tag list syntax,

03:10:25.820 --> 03:10:29.561
they are allowed to overlap. And if they do,
then the first case that evaluates to true

03:10:29.561 --> 03:10:33.670
is going to execute. Now another thing that
I should have pointed out earlier is notice

03:10:33.670 --> 03:10:38.320
that we don't have curly braces around this,
any statements that after this case, and before

03:10:38.320 --> 03:10:41.980
the next case is going to be part of the block
that's going to execute, so I can have as

03:10:41.980 --> 03:10:47.070
many statements as I want here. The delimiters,
in this case, are the actual case keywords,

03:10:47.070 --> 03:10:52.110
the default keyword, or the closing brace,
so any of those delimit the end of a block

03:10:52.110 --> 03:10:56.150
in a case statement. Now again, if you're
coming from another language, then this syntax

03:10:56.150 --> 03:11:00.171
might be looking a little weird, because you
might be looking for this word coming in here.

03:11:00.171 --> 03:11:04.170
And we'll have to add this word here. And
we'll have to have this word here.

03:11:04.170 --> 03:11:08.210
So you might be wondering where the heck are
my break keywords, one go, the break keyword

03:11:08.210 --> 03:11:14.790
is actually implied, because so many use cases
for switches have breaks in there. And forgetting

03:11:14.790 --> 03:11:19.650
a break is the cause of innumerable errors
when working with switch statements, the design

03:11:19.650 --> 03:11:24.290
decision was made to have an implicit break
between our cases, instead of an implicit

03:11:24.290 --> 03:11:30.670
fall through which most other c based languages
have. So what happens if you do in fact want

03:11:30.670 --> 03:11:35.210
your case to fall through. So in this example,
let's just say that we do want to print out

03:11:35.210 --> 03:11:39.301
that we're less than or equal to 10, and that
we're less than or equal to 20. And we know

03:11:39.301 --> 03:11:44.160
that if we pass this first case, we're going
to pass the second case to, in that case,

03:11:44.160 --> 03:11:50.761
we can actually use the keyword fall through.
So if I run this, you see that both messages

03:11:50.761 --> 03:11:54.540
print out. So I'm going to get less than or
equal to 10 and less than or equal to 20.

03:11:54.540 --> 03:12:00.390
Now one thing to keep in mind here is fall
through is logic less. So when we say fall

03:12:00.390 --> 03:12:05.540
through to the next case, it will do that.
So if I, for example, change this to be greater

03:12:05.540 --> 03:12:12.340
than or equal to, then we know that I fails
the second case, but if I run, it still executes,

03:12:12.340 --> 03:12:17.110
because fall through means that you are taking
the responsibility with the control flow.

03:12:17.110 --> 03:12:20.980
And you intentionally want the statements
in the next case to execute. Now and go you

03:12:20.980 --> 03:12:25.600
don't use follow through very often, because
we have that tag syntax that can take multiple

03:12:25.600 --> 03:12:31.170
tests per case. And so a lot of the use cases
for falling through are taking care of that.

03:12:31.170 --> 03:12:34.600
However, if you do have a use case where you
need follow through, then it is available

03:12:34.600 --> 03:12:38.221
to you. The next thing that I want to talk
about was switch statements are a special

03:12:38.221 --> 03:12:42.920
use of a switch statement called a type switch.
So I'm going to drop in this example here.

03:12:42.920 --> 03:12:47.590
And this should be pretty familiar except
for what we're switching on. So notice that

03:12:47.590 --> 03:12:52.811
we are switching on a tag. But the tag variable
is typed to type interface, which can take

03:12:52.811 --> 03:12:57.750
any type of data that we have in a go application.
So the interface type can be assigned to an

03:12:57.750 --> 03:13:02.590
integer like we're seeing here, we can assign
it to a string to a Boolean, to a function

03:13:02.590 --> 03:13:08.300
to a struct to a collection, anything we want
to assign to an interface is going to be permissible.

03:13:08.300 --> 03:13:13.570
So then in go, we can use this syntax here.
So we can put in the dot operator. And after

03:13:13.570 --> 03:13:17.250
that, put in params with the word type in
the middle. And what that's going to do is

03:13:17.250 --> 03:13:23.330
tell go to pull the actual underlying type
of that interface and use that for whatever

03:13:23.330 --> 03:13:27.990
we're doing next. Now, you don't just use
that for type switching. But this is a common

03:13:27.990 --> 03:13:32.490
use case for it. So in this case, I'm going
to assign the variable i the value one, which

03:13:32.490 --> 03:13:39.050
as we know is going to type I to be an integer.
And then I can actually use go types as the

03:13:39.050 --> 03:13:43.960
cases, because this is going to return a type,
then I can use those type keywords here as

03:13:43.960 --> 03:13:49.240
my cases. So if I run this, knowing that one
is an integer, I should not be surprised when

03:13:49.240 --> 03:13:53.490
I see the first case passes, and the other
two are ignored. If I had a decimal point

03:13:53.490 --> 03:13:58.160
zero here, then that's going to turn this
into a floating point 64. And we see that

03:13:58.160 --> 03:14:03.271
go recognizes that. Similarly, if I put one
in a string here, then we're going to see

03:14:03.271 --> 03:14:09.720
that go understand that. And I can even make,
for example, an array. And we don't need to

03:14:09.720 --> 03:14:15.000
initialize any values here. But if we see
that, then go recognizes that as another type.

03:14:15.000 --> 03:14:21.931
And if I want to have a case to catch that,
then I can actually have a case for a raise

03:14:21.931 --> 03:14:28.080
of three integers. And then I can print that
out. Now if I run, we see that it recognize

03:14:28.080 --> 03:14:34.670
that and this is different than two. So if
I use a two element array, please be aware

03:14:34.670 --> 03:14:38.221
that those are different types. Arrays are
not equivalent to every other array, you have

03:14:38.221 --> 03:14:42.271
to have the same data type and the same array
size in order for them to be evaluated as

03:14:42.271 --> 03:14:45.760
the same type. Okay, the last thing that I
want to talk about I can illustrate with this

03:14:45.760 --> 03:14:50.650
example here. Now in this example we're extending
on the previous one was type switches. And

03:14:50.650 --> 03:14:56.100
notice that I've got these two print statements
here on line 11 and line 12. So if I run this,

03:14:56.100 --> 03:15:01.840
I see that I is an integer and this will print
to it. In some situations, you might need

03:15:01.840 --> 03:15:06.421
to leave a case early. So maybe inside of
the case, you're executing some kind of a

03:15:06.421 --> 03:15:11.080
logical test, and you find out that there
is some logic in the case that you don't want

03:15:11.080 --> 03:15:15.311
to execute in certain situations. Well, if
you want to do that, you can actually exit

03:15:15.311 --> 03:15:19.761
out of the switch statement early by using
the break keyword. So if I add that and run,

03:15:19.761 --> 03:15:24.360
then I have a way to break out of the switch
early. And I'm not going to execute any code

03:15:24.360 --> 03:15:29.271
below that break statement. So you can wrap
this in a logical test to determine if you've

03:15:29.271 --> 03:15:33.140
got a validation error. For example, on some
incoming data, you might not want to save

03:15:33.140 --> 03:15:37.280
that data to the database. And then you can
use this break keyword in order to short circuit

03:15:37.280 --> 03:15:41.350
that save operation. Okay, so that pretty
much wraps up what I have to talk about with

03:15:41.350 --> 03:15:45.970
if and switch statements. Let's go into a
summary and review what we've talked about.

03:15:45.970 --> 03:15:50.021
In this video, we started our discussion about
the different control flow tools that we have

03:15:50.021 --> 03:15:51.021
available

03:15:51.021 --> 03:15:55.260
to us in our NGO applications. And we started
out by talking about the very basic if statements

03:15:55.260 --> 03:16:00.680
and how we can use a boolean variable to determine
if a block of statements will execute or not.

03:16:00.680 --> 03:16:05.740
We then talked about the initializer syntax,
and how that allows us to execute a statement,

03:16:05.740 --> 03:16:10.070
that's going to set up variables that we can
use to run our test against as well as use

03:16:10.070 --> 03:16:14.610
within the statements of our if tests. We
then talked about the comparison operators,

03:16:14.610 --> 03:16:18.641
and we talked about how there are six of them,
we've got less than, greater than, less than

03:16:18.641 --> 03:16:23.240
or equal to and greater than or equal to,
to work with primarily the numeric types,

03:16:23.240 --> 03:16:27.230
as well as the double equals operator and
the non equals operator that are available

03:16:27.230 --> 03:16:31.700
to be used more generally, we talked about
the logical operators, the AND operator, the

03:16:31.700 --> 03:16:36.771
OR operator and the non operator that allows
to chain together Boolean operations, as well

03:16:36.771 --> 03:16:41.720
as reverse the result of a Boolean operation.
In the case of that knot operator, we talked

03:16:41.720 --> 03:16:46.120
about short circuiting and how when you're
chaining together tests with an OR operation,

03:16:46.120 --> 03:16:51.650
for example, if any one of those logical tests
evaluates to true, then the remaining tests

03:16:51.650 --> 03:16:56.400
are not executed. So any side effects or any
functional operations that might occur with

03:16:56.400 --> 03:17:02.230
those are not going to be executed. Similarly,
with an an test, the first part of an ad test

03:17:02.230 --> 03:17:06.870
to return a false result is going to halt
the execution of that and test. So any side

03:17:06.870 --> 03:17:11.771
effects you might be relying on afterward
are not going to occur. We then talked about

03:17:11.771 --> 03:17:16.510
the two different variants of if tests, we
talked about the FL statement, and how we

03:17:16.510 --> 03:17:22.260
can use that to execute one of two branches
of code. So if the if test succeeds, then

03:17:22.260 --> 03:17:26.040
we're going to execute the first block of
statements. Otherwise, we're going to execute

03:17:26.040 --> 03:17:30.940
the second block of statements. Related to
that is the if else if statement. And in this

03:17:30.940 --> 03:17:35.320
case, instead of determining between one of
two paths, and forcing your code to execute

03:17:35.320 --> 03:17:41.811
one of those, you can add additional logical
tests. So at most one block is going to execute.

03:17:41.811 --> 03:17:46.811
But if all of your F tests fail, then you
might not get any blocks executing. And finally,

03:17:46.811 --> 03:17:51.680
I took a minute to talk about equality operations,
especially when working with floating point

03:17:51.680 --> 03:17:56.630
numbers. And how equality and floats don't
really get along that well. So if you do need

03:17:56.630 --> 03:18:00.160
to do some kind of inequality operation with
floating point numbers, then you're going

03:18:00.160 --> 03:18:05.141
to want to turn that into some kind of a comparison
operation against an error function. So for

03:18:05.141 --> 03:18:09.340
example, we were checking to see if two floats
were equal, instead of checking to see if

03:18:09.340 --> 03:18:14.240
they're actually equal, and we divided them
subtracted one from that result, and check

03:18:14.240 --> 03:18:19.391
that against an error parameter. So we decided,
if they were within a 10th of a percent, they

03:18:19.391 --> 03:18:22.851
were going to be considered the same, you
can use a similar type of error function with

03:18:22.851 --> 03:18:27.690
your operations. But in general, you should
not test to see if two floating point numbers

03:18:27.690 --> 03:18:31.870
are equivalent to one another. We then moved
on to talk about switch statements, and the

03:18:31.870 --> 03:18:35.250
various ways that we can use those in our
applications. We started by talking about

03:18:35.250 --> 03:18:40.390
how to switch on a tag or tag is just another
name for a variable. But that variable has

03:18:40.390 --> 03:18:45.110
a special significance in a switch statement,
because all of your test cases are going to

03:18:45.110 --> 03:18:50.051
be compared back to that tag. We talked about
how with go we can have multiple tests with

03:18:50.051 --> 03:18:54.420
our case statements. And by doing that, we
can actually eliminate a lot of situations

03:18:54.420 --> 03:18:59.000
in other languages where we need to fall through
and chain multiple cases together. Well in

03:18:59.000 --> 03:19:03.890
go, we can just add those multiple tests in
the same case, and eliminate the need to do

03:19:03.890 --> 03:19:08.730
that following through. We also do have initializers
available with switch statements. But instead

03:19:08.730 --> 03:19:13.790
of the initializer, generally generating a
Boolean as we do with an if statement, the

03:19:13.790 --> 03:19:17.260
initializer is going to generate the tag that's
going to be used for the comparisons. In our

03:19:17.260 --> 03:19:21.801
cases, we talked about switches with no tags
and how it adds a lot of flexibility to the

03:19:21.801 --> 03:19:26.561
switch statement. But it is a little bit more
verbose syntax. So instead of the cases being

03:19:26.561 --> 03:19:31.460
compared for equivalency with the tag, we're
going to actually put in the comparison operation

03:19:31.460 --> 03:19:36.540
ourselves. So we can use more than just equivalency
testing we can check less than or equal to,

03:19:36.540 --> 03:19:41.730
or any other comparison function, including
chaining comparisons together by using logical

03:19:41.730 --> 03:19:45.870
operators. We talked about how we have the
fall through keyword available in switches,

03:19:45.870 --> 03:19:50.480
and how that replaces the break keyword in
many languages. So where many languages have

03:19:50.480 --> 03:19:56.690
implicit fall through an explicit breaking
in go we flip it around so we have implicit

03:19:56.690 --> 03:20:00.830
breaks. But if you do need one case to fall
through to the next Then you can use this

03:20:00.830 --> 03:20:05.370
fall through keyword. Now one thing to keep
in mind when you're doing that is when you're

03:20:05.370 --> 03:20:10.480
falling through, any additional case logic
is not executed, the fall through will override

03:20:10.480 --> 03:20:15.860
any case logic that you have. And so the next
statement will execute regardless of if that

03:20:15.860 --> 03:20:21.140
case would normally pass or not. We also talked
about type switches, and how we can use that

03:20:21.140 --> 03:20:27.320
special syntax by adding a dot perenne type
perenne on an empty interface in order to

03:20:27.320 --> 03:20:32.110
get the underlying type of that empty interface.
So for example, if we've got an empty interface

03:20:32.110 --> 03:20:35.950
that's holding an integer, then we can use
that syntax in order to get that underlying

03:20:35.950 --> 03:20:41.110
integer value. Then in our switches, we can
switch against those types. And then we can

03:20:41.110 --> 03:20:45.021
make a decision based on the data that we
got in. And finally, we talked about breaking

03:20:45.021 --> 03:20:50.300
out early, when we've passed into a case in
our switch statement. There are times when,

03:20:50.300 --> 03:20:54.170
in the middle of the case, we need to exit
out early, because we've done some additional

03:20:54.170 --> 03:20:59.380
analysis. And we've decided that we should
not proceed executing this case. So for example,

03:20:59.380 --> 03:21:03.610
we've got a switch statement. And inside of
that case, we're doing some validation on

03:21:03.610 --> 03:21:07.801
the data before we save it to the database,
we might decide that data is invalid, and

03:21:07.801 --> 03:21:12.350
we should not proceed to save it to the database.
So in that case, you can use the break keyword

03:21:12.350 --> 03:21:17.360
break out of the case and continue execution
after the switch statement, I want to continue

03:21:17.360 --> 03:21:21.050
our discussion of the control flow structures
that we have available in the go language

03:21:21.050 --> 03:21:26.570
by talking about looping. Now in the last
video, we talked about the two ways that we

03:21:26.570 --> 03:21:31.030
have to introduce branching logic into our
application if statements and switch statements.

03:21:31.030 --> 03:21:34.790
Well, when we talk about looping and go, things
are actually going to be a little bit simpler,

03:21:34.790 --> 03:21:38.460
because we only have one type of statement
that we're going to have to learn. And that

03:21:38.460 --> 03:21:42.080
statement is the for statement. Now we're
basically going to break this conversation

03:21:42.080 --> 03:21:46.230
down into three different parts, we're going
to talk about simple loops, we're going to

03:21:46.230 --> 03:21:49.551
talk about how we can exit a loop early. And
then we're going to talk about how we can

03:21:49.551 --> 03:21:54.140
loop through collections. Okay, so let's go
ahead and get started by learning how to do

03:21:54.140 --> 03:21:56.850
some simple loops in go.

03:21:56.850 --> 03:22:00.790
So in order to start our discussion about
looping and go, I want to start with this

03:22:00.790 --> 03:22:05.041
perhaps the most basic for loop that we can
create. So we're going to start with the for

03:22:05.041 --> 03:22:09.820
keyword as you might expect. And then we're
going to follow the for keyword with three

03:22:09.820 --> 03:22:13.910
statements, the first statement is going to
be an initializer. Now this is the same as

03:22:13.910 --> 03:22:18.500
an initializer. And if statements and switch
statements. So we can add any kind of statement

03:22:18.500 --> 03:22:22.450
that we want here. And normally, we're going
to use that in order to set up a counter,

03:22:22.450 --> 03:22:26.610
when we're using a for loop like this, the
next statement that we have here is going

03:22:26.610 --> 03:22:30.811
to be some kind of a statement that generates
a Boolean result. And that's going to be used

03:22:30.811 --> 03:22:35.061
by the for loop to determine if it's done
looping or not. And then the last statement

03:22:35.061 --> 03:22:38.680
is going to be the incrementer. And normally,
we're going to use that in a situation like

03:22:38.680 --> 03:22:43.540
this to increment a counter variable. So if
we run this, we see that we get the numbers

03:22:43.540 --> 03:22:49.030
zero through four printed out, we could also
increment i by two. And there, you see that

03:22:49.030 --> 03:22:53.110
we only get three iterations of the loop,
because I has the value zero, then it has

03:22:53.110 --> 03:22:57.641
the value two, and then it has the value four,
when it comes to the next time it has the

03:22:57.641 --> 03:23:02.811
value of six, well, six is not less than five.
Therefore the comparison operation results

03:23:02.811 --> 03:23:07.490
to false and we exit out of the loop. So this
is certainly possible to do and you will occasionally

03:23:07.490 --> 03:23:11.730
see this. But the most standard way that you
see these loops created is like this using

03:23:11.730 --> 03:23:15.580
an increment statement. Now if you're coming
from another language, you might be expecting

03:23:15.580 --> 03:23:20.850
to be able to do something like this. So maybe
we want to variables, increment in our for

03:23:20.850 --> 03:23:25.690
loop. And so we're going to initialize j there.
And then we're going to increment j with each

03:23:25.690 --> 03:23:30.351
loop. So if we go ahead and try and run this,
we see that that's actually not allowed, because

03:23:30.351 --> 03:23:34.100
we have no comma operator in the go language.
So you can't separate two statements like

03:23:34.100 --> 03:23:40.200
this using the comma. So this is an error,
and this is an error. So if we want to do

03:23:40.200 --> 03:23:45.230
that, though, we can use gos ability to initialize
multiple values at the same time by adding

03:23:45.230 --> 03:23:50.870
a comma here getting rid of this part here,
adding the comma there. And then we can't

03:23:50.870 --> 03:23:54.910
treat these as individual statements, because
you can only have one statement here. And

03:23:54.910 --> 03:23:59.641
in go the increment operation is a statement,
it's not an expression. So we need to figure

03:23:59.641 --> 03:24:05.690
out a way to do both of these at one time.
So we will simply come in and said I n j equal

03:24:05.690 --> 03:24:12.800
to i plus one and j plus one. And go ahead
and run that. And now we have I printing out

03:24:12.800 --> 03:24:18.240
if we have j here we see that j printout as
well, we can actually increment j by two here.

03:24:18.240 --> 03:24:22.630
And we see that i and j are incrementing independently.
And we have no problems here. Now just to

03:24:22.630 --> 03:24:27.080
come back and revisit that increment comment
that I made earlier, you might be tempted

03:24:27.080 --> 03:24:31.511
to do something like this, if you just want
to increment them by one. If we run that,

03:24:31.511 --> 03:24:36.000
we're actually going to get an error because
again, in go unlike a lot of languages, the

03:24:36.000 --> 03:24:40.290
increment operation is not an expression.
So we can't use that as part of a statement.

03:24:40.290 --> 03:24:45.510
It is a statement on its own. So when you're
just incrementing one variable, you can certainly

03:24:45.510 --> 03:24:49.960
do this because i plus plus is a statement,
but we can't use that in combination with

03:24:49.960 --> 03:24:54.510
anything else. We can't use it as an expression.
Something else that's interesting. Let me

03:24:54.510 --> 03:25:00.140
go back to our initial example here. So we
can play around with this a little bit. So

03:25:00.140 --> 03:25:04.260
at first blush, if you just come into programming,
this AI variable might seem like it's something

03:25:04.260 --> 03:25:08.771
special because it's used up in the for loop.
And the fact is, it's a variable just like

03:25:08.771 --> 03:25:12.700
anything else. So we can do whatever we want
with it. As a matter of fact, just to show

03:25:12.700 --> 03:25:17.021
you that, let me drop in this cool little
bit of code. As you can see, what we're going

03:25:17.021 --> 03:25:21.540
to do here is we're going to take the modulus
of i n two, and we're going to see if that

03:25:21.540 --> 03:25:25.720
zero, so basically, we're checking to see
if it has an even number or an odd number.

03:25:25.720 --> 03:25:30.210
If I is an odd number, then we're going to
divide it by two. If I is an even number,

03:25:30.210 --> 03:25:33.370
then we're going to multiply it by two and
add one to it, it's just a couple things to

03:25:33.370 --> 03:25:36.690
play around with the incrementer. So let's
run this and see if this actually goes to

03:25:36.690 --> 03:25:40.880
completion. And in fact, it does. And you
see that the variables going all over the

03:25:40.880 --> 03:25:47.480
place. So we start with zero zeros on so divide
that by two, which stays zero, the next iteration

03:25:47.480 --> 03:25:51.700
is going to be one because we're incrementing
by one, so it's actually going to be multiplied

03:25:51.700 --> 03:25:56.900
by two and one added to it. So we print the
one here. But then by the time we're done

03:25:56.900 --> 03:26:03.460
here, two times one plus one is three, and
so is three, that gets incremented to four,

03:26:03.460 --> 03:26:08.620
so we're printing for four out here, four
is even to divide that by two, two gets incremented

03:26:08.620 --> 03:26:14.650
again, so we print out the value three, three
is odd. So three times two is six plus one

03:26:14.650 --> 03:26:19.850
is seven, seven is greater than five. And
so we leave the comparison operation, so we

03:26:19.850 --> 03:26:23.690
can do whatever we want with the counter.
Now, just because you can play with the counter

03:26:23.690 --> 03:26:27.180
doesn't mean it's a good idea. As a matter
of fact, normally, it's very bad practice

03:26:27.180 --> 03:26:30.820
to manipulate the counter within the for loop.
So maybe the best reason to show you that

03:26:30.820 --> 03:26:34.670
you can do this is to make sure that you avoid
doing this because there can be times when

03:26:34.670 --> 03:26:38.340
you're inadvertently changing the counter
variable within a loop. And your loops might

03:26:38.340 --> 03:26:42.370
start to act really strange, like we're seeing
in this example here. Okay, so let's go ahead

03:26:42.370 --> 03:26:46.090
and restore our original example, make sure
that that's running again, and it is we're

03:26:46.090 --> 03:26:49.801
printing out the values zero through four
again. Now the next thing that I want to show

03:26:49.801 --> 03:26:54.120
you is that we don't actually need all three
statements here. So one thing that we could

03:26:54.120 --> 03:26:59.561
do, let's just say that I is initialized somewhere
else in our application, so we don't need

03:26:59.561 --> 03:27:05.330
it to be set up here. And we can run with
this first statement being empty. Now you

03:27:05.330 --> 03:27:09.040
can't leave this for a semi colon out, because
if you leave that out, then everything's in

03:27:09.040 --> 03:27:12.511
the wrong place. And it thinks that this is
going to be the initializer. And this is going

03:27:12.511 --> 03:27:17.700
to be the comparison operator. So if we try
and run this way, we're going to get an error.

03:27:17.700 --> 03:27:21.840
But if we leave the semicolon in, then go
recognizes that we simply don't have an initializer

03:27:21.840 --> 03:27:25.950
in this for loop. And it executes everything
the way that we expect it to. And of course

03:27:25.950 --> 03:27:30.630
I've variable ri is taken in just like we
would expect. Now the difference between this

03:27:30.630 --> 03:27:37.101
format and the previous one is in this i is
scoped to the main function. But when we have

03:27:37.101 --> 03:27:44.511
this syntax here, I is scoped to the for loop.
So if I tried to print the value of i out

03:27:44.511 --> 03:27:49.271
here, we're not going to get a valid value
because I is not defined. But in this other

03:27:49.271 --> 03:27:54.480
form, when we're putting it out here, then
I is scoped to the main function. And we are

03:27:54.480 --> 03:27:58.521
actually going to get the final value of I
printed out which is the value five, because

03:27:58.521 --> 03:28:03.970
five is the first value that fails this test.
So this is actually coming from this statement

03:28:03.970 --> 03:28:08.221
right here. Okay, the next thing that we can
do, let me go ahead and wipe this out, we

03:28:08.221 --> 03:28:12.900
also don't need the incrementer value, so
we can eliminate that. Now if I run this right,

03:28:12.900 --> 03:28:16.181
now, we're actually going to get an error,
because what this is going to do is it's going

03:28:16.181 --> 03:28:20.220
to generate an infinite loop. And in the go
playground, they don't let us do infinite

03:28:20.220 --> 03:28:24.000
loops. And so after it runs for a little bit
of time, it's going to shut the process down

03:28:24.000 --> 03:28:27.790
on us. If we were actually running this in
a local environment, all you'd see is the

03:28:27.790 --> 03:28:32.061
value zero printed out over and over and over
and over again, until eventually you got bored

03:28:32.061 --> 03:28:37.690
and shut the application down. Now we can
of course, since I is a variable just like

03:28:37.690 --> 03:28:43.290
any other, we can put the incrementer in here,
and everything works just fine. So once again,

03:28:43.290 --> 03:28:47.640
we have to remember to put the semicolon here,
if we remove the semi colon, then go doesn't

03:28:47.640 --> 03:28:51.341
know what the heck we're asking it to do,
because this is invalid syntax. So if you

03:28:51.341 --> 03:28:56.250
have the first semicolon, you need the second
semi colon. Now this case does happen actually

03:28:56.250 --> 03:29:00.320
quite a bit where we need a for loop and just
a comparison operation. And this is how go

03:29:00.320 --> 03:29:04.980
does do while loops. So in a lot of languages,
you have two more keywords, you've got the

03:29:04.980 --> 03:29:09.500
do keyword and the wild keyword. And normally
those work with simply a logical test. And

03:29:09.500 --> 03:29:13.080
then you have some other increment operations.
So you either have an increment or inside

03:29:13.080 --> 03:29:17.890
of the loop, or you're pulling the next value
off the stack. And comparing that on each

03:29:17.890 --> 03:29:22.761
iteration, or something like that, we'll go
has the same problems to solve, but didn't

03:29:22.761 --> 03:29:26.540
make sense for the designers of the language
to introduce a new keyword just for what is

03:29:26.540 --> 03:29:31.351
basically a special case of a for loop. So
what they allow us to do is we of course can

03:29:31.351 --> 03:29:37.250
use this double semi colon syntax here. But
you can also leave them both off. So if I

03:29:37.250 --> 03:29:41.690
run this way, we see that this works. And
this is going to work exactly the same way

03:29:41.690 --> 03:29:46.940
as if we have both of these semicolons here.
So this is a little bit of syntactic sugar.

03:29:46.940 --> 03:29:51.271
It's exactly the same construct. It's just
you don't need to have the additional semi-colons

03:29:51.271 --> 03:29:56.610
and it reads a little bit cleaner. So in this
case, our for loop is just doing a comparison

03:29:56.610 --> 03:30:00.870
operation. Go is going to assume that we're
taking care of where those variables for the

03:30:00.870 --> 03:30:05.340
comparison are coming from somewhere else.
Now the third form of a for loop that we have

03:30:05.340 --> 03:30:09.891
available when we're working with counters
like this is the infinite for loop. Because

03:30:09.891 --> 03:30:14.521
we also have a situation with do while loops
in other languages, where we need the application

03:30:14.521 --> 03:30:20.021
to run through the loop and undetermined number
of times. And by undetermined means, we don't

03:30:20.021 --> 03:30:25.141
actually know when to stop by an obvious logical
test, we need some complex logic within the

03:30:25.141 --> 03:30:29.561
loop in order to determine when to leave.
So in go, the way that we do that is we simply

03:30:29.561 --> 03:30:33.790
leave off the logical test, and we run like
this. So if I run this, again, as you might

03:30:33.790 --> 03:30:37.470
expect, the playground is going to crash out
on us because there's no way for the program

03:30:37.470 --> 03:30:42.190
to exit. And so it's just going to run forever.
So we need some way to tell our infinite loop

03:30:42.190 --> 03:30:46.271
when it's done processing and when to leave.
And the way we're going to do that is using

03:30:46.271 --> 03:30:50.580
the break keyword. And then Normally, the
way that you do this is you'll put some kind

03:30:50.580 --> 03:30:56.490
of logical tests inside of the loop. So we
can say, if I equals five, then we're going

03:30:56.490 --> 03:30:59.720
to use that break keyword. And we saw the
break keyword, the first time when we were

03:30:59.720 --> 03:31:03.630
talking about switch statements, or the break
keyword is actually more commonly used inside

03:31:03.630 --> 03:31:08.021
of for loops, especially this kind of infinite
for loop here. So what we're doing here is

03:31:08.021 --> 03:31:13.011
if i is equal to five, so we're going to print
out the values, zero through four, then when

03:31:13.011 --> 03:31:16.930
I was fine, we're gonna break out. So if we
go ahead and run this, we get exactly the

03:31:16.930 --> 03:31:21.880
same values that we had before. Now when we
do this, we actually leave the entire for

03:31:21.880 --> 03:31:26.480
loop. So execution of the loop stops, and
we're done processing. Now another thing that

03:31:26.480 --> 03:31:31.501
we can do is use what's called a continue
statement. So let me drop in an example that

03:31:31.501 --> 03:31:35.870
shows you that. So in this case, we're looping
from zero to nine, because we're going to

03:31:35.870 --> 03:31:39.290
keep incrementing as long as i is less than
10. And then we're checking to see if the

03:31:39.290 --> 03:31:43.460
value is even if it is even, then we're going
to use this continuous statement here. And

03:31:43.460 --> 03:31:48.590
what this does is it basically says, exit
this iteration of the loop and start back

03:31:48.590 --> 03:31:54.820
over. So what's going to happen when we have
00 modulates to is zero, so we're going to

03:31:54.820 --> 03:31:59.760
continue, which means we're not going to hit
this print statement, when we have one, one

03:31:59.760 --> 03:32:03.141
minus two is one, so we're not going to hit
this continue, and we're going to print out

03:32:03.141 --> 03:32:07.170
one, and then two is going to hit the continue
and three is not. So what we should see is

03:32:07.170 --> 03:32:11.820
we'll only print the odd numbers out. If we
run this, we see that that is in fact what

03:32:11.820 --> 03:32:16.391
happens. So continuous statements aren't used
very often. But they can be very, very useful.

03:32:16.391 --> 03:32:20.370
If you're looping through a large set of numbers,
and you need to determine within the loop

03:32:20.370 --> 03:32:24.530
whether you want to process a record or not.
Now, to show you the next thing, I'm actually

03:32:24.530 --> 03:32:28.840
going to do this, this is actually going to
print out a nested loop. So what we're doing

03:32:28.840 --> 03:32:33.350
here is a pretty simple example, we're starting
with the variable, I initializing it to one,

03:32:33.350 --> 03:32:37.510
and we're going to run as long as i is less
than or equal to three, and then we're doing

03:32:37.510 --> 03:32:41.850
the same thing with J on the inside. So basically
is going to be one, then it's going to loop

03:32:41.850 --> 03:32:46.601
through days from one to three, then is going
to be two, it's going to loop through j 4123.

03:32:46.601 --> 03:32:50.771
Again, and then inside this inner loop, we're
just multiplying the two numbers together.

03:32:50.771 --> 03:32:54.921
So if we run this, we see that we get all
of the permutations of i times j, where i

03:32:54.921 --> 03:32:59.930
and j go from the values 123. So we get all
of these values printed out, and everything

03:32:59.930 --> 03:33:05.021
works the way that we expect. Now what happens
if we want to leave the loop, as soon as we

03:33:05.021 --> 03:33:08.990
get the first value that's greater than three.
So what we want to do is something like this,

03:33:08.990 --> 03:33:12.521
so we're going to multiply it times j, we're
going to repeat our logic here. And we're

03:33:12.521 --> 03:33:16.351
going to see if that's greater than or equal
to three, if it is, then we're going to break

03:33:16.351 --> 03:33:21.680
out of the loop. Now if I run this, we don't
exactly get the expected result. And the reason

03:33:21.680 --> 03:33:27.040
for that is as soon as i times j is greater
than three, it breaks out of the loop, but

03:33:27.040 --> 03:33:31.360
the loop that is going to break out of is
the closest loop that it can find. So it's

03:33:31.360 --> 03:33:36.080
actually breaking out of this loop here. And
this loop just restarts because there's nothing

03:33:36.080 --> 03:33:39.940
to tell it to stop. So you might ask the question,
Well, how do we break out in the outer loop?

03:33:39.940 --> 03:33:44.510
Do we have to have more logic here and check
to see if i times j is greater than three

03:33:44.510 --> 03:33:48.930
again, and then break out? Well, the answer
is, of course, now, we do have a concept called

03:33:48.930 --> 03:33:52.491
a label that we can add. So a label is put
together something like this, we're going

03:33:52.491 --> 03:33:56.900
to start with a word and follow it with a
colon. And we're going to left justify that

03:33:56.900 --> 03:34:01.710
in our code blocks. So once I have a label
defined, I can actually add the label after

03:34:01.710 --> 03:34:06.790
the break keyword. And it basically describes
where we want to break out to. So since this

03:34:06.790 --> 03:34:10.780
labels just before this for loop, we're going
to break out of the outer for loop. So if

03:34:10.780 --> 03:34:15.820
I run now, I get to the value three, three
is greater than or equal to three. And so

03:34:15.820 --> 03:34:20.261
I break out of both the inner and the outer
loop. The last thing that I want to talk about

03:34:20.261 --> 03:34:25.250
in this video is how we can work with collections
with for loops. So we've seen this before

03:34:25.250 --> 03:34:28.530
we have a slice of integers. In this case,
we're containing the values one, two, and

03:34:28.530 --> 03:34:33.200
three. And we've seen how we can work with
this as a slice so we can print this out.

03:34:33.200 --> 03:34:38.000
We run this we get no big surprise, we get
the slice printed out with the values 123.

03:34:38.000 --> 03:34:42.130
But what happens if I wanted to work with
each individual value? Well, we've seen how

03:34:42.130 --> 03:34:47.420
we can do this, we can pull out one value
from the slice, and we get the value two.

03:34:47.420 --> 03:34:52.230
But how do we work with an arbitrarily sized
slice. So I don't know how big this slice

03:34:52.230 --> 03:34:56.980
is going to be at runtime. I want to be able
to loop through all the items within the slice.

03:34:56.980 --> 03:35:00.380
So the way that I'm going to loop through
a collection is using a special format The

03:35:00.380 --> 03:35:04.320
for loop called a four range loop. So I'm
going to start that with the four keyword

03:35:04.320 --> 03:35:09.721
as you might expect. And then what I'm going
to get is both the key and the value for the

03:35:09.721 --> 03:35:14.450
current item in the collection. So I'm going
to have two variables that I can set there.

03:35:14.450 --> 03:35:19.230
And then I'm going to set that equal to this
special range keyword and then provide the

03:35:19.230 --> 03:35:23.561
collection that I'm going to range over. So
what this is going to do is it's going to

03:35:23.561 --> 03:35:28.130
look at the collection here. And it's going
to take each value one at a time, give us

03:35:28.130 --> 03:35:31.950
the key and the value, and then we're going
to be able to work with those values independently.

03:35:31.950 --> 03:35:37.150
So inside of this, let's go ahead and just
print out the value of the key and the value

03:35:37.150 --> 03:35:41.740
and run that. And you see that we get the
indexes for the items in the slice, and we

03:35:41.740 --> 03:35:46.440
get their values. So the indexes are coming
first, those are the keys. And then the values

03:35:46.440 --> 03:35:51.300
are the actual values in the slice. And this
is the only syntax, you have to remember when

03:35:51.300 --> 03:35:56.170
using the range keyword, you're always going
to get this key comma value result coming

03:35:56.170 --> 03:36:01.170
out. So this syntax is going to work for slices
and for arrays. So if we make this an array

03:36:01.170 --> 03:36:06.061
by just adding a size, here, we see that we
get the exact same output, we can loop over

03:36:06.061 --> 03:36:10.570
maps. So if I pull back the state populations
map that we use for a couple of videos now,

03:36:10.570 --> 03:36:14.410
and loop over that, once again, pulling up
the key and the value and ranging over the

03:36:14.410 --> 03:36:18.500
map this time, then if I print the key and
the value, I'm going to be able to split that

03:36:18.500 --> 03:36:22.521
out and then get the state in their population
printed out separately. And I can even use

03:36:22.521 --> 03:36:26.521
a string as a source for a four range loop.
Because what we're going to be able to do

03:36:26.521 --> 03:36:31.811
here is pull each letter out of this string
as a character and look at that. And we see

03:36:31.811 --> 03:36:36.670
that we do get each position. And now we get
this numeric value, which if you've been paying

03:36:36.670 --> 03:36:40.190
attention over the last few videos, you're
going to remember that this is actually the

03:36:40.190 --> 03:36:44.910
Unicode representation for that digit. So
we can cast it back to a string by just using

03:36:44.910 --> 03:36:48.930
a simple conversion operation. And we see
that we get each letter printed back out as

03:36:48.930 --> 03:36:53.570
we would expect. The other type of data that
we can arrange over in go is what's called

03:36:53.570 --> 03:36:57.750
a channel. Now channels are used for concurrent
programming and go and that's a topic for

03:36:57.750 --> 03:37:02.351
a future video. So I'm going to leave that
topic right now, I promise when we talk about

03:37:02.351 --> 03:37:06.740
parallelism and concurrency and go, I'll revisit
the for loop and show you how you can use

03:37:06.740 --> 03:37:10.021
for loops with channels, because there are
some special behaviors that you have to be

03:37:10.021 --> 03:37:14.740
aware of when you're ranging over channels.
Now, if I come back to this example, and print

03:37:14.740 --> 03:37:19.710
this out, you see that we have access to both
the key and the value every time. Now, this

03:37:19.710 --> 03:37:23.681
is not always true, you don't always need
access to the value. And this can lead to

03:37:23.681 --> 03:37:27.900
some problems. Because if I only want to print
the keys out and run this, this is actually

03:37:27.900 --> 03:37:32.550
an error, because in go, you have to use every
variable that's declared. And so we got this

03:37:32.550 --> 03:37:36.200
situation where we've got this variable v,
but we're not using it. And so that's going

03:37:36.200 --> 03:37:40.391
to cause us a problem with our application.
Now and go what you can do, if you only want

03:37:40.391 --> 03:37:45.280
to get the keys out, you can actually skipped
the comma value. And when you run that, it's

03:37:45.280 --> 03:37:49.330
going to ignore the value. But what happens
if you get into a situation where you only

03:37:49.330 --> 03:37:53.271
want to print the value out. So if I restore
this, and I want to want to print the value,

03:37:53.271 --> 03:37:58.740
of course, I get the same error. But I can't
just say this, because go who's going to assign

03:37:58.740 --> 03:38:03.950
the keys to that. So what do I do? Well, in
this situation, when you only want the values,

03:38:03.950 --> 03:38:07.851
then you can use that underscore operator
that write only variable that we've seen a

03:38:07.851 --> 03:38:11.390
couple of times. And basically, that's going
to give a hint to the compiler that we don't

03:38:11.390 --> 03:38:15.980
actually care about the key. But we need this
in this first position in order to get the

03:38:15.980 --> 03:38:20.660
value. So when we run this, we do see that
we get those populations printed out. Okay,

03:38:20.660 --> 03:38:24.330
so that covers what I want to talk about with
four statements and go, let's go into summary

03:38:24.330 --> 03:38:29.851
and review what we've talked about. In this
video, we talked about the second major control

03:38:29.851 --> 03:38:34.070
flow construct that we have in the go language,
the looping construct, and we talked about

03:38:34.070 --> 03:38:37.830
how we're going to use the for statement for
all of the loops that we need to do and go.

03:38:37.830 --> 03:38:41.900
So we don't have to remember I do keyword
and while keyword and a for keyword, when

03:38:41.900 --> 03:38:47.660
we use the for keyword that's going to allow
us to loop over every collection that we have.

03:38:47.660 --> 03:38:51.610
We started by talking about simple loops and
how there are three basic forms for the simple

03:38:51.610 --> 03:38:56.170
loop, we've got this first syntax, which is
the most basic, that's the initializer test

03:38:56.170 --> 03:38:59.080
incrementer syntax, and we're going to use
that initializer

03:38:59.080 --> 03:39:03.751
to set us up in our loop. Normally, by initializing
a counter variable, then we're going to follow

03:39:03.751 --> 03:39:07.860
that with our test, our test is normally going
to look at the incrementer to see if it's

03:39:07.860 --> 03:39:12.311
at a certain value that's out of range for
our for loop. And then we've got an incrementer

03:39:12.311 --> 03:39:17.120
and that incrementer. His job is to move the
incrementer along at every iteration of the

03:39:17.120 --> 03:39:20.630
loop in order to move to the next case that
we want to loop through. Now we also learned

03:39:20.630 --> 03:39:25.330
in this first syntax, we actually can leave
the first and last statements on that out.

03:39:25.330 --> 03:39:29.150
But if we're going to use any of this syntax,
we have to leave the semi colons in place.

03:39:29.150 --> 03:39:34.480
So leaving a semi colon out confuses the compiler,
it starts to assign things to the wrong places.

03:39:34.480 --> 03:39:37.660
And so you're going to get an error in your
application. So if you need an initializer

03:39:37.660 --> 03:39:42.590
or an incrementer, then you're going to have
to use this full syntax. Now the second syntax

03:39:42.590 --> 03:39:47.391
eliminates the need for the initializing the
incrementer. And it assumes that the test

03:39:47.391 --> 03:39:52.110
conditions are being managed somewhere else.
So in this construct, you only have the for

03:39:52.110 --> 03:39:56.380
test. And as soon as that test is false, you're
going to exit the loop. The last construct

03:39:56.380 --> 03:40:00.800
that we have is the for loop on its own and
that will run indefinitely. Until somewhere

03:40:00.800 --> 03:40:05.590
within your four loop, the break statement
is called. That leads us to how we can exit

03:40:05.590 --> 03:40:09.670
early from a for loop. And we have three concepts
that we talked about with that, we've got

03:40:09.670 --> 03:40:14.140
the break keyword that will break out of the
immediate loop that's executing and continue

03:40:14.140 --> 03:40:19.120
the application execution after that loop.
The continue statement is similar to the break

03:40:19.120 --> 03:40:23.250
statement, except for eight doesn't break
out of the loop, it just breaks out of the

03:40:23.250 --> 03:40:28.190
current iteration goes back to the incrementer,
and continues execution of the for loop at

03:40:28.190 --> 03:40:32.510
the next increment. Now we can also use labels
in our application and combine those with

03:40:32.510 --> 03:40:36.910
break statements in order to break out of
an inner loop. And that's typically how they're

03:40:36.910 --> 03:40:41.460
used in go. So for example, if you have a
nested loop where you're iterating over two

03:40:41.460 --> 03:40:44.591
collections, and you need to break out of
the outer loop, then you need to set up a

03:40:44.591 --> 03:40:48.979
label and then follow the break keyword with
the name of that label so that Google knows

03:40:48.979 --> 03:40:53.370
where to break out to. And finally, we talked
about how to loop over collections, and how

03:40:53.370 --> 03:40:57.710
the collections that we have available, there's
quite a few we've got arrays, slices, maps,

03:40:57.710 --> 03:41:02.250
strings and panels that we can loop over.
But they all have this similar syntax, we're

03:41:02.250 --> 03:41:05.672
going to use that for keyword, we're going
to get a key and a value. And then we're going

03:41:05.672 --> 03:41:10.620
to set that equal to the range keyword followed
by the collection that we're looping over.

03:41:10.620 --> 03:41:14.720
So the keys when working with arrays, slices
and strings are going to be the index within

03:41:14.720 --> 03:41:18.700
that collection. So you're going to have that
zero based index. With maps, we're going to

03:41:18.700 --> 03:41:22.800
get the key from that map. And the values
are what you expect them to be. They're the

03:41:22.800 --> 03:41:26.840
value for that current index. Now when we're
talking about channels, it's going to follow

03:41:26.840 --> 03:41:30.850
very similar syntax, but channels have a little
bit of a special interpretation for these.

03:41:30.850 --> 03:41:35.391
And we'll talk about those in a future module,
I'd like to finish our discussion of control

03:41:35.391 --> 03:41:40.820
flow constructs that we haven't go by talking
about defer panic and recovery. We'll start

03:41:40.820 --> 03:41:44.780
that discussion by talking about deferred
functions, and how we can actually invoke

03:41:44.780 --> 03:41:50.150
a function, but delay its execution to some
future point in time. Then we'll talk about

03:41:50.150 --> 03:41:55.000
how an application can panic. So in this conversation,
we'll talk about how go application can enter

03:41:55.000 --> 03:41:59.210
a state where it can no longer continue to
run and how the go runtime can trigger that

03:41:59.210 --> 03:42:03.290
as well as how we can trigger that on our
own. And then related to panicking, we'll

03:42:03.290 --> 03:42:07.990
talk about recovery. Now when your application
starts to panic, ideally, you'd have some

03:42:07.990 --> 03:42:12.570
way to save the program so that it doesn't
bail out completely. So we'll talk about if

03:42:12.570 --> 03:42:16.550
your application can be saved, how you can
use the recover function in order to signal

03:42:16.550 --> 03:42:22.630
that to the rest of your application. Okay,
so let's go ahead and get started. In a normal

03:42:22.630 --> 03:42:27.420
go, application control flows from the top
to the bottom of any function that we call.

03:42:27.420 --> 03:42:31.891
Now, of course, we can alter that a little
bit by introducing branching logic so that

03:42:31.891 --> 03:42:36.570
we can skip some statements. And we can use
looping that we talked about in the last video

03:42:36.570 --> 03:42:40.470
to repeat certain blocks of statements multiple
times. But generally, a function is going

03:42:40.470 --> 03:42:44.681
to start at the first line and execute through
until it gets to the last one. So if we run

03:42:44.681 --> 03:42:49.090
this program right here, we see that it's
no big surprise that we print start, then

03:42:49.090 --> 03:42:53.700
we print middle, and then we print end. And
what we can do if we want to defer the execution

03:42:53.700 --> 03:42:58.640
one of these statements is proceeded with
the defer keyword. So if I put that in front

03:42:58.640 --> 03:43:04.521
of this print line here, then run that, you
notice that middle is actually printed after

03:43:04.521 --> 03:43:10.280
end. So the way the defer keyword works in
go, is that it actually executes any functions

03:43:10.280 --> 03:43:14.990
that are passed into it after the function
finishes its final statement, but before it

03:43:14.990 --> 03:43:20.440
actually returns. So the way this main function
is executing is its calling line eight and

03:43:20.440 --> 03:43:24.580
it's printing out start, then it recognizes
that it has a deferred function to call and

03:43:24.580 --> 03:43:29.021
then it prints out end. And then the main
function exits now when go recognizes that

03:43:29.021 --> 03:43:33.000
that function exits, it looks to see if there
are any deferred functions to call. And since

03:43:33.000 --> 03:43:37.930
we have one, and then goes ahead and calls
that, so deferring doesn't move it to the

03:43:37.930 --> 03:43:42.540
end of the main function, and actually moves
it after the main function. But before the

03:43:42.540 --> 03:43:46.851
main function returned. Now, if we put the
deferred keyword in front of all of these

03:43:46.851 --> 03:43:52.720
statements, then we'll actually see an interesting
behavior. Because the deferred functions are

03:43:52.720 --> 03:43:58.561
actually executed in what's called lifepo
order or last in first out. So the last function

03:43:58.561 --> 03:44:02.320
that gets deferred is actually going to be
the first one that gets called. And this makes

03:44:02.320 --> 03:44:07.420
sense, because often we're going to use the
deferred keyword to close out resources. And

03:44:07.420 --> 03:44:11.720
it makes sense that we close resources out
in the opposite order that we open them, because

03:44:11.720 --> 03:44:15.760
one resource might actually be dependent on
another one. So if we run this like this,

03:44:15.760 --> 03:44:19.521
we actually see that we've reversed the order
of printing this. So we're now printing and

03:44:19.521 --> 03:44:23.440
middle and start. And just to remind you,
these aren't executing in the context of the

03:44:23.440 --> 03:44:27.851
main function they're executing after the
main function is done, but before it returns

03:44:27.851 --> 03:44:31.780
any results to the calling function. Now,
these are good theoretical examples. But in

03:44:31.780 --> 03:44:35.271
this situation, I felt it makes sense to get
a little bit more practical example for you

03:44:35.271 --> 03:44:39.890
to look at. So for this, we're actually going
to need to go into Visual Studio code, because

03:44:39.890 --> 03:44:43.220
we're going to need to run a program that's
going to make some resource requests through

03:44:43.220 --> 03:44:47.900
the HTTP package. And you can't do that in
a playground. So if we look at this program,

03:44:47.900 --> 03:44:51.960
here, we're importing a couple of packages.
Then we're using the get function from the

03:44:51.960 --> 03:44:57.460
HTTP package in order to request the robots
dot txt file from google.com. Now this example

03:44:57.460 --> 03:45:02.060
you can actually find in gos documentation.
I basically stole this as an example for how

03:45:02.060 --> 03:45:05.621
you can use the deferred function. Now, as
you can see, with this request, we're going

03:45:05.621 --> 03:45:09.140
to get a response and an optional error. And
we're going to check to see if that error

03:45:09.140 --> 03:45:13.730
is nil. And if it's not, then we're going
to log that out and exit our application.

03:45:13.730 --> 03:45:17.840
If it is not nailed, and we got a good response.
So then we're going to use the read all function

03:45:17.840 --> 03:45:22.570
from the IO util package, what that'll do
is that'll take in a stream, and that'll parse

03:45:22.570 --> 03:45:26.320
that out to a string of bytes for you to work
with. So if we look at the robots variable,

03:45:26.320 --> 03:45:30.470
here, we see that that is a string of bytes.
And then we close the body of the response

03:45:30.470 --> 03:45:34.460
to let the web request know that we're done
working with it, so it can free up those resources.

03:45:34.460 --> 03:45:37.860
Of course, the read operation can fail, so
we're checking for that error. And then we're

03:45:37.860 --> 03:45:43.171
finally going to print out the value of the
robots variable here. So if we run this application,

03:45:43.171 --> 03:45:48.480
by invoking it with the go run command, we
see in fact that we do get the robots printed

03:45:48.480 --> 03:45:52.610
out, and everything worked out just fine.
So we got this entire response printed out

03:45:52.610 --> 03:45:56.450
to the console here. Now, one thing that we're
doing here, and that the defer keyword can

03:45:56.450 --> 03:46:02.021
help with is handling this body close. Now,
in this application, we only have one statement

03:46:02.021 --> 03:46:06.650
that's really being worked with between the
request being made, and the body being closed.

03:46:06.650 --> 03:46:11.110
However, in many applications, you might have
quite a bit of logic that's involved, that

03:46:11.110 --> 03:46:14.800
needs that body to be open and continue to
work with it, maybe you're reading this stream

03:46:14.800 --> 03:46:19.030
one character at a time, and you're doing
some pattern matching or something like that.

03:46:19.030 --> 03:46:23.190
So you can actually end up with quite a few
statements in here. So what can happen here

03:46:23.190 --> 03:46:27.510
is that you might make this request and open
up this resource up here. And then it might

03:46:27.510 --> 03:46:31.930
be dozens of lines later that you actually
get around to closing in. Well, that introduces

03:46:31.930 --> 03:46:36.271
the possibility that you forget to close it.
Now, it's going to be hard to find that it's

03:46:36.271 --> 03:46:40.780
going to be hard to remember to close the
resource. And so you're introducing the possibility

03:46:40.780 --> 03:46:45.700
of bugs coming into your application. So what
we can do is add the defer keyword here. And

03:46:45.700 --> 03:46:49.320
then we can go ahead and move this up a line.
So if we run this, then it looks like we're

03:46:49.320 --> 03:46:53.570
closing the resource, and then we're trying
to read it. But if we run the application,

03:46:53.570 --> 03:46:57.450
we see that it works just fine. Everything
comes out the same way it did before. Now

03:46:57.450 --> 03:47:00.891
if we leave the defer keyword off,

03:47:00.891 --> 03:47:04.670
then we do get an error because we closed
the response body before we were done reading

03:47:04.670 --> 03:47:08.660
it. So what this allows you to do, and this
is the most common use case that I've seen

03:47:08.660 --> 03:47:14.021
for using defer is it allows you to associate
the opening of a resource and the closing

03:47:14.021 --> 03:47:17.700
of the resource right next to each other.
So you see this pattern a lot where we're

03:47:17.700 --> 03:47:21.021
going to open resource, we're going to check
for an error. And then we're going to close

03:47:21.021 --> 03:47:24.750
the resource. And you want to check for the
error first. Because if there's error generated

03:47:24.750 --> 03:47:28.360
here, then you actually never got this resource.
And so trying to close, it will cause your

03:47:28.360 --> 03:47:32.080
application to fail. But as long as you know
that you have the resource there, then it

03:47:32.080 --> 03:47:35.810
makes sense to do a deferred call to close
it. Now, one thing I would warn you about

03:47:35.810 --> 03:47:39.800
is this is a pretty common pattern. And you're
going to see this all the time. But if you're

03:47:39.800 --> 03:47:44.240
making a lot of requests and opening a lot
of resources within a loop, then using the

03:47:44.240 --> 03:47:49.221
defer keyword to close, it might not be your
best choice. Because remember, the deferred

03:47:49.221 --> 03:47:53.100
statements don't execute until the function
itself executes. So if you've got a loop that's

03:47:53.100 --> 03:47:57.210
going to loop over a million resources, you're
gonna have a million resources open before

03:47:57.210 --> 03:48:01.210
all of those get closed at the same time when
the function finally executes. So if you're

03:48:01.210 --> 03:48:05.690
working with resources in the loop, then you
might not actually want to use the defer keyword,

03:48:05.690 --> 03:48:09.370
you might want to explicitly close those resources
when you're done with them. Or another option

03:48:09.370 --> 03:48:13.400
would be to delegate the processing of those
resources out to another function and have

03:48:13.400 --> 03:48:17.370
that function, close the resource. That way,
you're not keeping a bunch of resources open

03:48:17.370 --> 03:48:21.940
at one time and wasting memory. Now the next
thing that I want to show you we can do back

03:48:21.940 --> 03:48:25.600
in the playground. So I want to do that, because
I think that's the most accessible environment

03:48:25.600 --> 03:48:30.891
that we have is this program here. So when
I run this program here, what do you think

03:48:30.891 --> 03:48:35.100
is going to print out when I run this, now
there's two lines of thought that you might

03:48:35.100 --> 03:48:39.670
have, the first line of thought is, well,
I'm defining a is the string start. And so

03:48:39.670 --> 03:48:44.250
I'm going to print start out. But you might
also realize the defer statement is going

03:48:44.250 --> 03:48:48.310
to cause this statement to print after the
main function is done. And before main is

03:48:48.310 --> 03:48:52.731
done, we've already changed the value to end.
So you could make an argument that this is

03:48:52.731 --> 03:48:57.100
going to bring start or end with the fact
is that we're going to get the values start

03:48:57.100 --> 03:49:02.100
printed out. And the reason for that is when
you defer a function like this, it actually

03:49:02.100 --> 03:49:06.631
takes the argument at the time, the defer
is called not at the time the called function

03:49:06.631 --> 03:49:11.430
is executed. So even though the value of a
is changed, before we leave the main function,

03:49:11.430 --> 03:49:16.311
we are going to actually eagerly evaluate
this variable. And so the value start is going

03:49:16.311 --> 03:49:20.750
to be put in here, we're not going to pay
attention to this value as it changes. Now

03:49:20.750 --> 03:49:25.150
the next thing that I want to talk to you
about in this video, is what's called panicking.

03:49:25.150 --> 03:49:29.480
Now in go, we don't have exceptions, like
a lot of applications have, because a lot

03:49:29.480 --> 03:49:33.700
of cases that are considered exceptional and
a lot of languages are considered normal in

03:49:33.700 --> 03:49:38.971
a go application. For example, if you try
and open a file, and that file doesn't exist,

03:49:38.971 --> 03:49:42.650
that's actually a pretty normal response.
It is reasonable to assume that you might

03:49:42.650 --> 03:49:47.210
try and open a file that doesn't exist. And
so we return error values. We don't throw

03:49:47.210 --> 03:49:52.120
exceptions because that's not considered exceptional
and go. However, there are some things that

03:49:52.120 --> 03:49:56.790
get a go application into a situation where
it cannot continue and that is considered

03:49:56.790 --> 03:50:00.950
exceptional. But instead of using the word
exception, which you has a lot of connotations

03:50:00.950 --> 03:50:04.490
because of its use and other languages, we're
going to use another word and that word is

03:50:04.490 --> 03:50:08.530
going to be panic. And that's because our
application can't continue to function. And

03:50:08.530 --> 03:50:12.120
so it's really starting to panic because it
can't figure out what to do. So if we take

03:50:12.120 --> 03:50:16.610
this example, here, I'm declaring two variables
a and b, and setting a equals one and B equal

03:50:16.610 --> 03:50:22.450
to zero. Now, obviously, the answer of one
divided by zero is invalid, we can't do that

03:50:22.450 --> 03:50:27.240
in a go application. So if I run this, we're
actually going to see that the runtime itself

03:50:27.240 --> 03:50:32.380
will generate a panic for us. And the runtime
errors printed out integer divide by zero.

03:50:32.380 --> 03:50:36.011
And then we get a stack trace letting us know
where that error occurred. Now, if you're

03:50:36.011 --> 03:50:39.790
going along and writing your own program,
and you get to a situation where your program

03:50:39.790 --> 03:50:43.830
cannot continue to execute, because of a certain
state that gets thrown, then it makes sense

03:50:43.830 --> 03:50:48.460
for you to panic as well. So to do that, you're
going to use the built in panic function like

03:50:48.460 --> 03:50:52.650
we see here. So we're printing out start,
then we're using the built in panic function

03:50:52.650 --> 03:50:56.400
passing in a string, and then we're going
to print out. And what's going to happen when

03:50:56.400 --> 03:51:01.170
we run this is very similar behavior to when
we had that divide by zero error a few seconds

03:51:01.170 --> 03:51:04.931
ago, but the error message that's printed
out is actually going to be the string that

03:51:04.931 --> 03:51:09.460
we passed into the panic function. And then
notice we get the same stack trace out, we

03:51:09.460 --> 03:51:13.540
do get start printing out. But of course,
we don't get the string end printed out.

03:51:13.540 --> 03:51:17.360
Now more practical example. Now this will
not run in the playground. But that's okay,

03:51:17.360 --> 03:51:22.320
because it probably wouldn't fail on the playground
anyway, is this one here. So this is a very

03:51:22.320 --> 03:51:25.730
simple web application where you're going
to use the handle function. So we're registering

03:51:25.730 --> 03:51:30.160
a function listener, that's going to listen
on every URL in our application. And then

03:51:30.160 --> 03:51:35.141
this is a callback that gets called every
time a URL comes in that matches this route.

03:51:35.141 --> 03:51:38.851
And all this is going to do is print out the
string hello, go. As a matter of fact, why

03:51:38.851 --> 03:51:41.931
don't I go ahead and do this over in Visual
Studio code, that way, you can see what this

03:51:41.931 --> 03:51:45.960
program is going to do. So we'll go ahead
and save this and we'll get it up and running.

03:51:45.960 --> 03:51:52.320
Now there's no errors and went ahead and started,
okay. So if I come in, and hit that URL, which

03:51:52.320 --> 03:51:57.570
is localhost 8080, that you see that we get
the string hello, go printed out. There you

03:51:57.570 --> 03:52:02.300
go an entire web development course in one
video. So we've got a very basic web handler

03:52:02.300 --> 03:52:06.940
that's printing out the string, hello, go.
And that's coming from this line right here,

03:52:06.940 --> 03:52:10.800
where we're writing to this response writer,
this response writer is basically giving us

03:52:10.800 --> 03:52:16.550
access to the response to this web request.
And we're printing out the string hello, go.

03:52:16.550 --> 03:52:20.860
Now, what's interesting here is this error
handler right here. So the listening serve

03:52:20.860 --> 03:52:25.410
function returns an optional error object.
So when might that happen? Well, one situation

03:52:25.410 --> 03:52:29.181
that can happen all the time, when you're
firing up a web server is the port can be

03:52:29.181 --> 03:52:34.340
blocked. So if I open up another terminal
here, and go ahead and try and run this, again,

03:52:34.340 --> 03:52:38.590
you see that we get our application panicking.
And the reason for that is we're trying to

03:52:38.590 --> 03:52:42.440
access a TCP port that's already been blocked.
And it's been blocked by the fact that we're

03:52:42.440 --> 03:52:46.841
running the application over here. So this
is a situation that happens all the time.

03:52:46.841 --> 03:52:51.381
Now, the listening serve function doesn't
have an opinion on if that's a panicking situation

03:52:51.381 --> 03:52:55.130
or not, because he just tried to execute something.
And it's going to return an error value saying,

03:52:55.130 --> 03:52:59.210
Well, that didn't work, it's reasonable to
assume that listening serve can fail. And

03:52:59.210 --> 03:53:03.830
so it's not going to panic is going to return
an error. Now, we're the ones writing the

03:53:03.830 --> 03:53:08.040
web application. And we know that if that
doesn't work, the entire application gets

03:53:08.040 --> 03:53:13.080
brought down, and nothing happens. So in that
situation, we decide that we're going to panic

03:53:13.080 --> 03:53:16.771
passing out that error that comes from the
listening serve method, letting whoever's

03:53:16.771 --> 03:53:20.921
trying to start this up, know that something
very bad just happen. And so this is a common

03:53:20.921 --> 03:53:25.010
pattern that you're going to see and go go
is rarely going to set an opinion about whether

03:53:25.010 --> 03:53:28.790
an error is something that should be panicked
over or not. all it's going to do is tell

03:53:28.790 --> 03:53:32.630
you, hey, this didn't work the way that you
expected it to work. It's up to you, as a

03:53:32.630 --> 03:53:36.381
developer to decide whether that's a problem
or not. So in this case, we say, yeah, that

03:53:36.381 --> 03:53:41.880
is a problem, we fail to start our application.
And so we do want to generate a panic. So

03:53:41.880 --> 03:53:46.230
what are we going to do in the situation that
our application is panicking. And we can get

03:53:46.230 --> 03:53:50.771
ourselves to a situation where we can recover
the application. So panics don't have to be

03:53:50.771 --> 03:53:56.560
fatal. They just are, if we panic all the
way up to the go runtime, and the go runtime

03:53:56.560 --> 03:53:59.570
realizes wait doesn't know what to do with
a panicking application. And so it's going

03:53:59.570 --> 03:54:04.330
to kill it. So we come back to this application
here, and run, we see that once again, we're

03:54:04.330 --> 03:54:09.650
getting this panic. But something I want to
show you related to our deferred discussion

03:54:09.650 --> 03:54:14.171
is this modification here. So I've added this
line, a deferred print statement that says

03:54:14.171 --> 03:54:19.350
this was deferred. So if we run this application,
something interesting is going to happen.

03:54:19.350 --> 03:54:23.310
We get stopped printed out. That's not a big
surprise. But then we get this was deferred

03:54:23.310 --> 03:54:28.860
printing out and then the panic happens. And
this is really important, because panics happen

03:54:28.860 --> 03:54:34.301
after deferred statements are executed. So
the order of execution is we're going to execute

03:54:34.301 --> 03:54:38.501
our main function, then we're going to execute
any deferred statements, then we're going

03:54:38.501 --> 03:54:42.890
to handle any panics that occur. And then
we're going to handle the return value. So

03:54:42.890 --> 03:54:46.740
there's actually quite a bit that happens
in a function after it exits this closing

03:54:46.740 --> 03:54:50.801
curly brace here. So why is this important?
Well, the first thing that's important is

03:54:50.801 --> 03:54:54.530
that the first statements that are going to
close resources are going to succeed even

03:54:54.530 --> 03:54:59.141
if the application panics. So if somewhere
up the call stack, you recover from the panic,

03:54:59.141 --> 03:55:00.540
you don't have to worry about

03:55:00.540 --> 03:55:05.730
resources being left out there and left open.
So any deferred calls to close resources are

03:55:05.730 --> 03:55:10.200
still going to work even if a function panics.
But the other thing that's really important

03:55:10.200 --> 03:55:17.091
is if I change my deferred function here to
something like this, now, this is a custom

03:55:17.091 --> 03:55:20.620
function. And we're not going to talk about
this for a couple of videos yet. But this

03:55:20.620 --> 03:55:23.590
is important in order to talk about this.
So I need to jump this ahead in the queue

03:55:23.590 --> 03:55:24.730
a little bit.

03:55:24.730 --> 03:55:28.830
So what we're creating here is what's called
an anonymous function. And an anonymous function

03:55:28.830 --> 03:55:32.960
is simply a function that doesn't have a name.
So nothing else can call this, this is defined

03:55:32.960 --> 03:55:38.500
at one point, and we can call it exactly one
time, these parenthesis here are making that

03:55:38.500 --> 03:55:42.700
function execute. And this is an important
thing to know about the defer statement, the

03:55:42.700 --> 03:55:46.691
first statement doesn't take a function itself,
it actually takes a function call. So you

03:55:46.691 --> 03:55:51.080
want to invoke that function, otherwise, things
aren't going to work properly. Now, inside

03:55:51.080 --> 03:55:55.990
of this custom function, notice that we're
using this recover function here. So what

03:55:55.990 --> 03:56:01.240
the recover function is going to do is it
will return nil if the application isn't panicking.

03:56:01.240 --> 03:56:05.300
But if it isn't nil, then it's going to return
the error that actually is causing the application

03:56:05.300 --> 03:56:10.381
to panic. So in this logical test, we're checking
to see if it's not nil. So if it's not nil,

03:56:10.381 --> 03:56:14.110
that means our application is panicking. and
in this situation, we're simply going to log

03:56:14.110 --> 03:56:18.420
that error out. Now, what happens in this
situation is the execution still stops at

03:56:18.420 --> 03:56:25.540
the panic. And let me import this log package
before we run this. And we see that the application

03:56:25.540 --> 03:56:29.950
still execute. So we got the string start
printed out, then we printed out the error

03:56:29.950 --> 03:56:34.490
using the long package. But we didn't get
this end function printed out. So it looks

03:56:34.490 --> 03:56:39.410
like our application is still dead. But recovered
does have some important impacts if we have

03:56:39.410 --> 03:56:43.150
a deeper call stack than what we're dealing
with right here. So let me drop in this example

03:56:43.150 --> 03:56:46.841
in order to show you. So in this case, we've
got the main function, that's going to be

03:56:46.841 --> 03:56:50.801
our application entry point, of course. And
then we've got this other function called

03:56:50.801 --> 03:56:53.950
panikkar. And all this thing does is it's
going to print on the line that says it's

03:56:53.950 --> 03:56:57.950
about the panic, and then it's going to panic.
And it's going to go ahead and recover from

03:56:57.950 --> 03:57:01.601
that panic using that deferred function that
we saw just a moment ago, then we're gonna

03:57:01.601 --> 03:57:05.440
have this line here, done panicking. And then
up in our main function, we're going to print

03:57:05.440 --> 03:57:09.961
start, we're going to call the panacur. And
then we're going to print and so let's see

03:57:09.961 --> 03:57:15.480
what happens when we run this. So as you see,
we get the start line printed out, like you

03:57:15.480 --> 03:57:21.310
would expect, we see the about the panic string
print out, then we panic, something bad happened,

03:57:21.310 --> 03:57:25.021
we go into our recover loop, because we're
not going to execute this because our application

03:57:25.021 --> 03:57:29.890
panic. And so our panikkar function is going
to stop execution right there and execute

03:57:29.890 --> 03:57:34.780
any deferred functions. And inside of that
deferred function, we call recover. So in

03:57:34.780 --> 03:57:38.350
that recover, we're going to log out the fact
that we have that error, and we're going to

03:57:38.350 --> 03:57:43.370
log that error message out that we see here.
But then in the main function execution continues.

03:57:43.370 --> 03:57:47.940
So in the event that you're recovering from
a panic, the function that actually recovers,

03:57:47.940 --> 03:57:52.650
still stops execution, because it's in a state
where it can no longer reliably continue to

03:57:52.650 --> 03:57:58.021
function. And so it makes sense for it to
stop doing whatever it was trying to do. However,

03:57:58.021 --> 03:58:01.700
functions higher up the call stack, those
functions that call the function that recovered

03:58:01.700 --> 03:58:06.521
from the panic, they are still presumably
in a situation where they can continue, because

03:58:06.521 --> 03:58:11.320
you recover function said that your application
is in a state working to continue to execute.

03:58:11.320 --> 03:58:15.631
Now, this is a little bit limiting as well,
because in order to determine what that error

03:58:15.631 --> 03:58:19.420
is, you actually have to call the recover
function, which basically means that you're

03:58:19.420 --> 03:58:23.090
saying that you're going to deal with it.
So what happens if you get that error, and

03:58:23.090 --> 03:58:26.850
you realize that this isn't something that
you can deal with? Well, in that case, what

03:58:26.850 --> 03:58:31.730
you're going to do is repainting the application.
So all we need to do in order to do that is

03:58:31.730 --> 03:58:35.421
just read through the error, or you can come
up with another error string, whatever makes

03:58:35.421 --> 03:58:40.811
sense for you. But in this case, inside of
the handler, we're throwing a panic again,

03:58:40.811 --> 03:58:45.510
then we actually see that we don't get that
end statement printed out our main function

03:58:45.510 --> 03:58:49.500
panics because we read through that panic.
So we get the full stack trace of when the

03:58:49.500 --> 03:58:53.840
panic actually happened. And we see that we're
inside a func one function, one is actually

03:58:53.840 --> 03:58:58.210
this anonymous function right here. And we
see that we do get that stack trace printed

03:58:58.210 --> 03:59:02.502
out and we don't get the string and printed
out. So if you're in a situation where you're

03:59:02.502 --> 03:59:06.090
trying to recover from a panic, and you realize
you can't handle it, you can feel free to

03:59:06.090 --> 03:59:11.390
re throw that panic, and the further management
of that panic, higher up the call stack. Okay,

03:59:11.390 --> 03:59:15.780
so let's go into a summary and review what
we've talked about in this video. In this

03:59:15.780 --> 03:59:19.800
video, we talked about the final two control
flow concepts that we have to be aware of

03:59:19.800 --> 03:59:24.920
in go programming. Now, one could argue that
differs and panics aren't really control flow

03:59:24.920 --> 03:59:29.710
constructs, because they're not the traditional
branching or looping logic that we consider.

03:59:29.710 --> 03:59:33.910
But they definitely do alter the flow of execution
of our program. And so I'm going to lump them

03:59:33.910 --> 03:59:37.771
together in this category. The first thing
that we talked about was the use of the defer

03:59:37.771 --> 03:59:43.310
function in order to delay the execution of
a statement until the end of a function. Now,

03:59:43.310 --> 03:59:47.340
these are useful to group open and close functions
together. So if your open function is going

03:59:47.340 --> 03:59:51.350
to open up a resource, and you need to make
sure that you close that, then you can defer

03:59:51.350 --> 03:59:55.501
the call to close that resource to make sure
that you're freeing up the memory and not

03:59:55.501 --> 03:59:59.370
holding on to that resource any longer than
you need to. The one thing I would warn you

03:59:59.370 --> 04:00:03.351
though, is be careful loops. If you're opening
and closing a bunch of resources inside of

04:00:03.351 --> 04:00:08.700
a loop, then you probably want to explicitly
handle that close without the deferred keyword.

04:00:08.700 --> 04:00:12.280
Because when you're using deferred keyword,
all of those resources are going to stay open

04:00:12.280 --> 04:00:16.920
until the function finishes execution. And
that can cause you some memory issues, especially

04:00:16.920 --> 04:00:21.061
if you're dealing with a very large number
of resources. If you've got multiple different

04:00:21.061 --> 04:00:25.860
statements inside of a function, then they
run in life order or lastin. First out, so

04:00:25.860 --> 04:00:30.500
the last deferred statement that you call
is going to be the first one that actually

04:00:30.500 --> 04:00:34.370
executes. And again, this makes sense, because
if you're opening a bunch of resources, and

04:00:34.370 --> 04:00:38.160
those resources are dependent upon one another,
then you're going to close them in the reverse

04:00:38.160 --> 04:00:42.230
order that you open them, which is typically
the right way to go. arguments in a deferred

04:00:42.230 --> 04:00:47.110
call are evaluated at the time the defer is
executed, not at the time the called function

04:00:47.110 --> 04:00:52.000
is executed. And that's important to keep
in mind because you could pass in variables

04:00:52.000 --> 04:00:56.290
into a deferred function call. And it can
be a little bit confusing if you change the

04:00:56.290 --> 04:01:00.311
value of those variables further on. And those
aren't reflected in your deferred statement.

04:01:00.311 --> 04:01:04.300
So just keep in mind, when you call defer,
the value of those variables are going to

04:01:04.300 --> 04:01:08.960
be captured at the time that that defer is
executed, not at the time the function actually

04:01:08.960 --> 04:01:13.350
executes. Now, something unplanned happens
in our application, then we've got two ways

04:01:13.350 --> 04:01:17.540
that a go application can go it can return
an error value, which is the normal case,

04:01:17.540 --> 04:01:23.050
or it can panic. Now, what you generally want
to do is you want to return an error value,

04:01:23.050 --> 04:01:28.190
because in go programming, we typically don't
consider a lot of things that go wrong in

04:01:28.190 --> 04:01:31.891
an application to be exceptional events, or
to be events that should cause the application

04:01:31.891 --> 04:01:36.820
to shut down. For example, a classic example
of that is making an HTTP request, and you

04:01:36.820 --> 04:01:41.021
make the request and you don't get a response
from that server. Well, that's something that

04:01:41.021 --> 04:01:45.851
happens all the time, no response is a valid
response, it just happens to be an error,

04:01:45.851 --> 04:01:50.680
because you're looking for that resource,
and you got a 404 return back. So in that

04:01:50.680 --> 04:01:54.870
case, you're going to return an error value,
you're not going to panic, the application

04:01:54.870 --> 04:01:59.381
panics are used when an application gets into
a state that it cannot recover from, for example,

04:01:59.381 --> 04:02:03.980
you hand the runtime a divide by zero problem,
there's no way for you to figure out how to

04:02:03.980 --> 04:02:08.771
divide a number by zero, and so has no way
to manage that. And that's a situation where

04:02:08.771 --> 04:02:13.160
the application is going to panic. So just
to summarize, then, they occur when an application

04:02:13.160 --> 04:02:17.771
can't continue at all, don't use them when
a file can't be opened. Unless it's a critical

04:02:17.771 --> 04:02:22.101
file. For example, if you're opening a template
that's used in a web application to generate

04:02:22.101 --> 04:02:25.720
your view layer, then that might be something
that's worth panicking over. But if you're

04:02:25.720 --> 04:02:29.230
trying to open up a log file, and you can't
get there, well, there's no reason to panic

04:02:29.230 --> 04:02:33.010
for that necessarily, you just need to return
an error value and then inform somebody that

04:02:33.010 --> 04:02:34.010
the logs aren't available.

04:02:34.010 --> 04:02:37.891
Now a situation where you might want to panic
is unrecoverable events. So if you're starting

04:02:37.891 --> 04:02:41.830
up a web server, and it can't get ahold of
the TCP port that it's supposed to be listening

04:02:41.830 --> 04:02:45.881
on, then that's probably a situation where
panic makes sense, the function will stop

04:02:45.881 --> 04:02:50.190
executing immediately at the point of the
panic, but the third functions will still

04:02:50.190 --> 04:02:53.830
fire. If nothing handles that panic, then
eventually the panic is going to go up the

04:02:53.830 --> 04:02:57.891
call stack, it's going to hit the go runtime,
the go runtime has no built in handling for

04:02:57.891 --> 04:03:03.230
panicking situations. And so the program will
then exit. If you do have a panicking situation

04:03:03.230 --> 04:03:07.351
that you feel that you can recover from, then
you can recover using the built in recover

04:03:07.351 --> 04:03:13.141
function. Now that function is used to recover
from panics, it's only useful inside of deferred

04:03:13.141 --> 04:03:17.180
functions. And the reason for that is because
of the behavior of panic. Remember, when an

04:03:17.180 --> 04:03:21.681
application starts to panic, it no longer
executes the rest of that function, but it

04:03:21.681 --> 04:03:26.160
will execute deferred functions. So the proper
place to use the recover keyword is inside

04:03:26.160 --> 04:03:30.740
of a deferred function, that's going to look
for a panicking situation. And if the application

04:03:30.740 --> 04:03:34.771
is panicking, then it can go ahead and decide
what to do with it, the current function will

04:03:34.771 --> 04:03:39.580
not attempt to continue. But if you do recover,
then higher functions in the call stack will

04:03:39.580 --> 04:03:43.950
continue as if nothing went wrong. Now, if
that's not the behavior that you want, if

04:03:43.950 --> 04:03:47.460
you call that recover function, you look at
the error that's returned from the recover

04:03:47.460 --> 04:03:51.870
function and you can't handle it. Remember
that you can go ahead and rethrow that panic

04:03:51.870 --> 04:03:56.261
by calling the panic function again. And then
the panic will continue to propagate up the

04:03:56.261 --> 04:04:01.170
call stack, I want to talk about pointers
and how we can use them in the go language.

04:04:01.170 --> 04:04:04.900
We'll start that discussion off by learning
how to create pointers. And then we'll talk

04:04:04.900 --> 04:04:09.550
about something called dereferencing. a pointer,
which is basically using a pointer to get

04:04:09.550 --> 04:04:13.990
at some underlying data. Then we'll talk about
the new function. And then we'll talk about

04:04:13.990 --> 04:04:18.790
a special type in NGO called nil. And then
we'll wrap up our discussion by talking about

04:04:18.790 --> 04:04:23.701
built in types and go that use internal pointers.
And so their behaviors a little bit different

04:04:23.701 --> 04:04:28.170
than other types that you'll work with in
your applications. Okay, so let's dive right

04:04:28.170 --> 04:04:33.000
in and learn how to create some pointers.
To start our discussion, I want to start as

04:04:33.000 --> 04:04:37.290
simply as I can. So I'm going to use this
example here. As you can see him declaring

04:04:37.290 --> 04:04:41.700
a variable a and assigning it the value 42.
And then I'm going to go ahead and print that

04:04:41.700 --> 04:04:46.141
out. So it should be no big surprise that
when I run this, the value 42 gets printed

04:04:46.141 --> 04:04:51.600
out. Now, if I extend this application a little
bit, and I create a variable b and assign

04:04:51.600 --> 04:04:56.330
it to the value of a and print both of those
out, then again, it's no big surprise that

04:04:56.330 --> 04:05:02.200
42 prints out two times. Now since a and b
are value types. When I put in this line here,

04:05:02.200 --> 04:05:06.812
what go is going to do is it's actually going
to copy whatever data is stored in a and assign

04:05:06.812 --> 04:05:11.580
it to be. So we're not actually pointing to
the same memory. And we can prove that by

04:05:11.580 --> 04:05:17.101
changing the value of a to, for example, 27,
and then printing out everything again. And

04:05:17.101 --> 04:05:22.561
if we run this, we see that the value of a
changes to 27, but the value of b stays at

04:05:22.561 --> 04:05:27.870
42. Now we can change this behavior a little
bit by having B point to a using something

04:05:27.870 --> 04:05:32.620
called a pointer. Now in order to demonstrate
that, I'm going to actually change our declaration

04:05:32.620 --> 04:05:37.600
syntax a little bit and go to more of a long
form syntax. And the reason for that is to

04:05:37.600 --> 04:05:42.021
make things a little bit more clear about
how the pointer notation works. So I hope

04:05:42.021 --> 04:05:45.601
you'll agree with me that this line eight
is exactly the same as the previous one that

04:05:45.601 --> 04:05:50.990
we had, it's just a little bit more verbose.
Now, if I want to change B into a pointer,

04:05:50.990 --> 04:05:55.620
and use that same long form syntax, what I
can do is declare the variable b. And then

04:05:55.620 --> 04:05:59.510
I'm going to declare it as a pointer to an
integer. And the way I declare it as a pointer

04:05:59.510 --> 04:06:04.941
is by preceding the type that I'm pointing
to with this asterisk here. So then if I want

04:06:04.941 --> 04:06:10.600
B to point to a, then I'm going to use a special
operator called the address of operator that

04:06:10.600 --> 04:06:15.730
you see here. So at line nine is now saying
is that B is a pointer to an integer. And

04:06:15.730 --> 04:06:18.490
I want to point it to a

04:06:18.490 --> 04:06:21.910
now what is a pointer exactly? Well, let me
remove these lines here and run this and see

04:06:21.910 --> 04:06:27.130
what we get as output. So as you see here,
a is still holding the value 42, like we expect,

04:06:27.130 --> 04:06:32.600
but B is holding this strange data here. So
what is that? Well, this is actually the numerical

04:06:32.600 --> 04:06:39.200
representation for the memory address that
is holding the location of a. So at this location

04:06:39.200 --> 04:06:46.070
in memory, we actually have assigned the integer
42. So be isn't holding the value 42, it's

04:06:46.070 --> 04:06:51.130
holding the memory location that's holding
his data. And we can prove that by using the

04:06:51.130 --> 04:06:56.050
address of operator down here. And when we
run this, again, we should see, in fact, we

04:06:56.050 --> 04:07:02.290
do see that the values are exactly the same.
So the address of A in memory is this value

04:07:02.290 --> 04:07:07.800
here, and B is holding that exact value. And
as a matter of fact, we can even go the other

04:07:07.800 --> 04:07:12.510
way. Because while the address of operator
is going to give us the address of a variable

04:07:12.510 --> 04:07:17.510
in memory, we can use a different operator
in order to figure out what value is actually

04:07:17.510 --> 04:07:21.630
being stored at a memory location. And that's
called the dereferencing operator. So if I

04:07:21.630 --> 04:07:25.580
go ahead and remove this, and then I'm going
to put a dereferencing operator right here

04:07:25.580 --> 04:07:29.750
in front of this pointer. Now you notice we're
using the same asterisk. But these have a

04:07:29.750 --> 04:07:34.720
little bit different meaning here. So up here
on line nine, this asterisk before type is

04:07:34.720 --> 04:07:39.520
declaring a pointer to data of that type.
So this is a pointer to an integer. Now when

04:07:39.520 --> 04:07:44.210
I put the asterisk in front of a pointer,
then that's going to dereference, which basically

04:07:44.210 --> 04:07:48.600
means it's going to ask the go runtime, to
drill through the pointer, find the memory

04:07:48.600 --> 04:07:53.130
location that that pointer is pointing to,
and then pull the value back out. So if we

04:07:53.130 --> 04:07:58.240
run this, we see that we get the value 42
printed out both times once again. Now what's

04:07:58.240 --> 04:08:03.450
the point of all of this, what the point is,
since B is pointing at the same value of a,

04:08:03.450 --> 04:08:08.720
Now both of these variables are actually tied
together. So if we change the value of a once

04:08:08.720 --> 04:08:16.030
again, and then print out their data, now
we see that both A and dereferencing, b both

04:08:16.030 --> 04:08:21.210
give the value of 27. Because they're both
actually pointing at the same underlying data.

04:08:21.210 --> 04:08:25.610
As a matter of fact, we can even dereference
the pointer and use that to change the value.

04:08:25.610 --> 04:08:31.220
So if I use the dereference, B, and assign
the value 42 to it, and then print it out

04:08:31.220 --> 04:08:36.170
again, then we see that once again, both values
are changing a and the value that B is pointing

04:08:36.170 --> 04:08:41.250
to our both teams, because it's in fact the
same data. Now, if you come from a background

04:08:41.250 --> 04:08:46.100
in languages that allow you to work with pointers
as variables, then you might be expecting

04:08:46.100 --> 04:08:50.831
to do something called pointer arithmetic.
So if I drop this example in here, we're going

04:08:50.831 --> 04:08:54.300
to start to play around with something that's
going to lead us to see how go treats pointer

04:08:54.300 --> 04:08:58.311
arithmetic. So I'm going to start with a variable
a, and that's going to hold an array of three

04:08:58.311 --> 04:09:04.150
values, one, two, and three. And then I'm
declared B as a pointer to the first element

04:09:04.150 --> 04:09:08.370
in the array to this value right here. And
then C is pointing to this second element

04:09:08.370 --> 04:09:11.990
right here. Now if I use this print statement,
here, it's going to print the value of the

04:09:11.990 --> 04:09:17.330
array and then this percent p syntax is actually
going to print the value of the pointer for

04:09:17.330 --> 04:09:22.130
BNC. So if we run this, we see that we do
in fact, get the array and then we get these

04:09:22.130 --> 04:09:26.990
two memory locations printed out that B and
C are holding. Now notice that C is holding

04:09:26.990 --> 04:09:31.880
a value that's for higher than B. And the
reason for that is how go lays out arrays

04:09:31.880 --> 04:09:36.360
in memory. Since this is an array of integers
and integers in this version of the runtime

04:09:36.360 --> 04:09:41.180
are four bytes long each element of an array
are four bytes apart. So this memory address

04:09:41.180 --> 04:09:47.160
ending with 124 is holding the first element
in the array, and then four bytes later, we're

04:09:47.160 --> 04:09:50.630
going to hold the next element of the array
c you might be tempted to do something like

04:09:50.630 --> 04:09:56.330
this if you come from another language, if
I take the address of C and subtract four,

04:09:56.330 --> 04:10:00.400
then that actually should give me the address
of B and then I can dereference that and Both

04:10:00.400 --> 04:10:04.750
of these should be pointing to the head of
the array. Well, if I run this, I in fact,

04:10:04.750 --> 04:10:09.690
see that I get an error. And the reason for
that is go does not allow math like this to

04:10:09.690 --> 04:10:14.990
be done on pointers. Now, once again, if you've
come from C or c++, you're probably aware

04:10:14.990 --> 04:10:19.530
of the tremendous performance advantages that
you can get if you're allowed to do pointer

04:10:19.530 --> 04:10:24.380
arithmetic, because you can jump around mapped
memory very, very quickly, and gain some pretty

04:10:24.380 --> 04:10:29.380
substantial benefits in the performance of
certain applications. However, whenever you

04:10:29.380 --> 04:10:34.150
get into pointer arithmetic, you're typically
getting into some fairly complicated code.

04:10:34.150 --> 04:10:39.530
And since go has as one of its core design
concerns simplicity, the decision was made

04:10:39.530 --> 04:10:44.460
to leave pointer arithmetic out of the go
language. Now, if you absolutely need to have

04:10:44.460 --> 04:10:48.410
something like this in your application, then
what I would suggest is you can come into

04:10:48.410 --> 04:10:54.030
the go packages and come down here to the
unsafe package. And this is going to give

04:10:54.030 --> 04:10:58.521
you operations that the go runtime is not
going to check for you. So if you really need

04:10:58.521 --> 04:11:02.600
to do pointer arithmetic and things like that,
then the unsafe package, which has a very

04:11:02.600 --> 04:11:07.510
appropriate name is available for you for
those very advanced scenarios. Now, those

04:11:07.510 --> 04:11:11.290
scenarios are advanced enough that what I'm
going to suggest is if you need to know it,

04:11:11.290 --> 04:11:15.560
you're going to learn it. But generally, you're
not going to need to know how this stuff works.

04:11:15.560 --> 04:11:19.450
Now the next thing that I want to show you
is how we can actually create pointer types.

04:11:19.450 --> 04:11:24.040
So we've seen this address of operator and
that's allowing us to instantiate a pointer

04:11:24.040 --> 04:11:28.910
to a certain variable. So if we look at the
type of B, it's actually a pointer to an integer

04:11:28.910 --> 04:11:32.961
because we're pointing to one element in the
array. But so far, we've had to declare the

04:11:32.961 --> 04:11:37.830
underlying type first. Well, that's actually
not necessary and go because often, you only

04:11:37.830 --> 04:11:42.660
want to work with the pointers, and you don't
really care where the underlying data is stored,

04:11:42.660 --> 04:11:47.570
you just need the ability to point to it wherever
it's at. So in this example, we see how we

04:11:47.570 --> 04:11:52.340
can do that. Now we've seen almost exactly
the same syntax before, because when we were

04:11:52.340 --> 04:11:56.800
talking about structs, we had an example that
looks something like this. So we were declaring

04:11:56.800 --> 04:12:02.141
my struct object, we were instantiating it
using the object initialization syntax. And

04:12:02.141 --> 04:12:07.140
when we print everything out, we print the
value 42 out. Now if I make this MSX variable,

04:12:07.140 --> 04:12:12.700
a pointer to a my struct, and then use the
address of operator in this object initializer,

04:12:12.700 --> 04:12:17.810
then I actually get almost the same behavior,
except for notice that when I print out the

04:12:17.810 --> 04:12:22.561
value of MS, I end up with this ampersand
here, which is basically saying that ns is

04:12:22.561 --> 04:12:28.650
holding the address of an object that has
a field with a value 42 in it. Now the advantage

04:12:28.650 --> 04:12:32.730
of being able to do this, it's going to come
to light in a future video. But for now, just

04:12:32.730 --> 04:12:37.750
be aware that you can do this. Now this isn't
the only way that we have available to us

04:12:37.750 --> 04:12:43.770
to initialize a variable to a pointer to an
object, we can also use the built in new function.

04:12:43.770 --> 04:12:48.181
Now unfortunately, with the new function,
we can't use the object initialization syntax,

04:12:48.181 --> 04:12:51.050
we're just going to be able to initialize
an empty object. So if I go ahead and run

04:12:51.050 --> 04:12:56.220
this, we see that we do get an initialized
object. But all of its fields are initialized

04:12:56.220 --> 04:13:01.070
to their zero values, we can't initialize
them using the object initialization syntax.

04:13:01.070 --> 04:13:06.440
Now, since I mentioned zero values, it's important
to understand the zero value for a pointer.

04:13:06.440 --> 04:13:10.560
Because as we talked about, in a very early
video, every variable that you declare in

04:13:10.560 --> 04:13:17.400
go has an initialization value. So right here
after line eight, ns is holding something.

04:13:17.400 --> 04:13:21.261
So the question is, what is that thing? So
if I go ahead and copy this print statement

04:13:21.261 --> 04:13:25.460
up here, we will be able to answer that question.
So let me format this and run it. And then

04:13:25.460 --> 04:13:30.460
we see that we get the special value nil out.
So a pointer that you don't initialize is

04:13:30.460 --> 04:13:34.720
actually going to be an initialized for you.
And it's going to hold this value nil. So

04:13:34.720 --> 04:13:39.790
this is very important to check in your applications.
Because if you're accepting pointers as arguments,

04:13:39.790 --> 04:13:44.061
it is best practice to see if that pointer
is a nil pointer. Because if it is, then you're

04:13:44.061 --> 04:13:47.980
going to have to handle that in a different
way. So for example, if we try and drill through

04:13:47.980 --> 04:13:53.130
and get to this foo field, but and this is
actually nil, then we're going to get a runtime

04:13:53.130 --> 04:13:57.141
exception, and our program is going to crash
on us. Now that actually leads us to an interesting

04:13:57.141 --> 04:14:01.060
point, how do we actually get at this underlying
field and work with it? Well, the obvious

04:14:01.060 --> 04:14:04.740
way that we're going to need to do that is
we're going to have to dereference the ns

04:14:04.740 --> 04:14:08.600
pointer in order to get it that struct, and
then we can get it that field. So we're going

04:14:08.600 --> 04:14:12.620
to have to use something like this. Now, you
might be asking why the prints are there?

04:14:12.620 --> 04:14:16.841
Well, it turns out that the dereferencing
operator actually has a lower precedence than

04:14:16.841 --> 04:14:21.101
the dot operator. So we need to print in order
to make sure that we're dereferencing, the

04:14:21.101 --> 04:14:26.120
MS variable instead of dereferencing, Ms dot
foo. So now we can go ahead and set this to

04:14:26.120 --> 04:14:30.861
the value 42. Now in order to get at the value
of foo, to print it out, then we're going

04:14:30.861 --> 04:14:34.780
to have to repeat the same exercise. So we're
going to add some brands here. I'm going to

04:14:34.780 --> 04:14:38.351
wrap this ms variable, and then we'll print
out the value of foods. So if I go ahead and

04:14:38.351 --> 04:14:44.210
run this, we in fact, do set and get the value
42, which is the value of that field. Now

04:14:44.210 --> 04:14:48.551
I hope you'll agree with me at this point
that this syntax is really ugly, because we

04:14:48.551 --> 04:14:52.860
use this syntax every time we dereference
a pointer, we're going to have to use match

04:14:52.860 --> 04:14:58.820
that a params and have this dereference operator.
Well it turns out because of the limitations

04:14:58.820 --> 04:15:03.471
that are put on point Here's the compiler
is actually able to help us out a little bit.

04:15:03.471 --> 04:15:08.830
So in fact, we don't need this syntax at all.
If we go ahead and remove this and remove

04:15:08.830 --> 04:15:13.060
this from the print statement as well, and
run this, we actually get exactly the same

04:15:13.060 --> 04:15:17.640
behavior. Now again, if you're coming from
a language, which makes extensive use of pointers,

04:15:17.640 --> 04:15:21.460
this is probably freaking you out. Because
the pointer and s

04:15:21.460 --> 04:15:26.160
doesn't actually have a field foo on it. The
pointer MS is pointing to a structure that

04:15:26.160 --> 04:15:31.740
has a field foo. So how is this working? Well,
again, this is just syntactic sugar. This

04:15:31.740 --> 04:15:36.720
is just the compiler helping us out because
it understands or not actually trying to access

04:15:36.720 --> 04:15:41.860
the Foo field on the pointer, we're implying
that we want the underlying object. And so

04:15:41.860 --> 04:15:46.470
go is going to go ahead and interpret that
properly for us, and dereference, the pointer.

04:15:46.470 --> 04:15:50.850
So the compiler really sees this statement
the same as this statement, they're exactly

04:15:50.850 --> 04:15:54.970
the same to the compiler, it's just one reads
a little bit more cleanly. Now, the last thing

04:15:54.970 --> 04:15:59.240
that I want to talk about today is how go
handles variables when they're assigned one

04:15:59.240 --> 04:16:03.811
to another. So let me go ahead and paste this
example in here. As you can see, on line eight,

04:16:03.811 --> 04:16:08.080
we're initializing an array. On line nine,
we're initializing another variable and pointing

04:16:08.080 --> 04:16:12.110
it in the same array as a, then I'm going
to print out both A and B. And then I'm going

04:16:12.110 --> 04:16:17.761
to change index one of the A array to 42,
and print them out again. Now, we've already

04:16:17.761 --> 04:16:21.780
done this example in the past, and hopefully
you remember that a is going to change but

04:16:21.780 --> 04:16:27.980
B is not because b is a copy of the array
that we stored in a and so they update independently

04:16:27.980 --> 04:16:33.760
of each other. However, if I remove this index,
and turn this into a slice, the behavior changes

04:16:33.760 --> 04:16:40.210
a little bit. If we run this, now we see that
both A and B are changed together. So what

04:16:40.210 --> 04:16:45.101
happened there? Well, the slice is copied
just like the array, but the effect of the

04:16:45.101 --> 04:16:49.560
copying is a little bit different. Because
in the version with an array, the values of

04:16:49.560 --> 04:16:54.100
the array are actually considered intrinsic
to the variable. So A is holding the values

04:16:54.100 --> 04:16:58.521
of the array, as well as the size of the array
and that size is held that way we can do bounds

04:16:58.521 --> 04:17:01.771
checking. So for example, if we asked for
index three, which is beyond the bounds of

04:17:01.771 --> 04:17:06.851
this array, and run, we can do bounds checking
in the go language. And that's a very good

04:17:06.851 --> 04:17:12.761
thing. However, with slices, remember, a slice
is actually a projection of an underlying

04:17:12.761 --> 04:17:20.240
array. And so the slice doesn't contain the
data itself, the slice contains a pointer

04:17:20.240 --> 04:17:25.550
to the first element that the slice is pointing
to on the underlying array. So what that means

04:17:25.550 --> 04:17:31.820
is that when we work with slices, the internal
representation of a slice actually has a pointer

04:17:31.820 --> 04:17:38.391
to an array. So while line nine is still copying
the slice a into the slice B, part of the

04:17:38.391 --> 04:17:43.310
data that gets copied is a pointer, not the
underlying data itself. What that basically

04:17:43.310 --> 04:17:47.250
means is, when you're sharing slices in your
application, you're actually always going

04:17:47.250 --> 04:17:51.480
to be pointing at that same underlying data.
Now, the other built in type that has this

04:17:51.480 --> 04:17:57.860
behavior is a map. Because maps, once again,
have a pointer to the underlying data, they

04:17:57.860 --> 04:18:02.060
don't actually contain the underlying data
in themselves. So if I take this example,

04:18:02.060 --> 04:18:06.311
where I'm initializing a map of strings to
strings and assigning that to a, and then

04:18:06.311 --> 04:18:11.250
B is assigned to a, then I print them both
out, then I change one of the values in a

04:18:11.250 --> 04:18:16.420
and print them out again, if I run this, we
see that both maps start out the same. And

04:18:16.420 --> 04:18:21.440
then when I change the key foo in the map,
a we actually change that in the map B as

04:18:21.440 --> 04:18:25.410
well. So what does that mean? Well, what it
means is, when you're working with slices

04:18:25.410 --> 04:18:29.570
and maps in a go application, you have to
be very, very careful to keep in mind at all

04:18:29.570 --> 04:18:35.090
times who's got access to that underlying
data. Because passing slices and maps around

04:18:35.090 --> 04:18:40.480
in your application can get you into situations
where data is changing in unexpected ways.

04:18:40.480 --> 04:18:44.960
However, if you're working with the other
data types, specifically primitives, arrays,

04:18:44.960 --> 04:18:49.690
or structs, then this generally isn't going
to happen to you because when you copy a struct,

04:18:49.690 --> 04:18:54.101
it's actually going to copy the entire structure
unless you're using pointers. Okay, so that

04:18:54.101 --> 04:18:58.311
wraps up what I have to talk about with pointers.
Let's head into a summary and review what

04:18:58.311 --> 04:19:02.480
we've talked about in this video. In this
video, we talked about pointers and how to

04:19:02.480 --> 04:19:07.750
use them in the go language. Now, we haven't
seen a lot of practical application for pointers

04:19:07.750 --> 04:19:11.771
yet. But we need to understand what pointers
are. Before we get into that. So over the

04:19:11.771 --> 04:19:15.430
next couple of videos, we'll get into why
you would want to use pointers and the benefits

04:19:15.430 --> 04:19:19.920
of them. But for now, we're just trying to
introduce the basic subject. So we started

04:19:19.920 --> 04:19:25.630
by learning how to create pointers. And we
learned that if we prefix a type with an asterisk,

04:19:25.630 --> 04:19:29.590
that's actually going to declare that type
to be a pointer to that underlying data type.

04:19:29.590 --> 04:19:34.270
So for example, we have this asterisk int,
which is going to be a pointer to an integer.

04:19:34.270 --> 04:19:38.690
We also learned how we can create pointers
using the address of operator to get the address

04:19:38.690 --> 04:19:43.570
of an existing variable in memory. Then we
learned about dereferencing pointers and how

04:19:43.570 --> 04:19:48.320
we can use that asterisk operator again, but
this time in front of a pointer instead of

04:19:48.320 --> 04:19:53.960
in front of a type and use that to drill through
the pointer to get at the value that the pointer

04:19:53.960 --> 04:19:58.430
is pointing to. We also learned that when
you're working with complex types, such as

04:19:58.430 --> 04:20:03.760
pointers to structs those pointers are automatically
going to be dereferenced for us. So our syntax

04:20:03.760 --> 04:20:08.360
doesn't get cluttered up by a whole bunch
of dereference, operations and parenthesis,

04:20:08.360 --> 04:20:12.480
then we moved on to learn how to create pointers
to objects. And we learned that there's a

04:20:12.480 --> 04:20:17.270
couple of different ways. So the first thing
that we can do is use that address of operator

04:20:17.270 --> 04:20:21.500
to get access to a pointer to an object that
we've already created. So in this example,

04:20:21.500 --> 04:20:25.810
we've got an instance of a my struct object
called Ms. And then we can use that address

04:20:25.810 --> 04:20:31.440
of operator to create a pointer p to that
struct. But we can also do that directly.

04:20:31.440 --> 04:20:36.710
So if we proceed an object initializer, with
that address of operator, then we can actually

04:20:36.710 --> 04:20:40.610
directly create a pointer. And we don't have
to have an intermediate variable that's holding

04:20:40.610 --> 04:20:45.700
that value, we can also use the new keyword
to initialize an object, but we can't initialize

04:20:45.700 --> 04:20:49.142
the fields at the same time. So the behavior
is a little bit different, because we're going

04:20:49.142 --> 04:20:53.040
to have to use the new keyword that's going
to zero out all the fields in a struct, for

04:20:53.040 --> 04:20:56.990
example. And then we're going to have to come
in later and initialize all the values. The

04:20:56.990 --> 04:21:01.460
last thing that we talked about was types
with internal pointers. And we saw how while

04:21:01.460 --> 04:21:06.031
they're treated exactly as any other variable
type, when we do an assignment, their behavior

04:21:06.031 --> 04:21:11.650
is a little bit different. So all assignment
operations and go are copy operations. So

04:21:11.650 --> 04:21:17.011
whenever you have a variable a and you create
a variable b and set it equal to a, all the

04:21:17.011 --> 04:21:21.930
data in a is going to be copied in order to
create B. However, slices and maps contain

04:21:21.930 --> 04:21:26.950
internal pointers. And so even though they're
copying, they're copying pointers, and so

04:21:26.950 --> 04:21:31.290
they're pointing to the same underlying data,
we're going to take a deep dive into functions

04:21:31.290 --> 04:21:35.780
and how you can use them in the go language.
Now, we've been talking about functions throughout

04:21:35.780 --> 04:21:40.080
this entire video series. But we've never
really taken the time to focus on them, because

04:21:40.080 --> 04:21:43.080
there's a lot of groundwork that we've had
to go through building up to the point where

04:21:43.080 --> 04:21:47.380
we can understand what a function is, and
how we can use those in our applications.

04:21:47.380 --> 04:21:50.810
So in today's video, like all of our videos
in this series, I'm going to break the discussion

04:21:50.810 --> 04:21:55.790
down into multiple parts. We'll start by talking
about the basic syntax of a function. Then

04:21:55.790 --> 04:22:00.340
we'll talk about the parameters that you can
pass into a function to influence how it works.

04:22:00.340 --> 04:22:03.960
Then we'll talk about the return values that
you can get back out of the function. We'll

04:22:03.960 --> 04:22:08.790
talk about something called an anonymous function.
We'll talk about how functions in the go language

04:22:08.790 --> 04:22:12.870
are first class citizens and can be passed
around in your application like any other

04:22:12.870 --> 04:22:16.811
variable, and then we'll wrap up our discussion
by talking about a special kind of function

04:22:16.811 --> 04:22:22.830
called a method. Okay, so let's get started
by learning the basic syntax of a function.

04:22:22.830 --> 04:22:27.061
To start our discussion of functions, we don't
have to go any farther than the basic application

04:22:27.061 --> 04:22:31.200
that the NGO playground gives us. So as soon
as you come into the playground, you're presented

04:22:31.200 --> 04:22:36.171
with this very simple application. And right
here, we have our first function. Now, the

04:22:36.171 --> 04:22:40.190
way that a go application is structured, is
you always have to have an entry point in

04:22:40.190 --> 04:22:44.850
the application. And the entry point of go
application is always in package main. And

04:22:44.850 --> 04:22:48.620
within that main package, you have to have
a function called main that takes no parameters

04:22:48.620 --> 04:22:53.330
and returns no values. So we can see that
right here. And so when we run the application,

04:22:53.330 --> 04:22:58.140
the application actually starts right here.
And so we print out the string, hello playground.

04:22:58.140 --> 04:23:02.690
And that's all that our application has to
do. So every NGO application starts this way.

04:23:02.690 --> 04:23:07.780
And we see here the most basic function that
we can create in the go language. So there

04:23:07.780 --> 04:23:11.330
are several major parts that we need to understand
about a function. First of all, they start

04:23:11.330 --> 04:23:14.620
with the func keyword. So as you can see here,
we're not going to start with function or

04:23:14.620 --> 04:23:18.670
anything else, we start with the func keyword,
and that's going to describe a function that

04:23:18.670 --> 04:23:22.950
we're going to create. Then we have the name
of the function that we're going to create.

04:23:22.950 --> 04:23:26.620
And this follows the same naming convention
as any other variable and go see you're going

04:23:26.620 --> 04:23:31.130
to use Pascal case or camel case for the names
of your functions. And depending on if you

04:23:31.130 --> 04:23:35.920
have an uppercase or lowercase determines
the visibility of that function. So just like

04:23:35.920 --> 04:23:39.390
with variables, and uppercase first letter
is going to be published from the package,

04:23:39.390 --> 04:23:43.550
so anything else can use it, and a lowercase
function name is going to be kept internal

04:23:43.550 --> 04:23:47.401
to the package. Now after the name of the
function, we have these match params here

04:23:47.401 --> 04:23:51.900
now we'll see as we get into parameters, what
these are for, but this is required syntax

04:23:51.900 --> 04:23:55.920
after the main function. So even if you don't
take any parameters in your function, you

04:23:55.920 --> 04:24:00.090
have to have these match params. And then
the actual body of the function is contained

04:24:00.090 --> 04:24:04.400
within these curly braces here. Now there
are a lot of holy wars and a lot of languages

04:24:04.400 --> 04:24:08.720
about where these curly braces should go.
So some languages put them here, some languages

04:24:08.720 --> 04:24:12.800
put them down here, some languages like to
indent them, there's all sorts of different

04:24:12.800 --> 04:24:16.800
conventions about where to put these curly
braces. Well, in the go language, there aren't

04:24:16.800 --> 04:24:21.830
any arguments because this is the convention
that is enforced by the compiler itself. So

04:24:21.830 --> 04:24:26.460
you have to put the opening curly brace on
the same line as the func keyword. And then

04:24:26.460 --> 04:24:30.641
the closing curly brace generally has to be
on its own. Now there are a couple of situations

04:24:30.641 --> 04:24:34.620
where you can have that closing curly brace
combined with a couple of other params. And

04:24:34.620 --> 04:24:38.641
we'll talk about that a little bit later in
this video. But generally speaking, when you're

04:24:38.641 --> 04:24:43.580
defining a function, the closing curly brace
has to be on its own line. Now, with functions

04:24:43.580 --> 04:24:48.380
defined like this, the execution path is static,
we can't actually influence what our functions

04:24:48.380 --> 04:24:52.780
doing from the outside, because we're not
passing any information into it. So if we

04:24:52.780 --> 04:24:56.830
do want to pass information into it, then
we're going to provide what are called parameters

04:24:56.830 --> 04:25:01.271
into the function. So let me just drop an
example that uses parameters. And you see

04:25:01.271 --> 04:25:06.650
here a main function is now calling into another
function called say message. And that same

04:25:06.650 --> 04:25:12.101
message function takes in this parameter MSG,
that's of type string. So when you're defining

04:25:12.101 --> 04:25:16.770
a function that takes parameters, the parameters
go between these two parenthesis here. And

04:25:16.770 --> 04:25:19.490
they're described like any other variable
declaration, except for you don't need the

04:25:19.490 --> 04:25:22.620
var keyword. So you're going to have the name
of the parameter, and you're going to have

04:25:22.620 --> 04:25:26.680
the type of the parameter. So then when we
want to call that function, we have to pass

04:25:26.680 --> 04:25:30.860
in the value for that parameter. And that's
called an argument. So we're going to pass

04:25:30.860 --> 04:25:34.860
in the argument Hello, go. And then inside
of our function, we're printing out the message

04:25:34.860 --> 04:25:40.181
that gets passed in. And so when we run this,
we see that Hello go prints out as a result.

04:25:40.181 --> 04:25:44.710
Now this MSG parameter isn't special in any
other way than the fact that it's passed into

04:25:44.710 --> 04:25:48.760
the function, it's treated as a local variable,
just like any other local variable that we

04:25:48.760 --> 04:25:54.330
might create. So if we created another variable
here, and we said, Hello, go, that's treated

04:25:54.330 --> 04:25:59.020
exactly the same way as our mystery variable.
So the only difference between the two is

04:25:59.020 --> 04:26:03.280
the MSG variable can be passed in from the
outside. And of course, that greeting variable

04:26:03.280 --> 04:26:07.891
was created locally. Now, you aren't constrained
to just pass a single parameter in, you can

04:26:07.891 --> 04:26:12.920
actually pass multiple parameters in. So if
I drop in this example, we can see that in

04:26:12.920 --> 04:26:17.240
action. So here, I've extended the same message
function to take two parameters. So I've still

04:26:17.240 --> 04:26:21.900
got the message parameter that's of type string.
And then I've put this comma here, and I've

04:26:21.900 --> 04:26:24.860
added another parameter, and that's going
to be an index. And that's going to be of

04:26:24.860 --> 04:26:29.221
type integer here. So as you can see, we can
pass as many parameters as we want, we're

04:26:29.221 --> 04:26:33.550
just going to provide a comma delimited list
of those parameter names and their types.

04:26:33.550 --> 04:26:38.310
So then when we call the function, we're going
to pass in one value for each one of those

04:26:38.310 --> 04:26:41.860
parameters. And they have to be in the same
order that they're declared. So the first

04:26:41.860 --> 04:26:45.110
argument that we're going to be passing is
the string hello, go, which is going to match

04:26:45.110 --> 04:26:49.510
this MSG variable. And then we're going to
pass in the I that's going to be the loop

04:26:49.510 --> 04:26:54.370
counter here. And that's going to be passed
into this ID x parameter. So then, in this

04:26:54.370 --> 04:26:57.071
function, we're just going to print out the
value of the message and then we're going

04:26:57.071 --> 04:27:01.681
to say what index we receive. So when we run
this, we see that the message prints out five

04:27:01.681 --> 04:27:05.920
times. And we get the same message, but the
index variable changes because we're passing

04:27:05.920 --> 04:27:10.110
in a different value every time we call the
function. Now, often, when you're defining

04:27:10.110 --> 04:27:13.680
a function, you're going to pass in multiple
parameters of the same type. So you're going

04:27:13.680 --> 04:27:18.970
to be tempted to have syntax like this. So
in this example, we've got a slightly different

04:27:18.970 --> 04:27:22.600
function. So instead of a generic, say, Hello,
we're going to have a say greeting function.

04:27:22.600 --> 04:27:25.460
And we're going to provide the greeting that
we're going to have and the name of whoever

04:27:25.460 --> 04:27:29.460
it is we're going to greet. So in this case,
we're passing in the string hello, and the

04:27:29.460 --> 04:27:34.290
string Stacy. So when we run this, we're gonna
say hello to Stacey. Now, since these types

04:27:34.290 --> 04:27:38.740
are the same, the go compiler actually provides
us a little bit more syntactic sugar, because

04:27:38.740 --> 04:27:43.010
this is a little bit more verbose than is
strictly necessary. So instead of specifying

04:27:43.010 --> 04:27:47.590
the type every time, we can actually just
specify a comma delimited list of variables,

04:27:47.590 --> 04:27:50.910
and then the type at the end. And what the
compiler is going to do is, it's going to

04:27:50.910 --> 04:27:55.880
infer that every variable that's in that comma
delimited, list has the same type. So when

04:27:55.880 --> 04:28:00.800
we run this, we actually get exactly the same
execution. But we just have a little bit more

04:28:00.800 --> 04:28:06.610
terse syntax. Now, so far, we've been passing
parameters in as value types. If you remember

04:28:06.610 --> 04:28:10.021
from our last discussion, we were talking
about pointers. And notice that I don't have

04:28:10.021 --> 04:28:14.631
any pointers in our function signatures right
now. So let me drop in this example here.

04:28:14.631 --> 04:28:17.750
And then we can start playing around with
the difference between passing in values and

04:28:17.750 --> 04:28:22.120
passing in pointers. So when I have this example
here, and I run it, we get exactly the same

04:28:22.120 --> 04:28:26.530
output that we had before. But I've got some
variables that I'm using to pass in as arguments

04:28:26.530 --> 04:28:30.730
to this function. Now, what do you think is
going to happen if I change the value of one

04:28:30.730 --> 04:28:34.970
of these variables inside the function, so
for example, if I change the name variable

04:28:34.970 --> 04:28:40.390
to Ted, and let's go ahead and print that
out, just to verify that it printed. And then

04:28:40.390 --> 04:28:44.921
what do you think is going to happen if I
print the same variable out, again, right

04:28:44.921 --> 04:28:51.870
here. So I'm passing in the name variable
by value. So that means that the go runtime

04:28:51.870 --> 04:28:56.771
is going to copy the data that's in this name
variable and provided to here. So what we

04:28:56.771 --> 04:29:00.390
would expect is when we change the value of
the name variable right here, it should have

04:29:00.390 --> 04:29:05.090
an effect. And we should print 10 out here.
But since this is a copy of the name variable,

04:29:05.090 --> 04:29:08.990
we actually shouldn't have any effect out
here. So if we run this, we see that in fact,

04:29:08.990 --> 04:29:13.950
that is true. So this is a safe way to pass
data into a function, you can be assured by

04:29:13.950 --> 04:29:18.880
passing by value, that the data is not going
to be changed when you pass it in. Now, if

04:29:18.880 --> 04:29:24.610
I change this to passing in pointers, by adding
a pointer here, and then passing in the address

04:29:24.610 --> 04:29:29.870
of these variables right here, and then dereferencing,
the pointers right here, then let's see what's

04:29:29.870 --> 04:29:34.590
going to happen. Actually, I need to add another
dereference right here. And now we're passing

04:29:34.590 --> 04:29:40.910
pointers to our variables around in our application.
So now, instead of working with a copy of

04:29:40.910 --> 04:29:46.490
the name variable, we're working with a pointer
to the name variable. And so when we run this,

04:29:46.490 --> 04:29:51.141
we actually see looks like I missed a dereference
operation right here. And now we see that

04:29:51.141 --> 04:29:56.010
we have in fact, change the variable not only
in the scope of the function, but in the calling

04:29:56.010 --> 04:30:01.240
scope as well. So by passing in a pointer,
we have in fact manipulated that parameter

04:30:01.240 --> 04:30:05.710
that we passed in. Now, why would you want
to do this? Well, there's a couple of reasons.

04:30:05.710 --> 04:30:09.540
First of all, a lot of times our functions
do need to act on the parameters that are

04:30:09.540 --> 04:30:14.080
passed into them. And so passing in pointers
is really the only way to do that. The other

04:30:14.080 --> 04:30:19.280
reason is passing in a pointer is often much,
much more efficient than passing in a whole

04:30:19.280 --> 04:30:22.931
value. Because right now we're passing in
simple strings, and strings aren't that large

04:30:22.931 --> 04:30:26.700
and ghost, so passing in copies versus passing
in pointers is pretty much going to be the

04:30:26.700 --> 04:30:31.721
same in terms of performance. However, if
you're passing in a large data structure,

04:30:31.721 --> 04:30:35.790
then passing in the value of that data structure
is going to cause that entire data structure

04:30:35.790 --> 04:30:40.700
to be copied every single time. So in that
case, you might decide to pass in a pointer

04:30:40.700 --> 04:30:44.590
simply for a performance benefit. Now, you
do have to be a little careful when you're

04:30:44.590 --> 04:30:48.980
passing in pointers, because of course, you
can inadvertently change that value. And so

04:30:48.980 --> 04:30:52.921
you can cause some issues for yourself. Now,
just to remind you of something else that

04:30:52.921 --> 04:30:57.490
we talked about in the pointer discussion,
if you're working with maps or slices, then

04:30:57.490 --> 04:31:00.960
you don't really have this option, because
since those two types have internal pointers

04:31:00.960 --> 04:31:04.690
to their underlying data, then they're always
going to act like you're passing pointers

04:31:04.690 --> 04:31:09.760
in. So just be careful when you're using those
data structures. Because you can inadvertently

04:31:09.760 --> 04:31:14.511
change the data in your calling function,
when you're manipulating them within the calling

04:31:14.511 --> 04:31:15.511
function.

04:31:15.511 --> 04:31:18.360
The last thing that I want to talk about when
we're working with parameters are what are

04:31:18.360 --> 04:31:22.511
called variadic parameters. So if I drop in
this example, here, we can see an example

04:31:22.511 --> 04:31:26.920
of a variadic parameter. So in this case,
I've got a generic some function that I'm

04:31:26.920 --> 04:31:31.590
creating here, and I'm passing in the numbers
one through five. Now, I'm not receiving five

04:31:31.590 --> 04:31:36.061
variables here, instead, I've got one variable
here, and I've preceded its type with these

04:31:36.061 --> 04:31:41.990
three dots here. So what that's done is that's
told the go runtime to take in all of the

04:31:41.990 --> 04:31:46.630
last arguments that are passed in, and wrap
them up into a slice that has the name of

04:31:46.630 --> 04:31:50.650
the variable that we have here. So then inside
of the sum function, we're going to print

04:31:50.650 --> 04:31:54.570
out what that values object is just so we
can see that and then we're going to go ahead

04:31:54.570 --> 04:31:58.641
and add up all the values in there. So since
it's going to act like a slice, we can use

04:31:58.641 --> 04:32:02.660
a for loop and range over those values. And
then we're going to print out the result of

04:32:02.660 --> 04:32:07.910
that. So when we run this, we see that we
do in fact, have a slice is printed out, the

04:32:07.910 --> 04:32:12.980
sum is 15. So we got that result printed out
properly. And there's no problem at all. Now,

04:32:12.980 --> 04:32:17.120
when you're using a variadic parameter, you
can only have one and it has to be the last

04:32:17.120 --> 04:32:22.681
one. So if I, for example, want to have a
custom message string, I can pass that in,

04:32:22.681 --> 04:32:28.950
and then pass that in here and then replace
this. And this still works just fine. However,

04:32:28.950 --> 04:32:34.130
I couldn't, for example, put the message parameter
as the last parameter, because the runtime

04:32:34.130 --> 04:32:38.590
doesn't have the ability to understand where
the variadic parameters and and where additional

04:32:38.590 --> 04:32:42.710
parameters would begin. So if you're using
variadic parameters, you can only have one

04:32:42.710 --> 04:32:47.360
and a half to be at the end. Okay, now, it's
nice to be able to pass data into our function,

04:32:47.360 --> 04:32:51.271
because now depending on the different data
that I pass in, I can change the behavior

04:32:51.271 --> 04:32:56.130
of the function. But it's also very useful
to be able to use our functions to do some

04:32:56.130 --> 04:33:00.620
work, and then return a result back to the
calling function. So in order to do that,

04:33:00.620 --> 04:33:04.301
we're going to use what are called return
values. So if I dropped in this example, we

04:33:04.301 --> 04:33:08.561
see it's basically the same as our last example.
But instead of printing the message in the

04:33:08.561 --> 04:33:13.590
sum function, we're returning the result out.
And then the main function is actually working

04:33:13.590 --> 04:33:17.879
with that. So there's a change we had to make
in our function signature. So right here after

04:33:17.879 --> 04:33:22.859
the parameter list, and before the opening
curly brace, I've listed the return values

04:33:22.859 --> 04:33:27.869
type. So in this case, I'm expecting to return
an integer. So I just put it right here, inside

04:33:27.869 --> 04:33:31.590
of my function, I'm going to use the return
keyword. And then I'm going to return the

04:33:31.590 --> 04:33:35.139
value of the variable that I've been building
up throughout the course of the function.

04:33:35.139 --> 04:33:39.479
So in this case, I declare the result variable
here, I populated in this loop. And then I

04:33:39.479 --> 04:33:44.049
return that result back now up here in the
main function, I can catch that return value

04:33:44.049 --> 04:33:49.379
by declaring a variable and setting it equal
to the result of this function. So S is actually

04:33:49.379 --> 04:33:53.590
going to be an integer type, because that's
what was returned out of this function. And

04:33:53.590 --> 04:33:57.479
then I can work with that integer. So if I
run this, I get exactly the same behavior

04:33:57.479 --> 04:34:01.549
that I had before. But now the sum function
is more of a pure function, it doesn't care

04:34:01.549 --> 04:34:05.469
what I do with that result, it's just going
to generate the result and return it back

04:34:05.469 --> 04:34:09.760
to the caller. Now another feature that go
has that's actually pretty rare in a lot of

04:34:09.760 --> 04:34:14.600
languages, is the ability to return a local
variable as a pointer. So in our previous

04:34:14.600 --> 04:34:20.510
example, when we return that result, go actually
copied that result to another variable, and

04:34:20.510 --> 04:34:25.270
that's what got assigned. But we can also
do this. So if you look here, I'm returning

04:34:25.270 --> 04:34:29.869
a pointer to an integer now. And instead of
returning the result, I'm returning the address

04:34:29.869 --> 04:34:34.930
of the result. And so S is now a pointer.
So I change to a dereference operation. So

04:34:34.930 --> 04:34:39.420
if I run this, it works exactly the same way.
Now again, if you're coming from another language

04:34:39.420 --> 04:34:44.059
that uses pointers a lot and doesn't abstract
away the differences between working on the

04:34:44.059 --> 04:34:48.270
stack and working on the heap, then this might
freak you out a little bit, because when we

04:34:48.270 --> 04:34:53.420
declare the result variable, it's actually
declared on the execution stack of this function,

04:34:53.420 --> 04:34:57.359
which is just a special section of memory
that's set aside for all of the operations

04:34:57.359 --> 04:35:01.680
that this function is going to be working
with. So in this funk Exit, then execution

04:35:01.680 --> 04:35:06.180
stack is destroyed, that memory is freed up.
And so in a lot of languages, this is not

04:35:06.180 --> 04:35:10.420
a safe operation, because now you're returning
a pointer to a location in memory that just

04:35:10.420 --> 04:35:14.869
got freed. And so you've got no idea what
value is going to be there.

04:35:14.869 --> 04:35:20.648
Well, in the go language, when it recognizes
that you're returning a value that's generated

04:35:20.648 --> 04:35:25.229
on the local stack, it's automatically going
to promote this variable for you to be on

04:35:25.229 --> 04:35:29.059
the shared memory in the computer, what's
also called the heap memory. So you don't

04:35:29.059 --> 04:35:32.549
have to worry about this value being cleared,
the runtime is going to recognize that you're

04:35:32.549 --> 04:35:36.660
returning a pointer from the local stack,
and everything is going to work for you just

04:35:36.660 --> 04:35:40.520
fine. And that makes a lot of things more
convenient. Because within the function, we

04:35:40.520 --> 04:35:44.490
can work with this as a true value. So we
don't have to worry about dereferencing pointers,

04:35:44.490 --> 04:35:48.221
and then just right at the end, we can return
the address of the result. And the runtime

04:35:48.221 --> 04:35:52.359
makes it all work for us. Another thing that
we can do in the go language, and this isn't

04:35:52.359 --> 04:35:57.570
done very often, but there are cases where
it is valuable is using named return values.

04:35:57.570 --> 04:36:02.209
So if I drop in this example here, notice
that I've changed my return value. Now I've

04:36:02.209 --> 04:36:07.068
got a set of parenthesis here. And then I've
got a name for the return value and a type

04:36:07.068 --> 04:36:12.561
for it. So when you do this, this is basically
syntactic sugar for declaring a result variable.

04:36:12.561 --> 04:36:16.670
So this variable is going to be available
in the scope of our sum function. And then

04:36:16.670 --> 04:36:20.449
that value is going to be implicitly returned.
So we can work with that result variable right

04:36:20.449 --> 04:36:24.600
here within our function. And then we don't
have to specify the name of the return variable

04:36:24.600 --> 04:36:29.279
down here in line 17, we just have to tell
it to return. So when we run this, we see

04:36:29.279 --> 04:36:33.730
that once again, we get exactly the same behavior.
But the body of our sum function is actually

04:36:33.730 --> 04:36:37.459
quite a bit cleaner, because we don't have
to do the maintenance of instantiating, this

04:36:37.459 --> 04:36:42.068
result variable. Now, this is actually not
done very often in the go language. And my

04:36:42.068 --> 04:36:46.988
suspicion is because it can be a little bit
confusing to read, because your return variables

04:36:46.988 --> 04:36:51.639
are declared way up here at the top of the
function, and your actual return is down here

04:36:51.639 --> 04:36:54.479
at the bottom. So if you're reading this code,
and you're trying to figure out what this

04:36:54.479 --> 04:36:58.689
function is actually going to return, you
have to come all the way back up to the function

04:36:58.689 --> 04:37:03.059
signature. So this can be a very valuable
technique to use. But I would be very careful

04:37:03.059 --> 04:37:07.230
with it. Because if you've got long functions,
the named result parameters can actually be

04:37:07.230 --> 04:37:11.568
more confusing instead of less confusing.
So you have the option there, pick whichever

04:37:11.568 --> 04:37:15.569
one makes the most sense for your application.
The last thing that I want to talk about with

04:37:15.569 --> 04:37:20.189
return values is the fact that we can do multiple
return values from a function. So in order

04:37:20.189 --> 04:37:23.799
to show you why this is valuable, let's take
this example here. So I've created a simple

04:37:23.799 --> 04:37:28.379
divide function that takes in two parameters
A and B, that are float 64, it's going to

04:37:28.379 --> 04:37:33.889
divide them and it's going to return that
result back. So if I run this, I get 1.6 666.

04:37:33.889 --> 04:37:39.340
Like you might expect, and everything's fine.
But what happens if I pass in a zero here.

04:37:39.340 --> 04:37:44.090
Now when I run this, I get an unknown result,
I get a positive infinity result. And I can't

04:37:44.090 --> 04:37:48.270
work with that in my application. So I'm going
to probably cause some sort of a failure down

04:37:48.270 --> 04:37:52.529
the line. So in a lot of languages, the only
thing we could do is throw an exception or

04:37:52.529 --> 04:37:57.379
panic the application and go when we detect
that there's this invalid value for the parameter

04:37:57.379 --> 04:38:02.250
B. So I guess we could do that we could add
some kind of logic here. If b equals equals

04:38:02.250 --> 04:38:11.539
0.0, then we're going to panic and we're going
to say, cannot provide zero as second value.

04:38:11.539 --> 04:38:15.689
And that would work. But keep in mind when
we talk about control flow and go, we don't

04:38:15.689 --> 04:38:19.969
want to panic our application as a general
course of action, because panicking means

04:38:19.969 --> 04:38:24.779
the application cannot continue. Now, in fact,
this application cannot continue if somebody

04:38:24.779 --> 04:38:29.850
provides the value of beat. But it's reasonable
to assume that we might pass zero in for this

04:38:29.850 --> 04:38:34.568
be parameter occasionally. So instead of doing
this, what we actually want to do is return

04:38:34.568 --> 04:38:40.090
an error back letting the calling function
know something that they asked it to do wasn't

04:38:40.090 --> 04:38:44.350
able to be done properly. So instead of doing
this, we're actually going to add a second

04:38:44.350 --> 04:38:48.328
return variable. So to do that, we're going
to add a print here. And we're going to return

04:38:48.328 --> 04:38:52.328
an object of type error, and then close that
parenthesis off. So we can return as many

04:38:52.328 --> 04:38:57.670
values as we want from a function. But this
is a very idiomatic way of using the go language.

04:38:57.670 --> 04:39:01.969
So we're going to return the intention of
the function as the first return value. And

04:39:01.969 --> 04:39:05.900
then we're going to return an error object
in case something went wrong. So in that case,

04:39:05.900 --> 04:39:09.869
what we're going to do is, we're going to
remove this panic, because we really don't

04:39:09.869 --> 04:39:14.289
want to be doing that. And we're going to
return the first value, we're just going to

04:39:14.289 --> 04:39:18.629
zero it out, because we can't do this operation,
so we can't return anything meaningful. And

04:39:18.629 --> 04:39:22.350
then we're going to return an error object.
Now you can generate one of those by using

04:39:22.350 --> 04:39:28.160
the air f function. And we can say cannot
divide by zero. So we're going to provide

04:39:28.160 --> 04:39:32.199
a value for that error. And then that's all
we need to do here. So since we've returned

04:39:32.199 --> 04:39:36.641
to this function in the error case, then if
we get past it, we can continue as if our

04:39:36.641 --> 04:39:43.040
parameters are okay. And so in that case,
we can actually do our operation. And then

04:39:43.040 --> 04:39:47.150
for the error value, we're going to pass nil
because no error was present. And again, this

04:39:47.150 --> 04:39:51.568
is very idiomatic go, we're going to return
an error value if something went wrong, and

04:39:51.568 --> 04:39:55.250
then we're going to explicitly return nil
if nothing went wrong. And then if you've

04:39:55.250 --> 04:39:58.760
read any amount of go code, you've seen this
quite a few times. We're going to check to

04:39:58.760 --> 04:40:03.228
see if that error also Got our standard if
error is not equal to nil, and then we're

04:40:03.228 --> 04:40:06.988
going to put our error handling logic in here.
So in this case, all we're going to do is

04:40:06.988 --> 04:40:16.520
print out the error and return from our main
function. So we're going to exit our application.

04:40:16.520 --> 04:40:17.520
If we don't have that, then we're going to
just print out the result of our calculation.

04:40:17.520 --> 04:40:20.908
So again, this is a very common pattern and
go inside of your functions that can generate

04:40:20.908 --> 04:40:25.978
errors, you're going to return the expected
value and then an error as the second parameter,

04:40:25.978 --> 04:40:29.378
then you're going to have a guard that's going
to check for those error conditions, you're

04:40:29.378 --> 04:40:34.218
going to return as soon as possible from your
function with the error value if an error

04:40:34.218 --> 04:40:38.158
is present. And the reason for that is we're
going to try and left justify our code as

04:40:38.158 --> 04:40:41.651
much as possible. So we don't end up with
these pyramids of doom, where we're going

04:40:41.651 --> 04:40:45.389
to have else checks. And we do all of our
error checking at the bottom, we're going

04:40:45.389 --> 04:40:49.738
to do our error checking at the beginning
and then return out as soon as possible. So

04:40:49.738 --> 04:40:53.408
if we do get past that, then we're going to
be on our happy path. And we're going to return

04:40:53.408 --> 04:40:58.600
out the result of a calculation and then a
nil error up in the calling function, we're

04:40:58.600 --> 04:41:02.680
going to have the standard test to see if
error is not equal to nil. If it isn't equal

04:41:02.680 --> 04:41:05.998
to nil, then we're going to process that error,
because now we've got something we're going

04:41:05.998 --> 04:41:10.780
to have to deal with. And then again, we don't
have an else block here, we just continue

04:41:10.780 --> 04:41:15.308
moving on, we're going to make sure our error
handling logic either recovers from the error

04:41:15.308 --> 04:41:19.798
or exits onto the function. And that way,
we can keep our main thread of execution left

04:41:19.798 --> 04:41:23.878
justified. So our main thread of execution
here is we're going to call this divide function,

04:41:23.878 --> 04:41:27.920
and then we're going to print out the result.
So any error handling should not force the

04:41:27.920 --> 04:41:32.978
main line of execution to be indented. So
now if we run this, we see that I forgot to

04:41:32.978 --> 04:41:36.700
initialize my error parameter. So let's go
ahead and add that. And this is something

04:41:36.700 --> 04:41:41.828
else I should talk about. When we're receiving
multiple values out of a function call, we

04:41:41.828 --> 04:41:46.548
actually have a common delimited list of those
return values. So this D parameter is going

04:41:46.548 --> 04:41:50.920
to match up to this float 64. And this eerr
parameter is going to match up to this error

04:41:50.920 --> 04:41:54.478
parameter here. So now if I run, everything
should work. And we see that we now get an

04:41:54.478 --> 04:41:59.578
error cannot divide by zero. So our main function
doesn't explode on us, we actually have something

04:41:59.578 --> 04:42:03.558
that we can work with. But if we put in a
valid value, then we're on that other path

04:42:03.558 --> 04:42:08.578
of execution, and we get the return value
back out. Now, so far, we've been treating

04:42:08.578 --> 04:42:13.480
functions as this special thing, because we're
always using this func keyword, we're declaring

04:42:13.480 --> 04:42:17.228
these at the top level of our application,
we're working with them. But functions and

04:42:17.228 --> 04:42:22.910
go are actually more powerful than that. Because
functions themselves can be treated as types,

04:42:22.910 --> 04:42:26.410
they can be passed around as variables, they
can be passed as arguments into functions,

04:42:26.410 --> 04:42:29.600
you can get them as return values, pretty
much anything you can do with any other type

04:42:29.600 --> 04:42:33.580
you can do with functions. So let's take a
look at that a little bit. So in this example,

04:42:33.580 --> 04:42:38.060
I'm actually declaring a function on the fly.
And this is called an anonymous function.

04:42:38.060 --> 04:42:40.950
Now we're going to continue to explore this
over the next couple of minutes. But this

04:42:40.950 --> 04:42:44.670
is the simplest example I can come up with.
So notice that I'm starting with the func

04:42:44.670 --> 04:42:49.378
keyword, I've got the params. For the parameters,
I've got the opening and closing curly brace,

04:42:49.378 --> 04:42:52.968
but I don't have the function name here. So
when you're doing this, this is what's called

04:42:52.968 --> 04:42:57.388
an anonymous function. And this is the basic
structure of a function when you're not working

04:42:57.388 --> 04:43:00.458
with functions in this traditional scope.
But instead you're working with functions

04:43:00.458 --> 04:43:05.440
as types. So inside of my function body, I'm
printing out the message Hello, go. And then

04:43:05.440 --> 04:43:10.500
I've got accompanying my closing curly brace,
these params here. Now these params here are

04:43:10.500 --> 04:43:14.790
basically going to invoke this function. So
this is an immediately invoked function, I'm

04:43:14.790 --> 04:43:19.770
defining it and executing it at exactly the
same time. So when I run this, and actually

04:43:19.770 --> 04:43:24.700
does execute that function, and we get the
value Hello, go printed out. If I don't have

04:43:24.700 --> 04:43:28.828
these friends, then the compiler is a little
confused. It doesn't know what to do with

04:43:28.828 --> 04:43:33.430
this function. It's just defined, but it's
never used anywhere. So fails a compilation

04:43:33.430 --> 04:43:38.708
check. But if I do invoke that function immediately,
then I get this behavior here. Now why would

04:43:38.708 --> 04:43:42.420
you use an anonymous function like this, I
actually have no idea why you would use an

04:43:42.420 --> 04:43:46.888
anonymous function like this. I mean, there
can be situations where you can declare variables

04:43:46.888 --> 04:43:52.228
inside of here. So if I declare a message
variable here, and I set that equal to this

04:43:52.228 --> 04:43:56.488
string, and then print that out, that can
be valuable because you're actually generating

04:43:56.488 --> 04:44:00.770
an isolated scope. So this message variable
is not going to be available in the main function

04:44:00.770 --> 04:44:05.159
is only going to be inside of this anonymous
function here. Now another place that you

04:44:05.159 --> 04:44:09.610
might use this is if we've got a for loop.
So if I start up a simple for loop, and I'll

04:44:09.610 --> 04:44:15.728
just count up to five, and increment by one,
let's see if I can do this on the fly here.

04:44:15.728 --> 04:44:20.100
And then I come in here and I actually print
the value of i out, I'll get rid of this message

04:44:20.100 --> 04:44:23.580
here and I'll print out I, you're going to
get a little bit of strange behavior. If I

04:44:23.580 --> 04:44:27.969
run this, this works, okay. But as we start
getting into asynchronous code, things are

04:44:27.969 --> 04:44:32.510
going to start behaving a little bit oddly.
So we do have access to this AI variable,

04:44:32.510 --> 04:44:36.780
because we're in the scope and the main function.
And so inner functions can actually take advantage

04:44:36.780 --> 04:44:41.590
of variables that are in the outer scope.
But the problem is, if this function is actually

04:44:41.590 --> 04:44:46.658
executing asynchronously, then this counter
variable is going to keep going. And we may

04:44:46.658 --> 04:44:51.218
actually have odd behavior here. So the best
practice is actually to provide a variable

04:44:51.218 --> 04:44:55.718
inside of here and actually pass that AI variable.
And what that's going to do is we're not going

04:44:55.718 --> 04:45:00.200
to be reading from the outer scope anymore.
We're going to be passing that into the function

04:45:00.200 --> 04:45:04.700
execute And that way, even if this is running
asynchronously, we're going to print out the

04:45:04.700 --> 04:45:08.058
value correctly. Now, this works correctly
in the playground, the way that we have this

04:45:08.058 --> 04:45:12.440
right now, because we actually aren't doing
anything asynchronously. This is all synchronous

04:45:12.440 --> 04:45:16.700
execution. And so we are safe to use this
outer counter. But it's not good practice

04:45:16.700 --> 04:45:20.988
to do that. Instead, it is best practice to
pass in that kind of variable. If you need

04:45:20.988 --> 04:45:24.980
that in your inner function. That way, changes
in the outer scope aren't reflected on the

04:45:24.980 --> 04:45:29.658
inner scope. Now taking this a little bit
farther, we can work with functions as variables,

04:45:29.658 --> 04:45:34.128
like I said before, so in this case, I've
declared an anonymous function, and I've assigned

04:45:34.128 --> 04:45:38.620
it to this variable F. And then I can execute
f by just invoking it like any other function.

04:45:38.620 --> 04:45:42.718
So if I call that, we see that we do print
hello, go out. So now that I've got this function

04:45:42.718 --> 04:45:47.498
defined as a variable, it's free to pass around
my application. Now, you might ask yourself,

04:45:47.498 --> 04:45:51.670
what is the signature for this function. So
let's go ahead and go through that. So if

04:45:51.670 --> 04:45:55.580
I get rid of the short syntax and extend this
out a little bit, then I'm going to start

04:45:55.580 --> 04:45:59.950
with the var keyword. And since this is a
very simple function, the type is just like

04:45:59.950 --> 04:46:03.878
this, we have the func keyword, and then an
open and close parenthesis. So the parameter

04:46:03.878 --> 04:46:07.830
is normally going here, I don't have any parameters
here, I don't have any return types. So the

04:46:07.830 --> 04:46:12.600
type signature for this variable is simply
func with two params. There. So if I run this,

04:46:12.600 --> 04:46:17.718
that works just fine. Now we can go a little
bit more complicated. And I'll drop an example

04:46:17.718 --> 04:46:21.320
of that in just to show you how that's going
to look. So in this case, I'm declaring a

04:46:21.320 --> 04:46:25.440
function signature for a divide function,
that's going to take in two floats, and it's

04:46:25.440 --> 04:46:29.690
going to return a float and an error. And
you see, this is the syntax for that. So we

04:46:29.690 --> 04:46:34.738
pass our parameter types in here. And then
we have the return types in params. As well,

04:46:34.738 --> 04:46:38.048
if you have just a single return type, then
you don't need these params, we could just

04:46:38.048 --> 04:46:42.200
put the type there like that. But we do have
that error type this coming back. So we do

04:46:42.200 --> 04:46:46.558
need to include that. And then when I initialize
that variable, I'm going to set it equal to

04:46:46.558 --> 04:46:50.318
an anonymous function that takes a and d.
And this is exactly the same divide function

04:46:50.318 --> 04:46:55.080
that we had before. And I can call that exactly
like we had before. So when I run this, it

04:46:55.080 --> 04:47:00.048
has exactly the same behavior as the last
example we did with the divide function. But

04:47:00.048 --> 04:47:04.260
now we have the divide function declared as
a variable. And we're working with it exactly

04:47:04.260 --> 04:47:08.708
the same way as when we declared it as a function.
Now, the difference between this and when

04:47:08.708 --> 04:47:15.110
we had the divide function declared globally,
is if I try and call it up here and run the

04:47:15.110 --> 04:47:19.680
application, notice that I get an error because
in this case, the function divide hasn't been

04:47:19.680 --> 04:47:24.318
declared yet, because it's declared as a variable.
And so I can't work with it yet. So that's

04:47:24.318 --> 04:47:27.600
just something to be aware of. If you're going
to be working with functions as variables

04:47:27.600 --> 04:47:31.408
like this, make sure that they're defined
before you actually try and execute them.

04:47:31.408 --> 04:47:34.790
Okay, the last thing that I want to talk about
with functions today is working with what

04:47:34.790 --> 04:47:37.888
are called methods. And there's a couple of
things to talk about with those. So let me

04:47:37.888 --> 04:47:41.468
just drop in an example that shows that. And
we can walk through this and then see what

04:47:41.468 --> 04:47:46.260
it's going to do. So in this example, I've
got a struct called greeter that greeter struct

04:47:46.260 --> 04:47:50.700
has two fields greeting and name. And then
I've got this method on it. And we'll come

04:47:50.700 --> 04:47:55.440
back to this in a second. So in my main function,
I'm declaring a greeter struct, and then I'm

04:47:55.440 --> 04:48:00.590
calling this function preceding it with the
struct that I have here. And this is how we're

04:48:00.590 --> 04:48:04.770
going to do method invocation. So we call
the method just like we were accessing a field,

04:48:04.770 --> 04:48:08.068
except for we have the params here where we
can pass some arguments in. Now my method

04:48:08.068 --> 04:48:14.160
declaration down here looks a lot like a function
except for it's got this odd bit right here.

04:48:14.160 --> 04:48:18.638
And this is what makes this function into
a method. So a method is basically just a

04:48:18.638 --> 04:48:24.780
function that's executing in unknown context,
and unknown context. And go is any type. Now

04:48:24.780 --> 04:48:28.780
it's very common that we can use structs.
But you can use any type. So we can make a

04:48:28.780 --> 04:48:33.530
type for an integer. So maybe we have a type
for an integer called counter. And then we

04:48:33.530 --> 04:48:39.138
can add methods on to that counter type, and
work with those. So when we declare that method,

04:48:39.138 --> 04:48:42.600
we're actually going to get access to that
type right here in this part. So what's going

04:48:42.600 --> 04:48:46.930
to happen when we call the greet method is
the greet method is going to get a copy of

04:48:46.930 --> 04:48:51.748
the greeter object. And that's going to be
given the name g in the context of this method.

04:48:51.748 --> 04:48:56.558
So then when we print out, we can access the
fields on that greeter object. So we can print

04:48:56.558 --> 04:48:59.620
out the greeting and the name. So when we
go ahead and run this, we see that we get

04:48:59.620 --> 04:49:03.620
Hello go printed out. And that's the basics
of a method. So methods are basically the

04:49:03.620 --> 04:49:07.888
same as functions, they just have this little
bit of syntactic sugar, that's providing a

04:49:07.888 --> 04:49:12.540
context that that function is executing in.
And when we do that, we call that a method.

04:49:12.540 --> 04:49:17.828
Now when we use this syntax right here, notice
that we're specifying greeter as a value type,

04:49:17.828 --> 04:49:22.350
we don't have a pointer here. So this is what's
called a value receiver. The received object

04:49:22.350 --> 04:49:26.958
in this greet method is the value greeter.
So what that means is just like any other

04:49:26.958 --> 04:49:31.648
time that we're working with values, we are
getting a copy of the struct, we're not actually

04:49:31.648 --> 04:49:35.068
going to get the struct itself. So if I change
the value of the Name field here, and then

04:49:35.068 --> 04:49:40.078
I print the Name field out of here, so I say
the new name is and then I print the Name

04:49:40.078 --> 04:49:44.110
field out, then it's no big surprise that
even though I assigned an empty string to

04:49:44.110 --> 04:49:47.930
the Name field here, up here in the main function,
it didn't have any effect. Because down here

04:49:47.930 --> 04:49:51.818
in this method, we're operating on a copy
of the greeter object. We're not operating

04:49:51.818 --> 04:49:55.638
on the greeter object itself. So again, that's
very valuable if you want your methods to

04:49:55.638 --> 04:50:00.590
be able to access the data of their parent
type without being able to manipulate Just

04:50:00.590 --> 04:50:04.310
keep in mind there is a cost with that. So
if there's greeter object was a very large

04:50:04.310 --> 04:50:08.020
struck, then we would be creating a copy of
that struct every time we invoke this method.

04:50:08.020 --> 04:50:12.208
Now, as you might expect, there's another
option that we have here. And that is to pass

04:50:12.208 --> 04:50:17.510
in what's called a pointer receiver. So if
we make this a pointer, and run the application,

04:50:17.510 --> 04:50:22.388
again, now we're actually able to manipulate
that underlying data. So we're going to print

04:50:22.388 --> 04:50:27.058
out Hello ghosts. So the method operates in
exactly the same way. And we don't have to

04:50:27.058 --> 04:50:31.290
change the format here, because we do have
that implicit dereferencing of pointers that's

04:50:31.290 --> 04:50:35.808
working for us. But now when I change the
value of the Name field, and print the Name

04:50:35.808 --> 04:50:39.468
field out up here, we do in fact, see that
we've been able to reassign the value of that

04:50:39.468 --> 04:50:44.208
field. Okay, so that covers working with functions
in the go language. Let's go into a summary

04:50:44.208 --> 04:50:48.648
and review what we've talked about. In this
video, we talked about functions and how to

04:50:48.648 --> 04:50:52.398
use them in the go language. And we started
out by talking about the basic syntax of a

04:50:52.398 --> 04:50:56.090
function, and we saw that this is about as
simple of a function as we can get. So we

04:50:56.090 --> 04:51:00.170
start with the func keyword, we have a name
for that function. And again, if that first

04:51:00.170 --> 04:51:03.930
letter is uppercase, then that function is
going to be published and allowed to be executed

04:51:03.930 --> 04:51:08.208
from outside of the package. But with a lowercase
first letter, it's going to be kept internal

04:51:08.208 --> 04:51:12.738
to the package, then we follow with a match
set of parenthesis, and then we have an open

04:51:12.738 --> 04:51:16.620
and closed curly brace. Now the open curly
brace has to be on the same line as the func

04:51:16.620 --> 04:51:20.718
keyword. And the closed curly brace has to
be on its own line after the final statement

04:51:20.718 --> 04:51:24.708
of the function, then we moved on to talk
about parameters and parameters allow us to

04:51:24.708 --> 04:51:29.568
pass data into the function to influence how
that function executes, basically providing

04:51:29.568 --> 04:51:34.148
some variables for the function that are passed
in from the outside. So we talked about how

04:51:34.148 --> 04:51:39.700
parameters are passed in as a common delimited
list of the name of the parameter and the

04:51:39.700 --> 04:51:43.978
type of the parameter. So we see here we're
passing into the Foo function, two parameters,

04:51:43.978 --> 04:51:48.238
the bar parameter that says type string, and
the bass parameter that's of type integer

04:51:48.238 --> 04:51:52.610
parameters of the same type can be comma delimited.
And the type can be listed at the end there.

04:51:52.610 --> 04:51:56.489
So in this case, we're passing in bar and
Babs as parameters. And both of those are

04:51:56.489 --> 04:51:59.180
going to be of type integer.

04:51:59.180 --> 04:52:03.040
When pointers are passed in the function contains
the value in the caller. So by default, we're

04:52:03.040 --> 04:52:07.458
going to be passing in the values themselves.
And so the go runtime is going to be copying

04:52:07.458 --> 04:52:11.740
that data and passing it into the function.
So any changes that are made inside of the

04:52:11.740 --> 04:52:16.398
function aren't going to be reflected in the
color scope. However, if you pass in a pointer,

04:52:16.398 --> 04:52:20.208
then you are going to be able to manipulate
the value inside of your function. And that

04:52:20.208 --> 04:52:24.148
will have an effect in the calling scope.
So the only exception to this rule is when

04:52:24.148 --> 04:52:28.048
you're working with slices and maps, since
they work with internal pointers, any changes

04:52:28.048 --> 04:52:32.530
inside of the function to the underlying data
is always going to be reflected inside of

04:52:32.530 --> 04:52:36.530
the calling scope. We also talked about how
you can use variadic parameters to send a

04:52:36.530 --> 04:52:41.950
list of the same types in, so it must be the
last parameter in the parameter list. It's

04:52:41.950 --> 04:52:46.100
received inside of the function as a slice.
And you see an example of the syntax right

04:52:46.100 --> 04:52:50.850
here. So we've got the function foo. It has
one parameter bar that's of type string, and

04:52:50.850 --> 04:52:56.020
then a parameter Baz, that's a very attic
parameter of integers. So inside of this food

04:52:56.020 --> 04:52:59.628
function, we're going to have a slice called
Baz. And that's going to contain all of the

04:52:59.628 --> 04:53:04.190
integers that have been passed in. Once your
function finishes doing its work, a lot of

04:53:04.190 --> 04:53:07.610
times we want it to return a value back out.
And in order to get that information back

04:53:07.610 --> 04:53:12.161
out, we're going to use return values. So
if you have a single return value, all you

04:53:12.161 --> 04:53:16.750
need to do is list the type. So in this case,
our foo function needs to return an integer,

04:53:16.750 --> 04:53:20.730
we can also specify multiple return values.
So if we're going to do that, we need to put

04:53:20.730 --> 04:53:24.478
parentheses around the types that we're going
to be returning. So in this example, we're

04:53:24.478 --> 04:53:28.530
going to be returning an integer and an error.
And this is a very common pattern that you're

04:53:28.530 --> 04:53:32.790
going to see in NGO applications where we're
going to have our functions return the intended

04:53:32.790 --> 04:53:37.620
value, and then an error value that's going
to let the caller know if anything went wrong.

04:53:37.620 --> 04:53:41.318
That way, the function itself doesn't have
to determine whether the application needs

04:53:41.318 --> 04:53:45.680
to panic, or execution can't continue. It
just knows it wasn't able to do what it was

04:53:45.680 --> 04:53:50.658
asked to do. And then it can delegate what
that error means to the application to the

04:53:50.658 --> 04:53:55.780
calling function, you can also use named return
values. So when you do that, instead of just

04:53:55.780 --> 04:53:59.920
providing the types in the return last, you're
going to provide the name of that return value.

04:53:59.920 --> 04:54:04.450
So when you do that, the runtime is going
to initialize that value for you to the zero

04:54:04.450 --> 04:54:08.690
value for that variable. And when you use
the return keyword, all you need to do is

04:54:08.690 --> 04:54:13.748
enter return on its own go is going to find
the current value of those returned variables.

04:54:13.748 --> 04:54:17.100
And that's what's going to be returned out
of your function. Another special behavior

04:54:17.100 --> 04:54:22.010
of go is you can actually return the addresses
and local variables as return values, and

04:54:22.010 --> 04:54:25.700
those are going to be treated properly. So
when you do that those variables are automatically

04:54:25.700 --> 04:54:30.871
promoted from local memory or stack memory
up into shared memory or heap memory. So you

04:54:30.871 --> 04:54:35.580
don't have to worry about those values being
cleared out as the function stack memory is

04:54:35.580 --> 04:54:40.180
reclaimed. We then started talking about anonymous
functions. And we talked about a couple of

04:54:40.180 --> 04:54:44.180
different uses for those. So we have this
immediately invoked function, which really

04:54:44.180 --> 04:54:47.780
isn't used too often in the go language, but
it's as simple of an anonymous function as

04:54:47.780 --> 04:54:51.910
I could get. The only potential advantage
that you have here is you can create an inner

04:54:51.910 --> 04:54:55.458
scope. So local variables that are created
inside of this anonymous function aren't going

04:54:55.458 --> 04:54:59.260
to be available outside, but I haven't seen
that very often. It's not going to be very

04:54:59.260 --> 04:55:03.068
often that you're going need to use this kind
of a function, then we also talked about how

04:55:03.068 --> 04:55:07.330
we can take that anonymous function and actually
assign that to a variable. So in this example,

04:55:07.330 --> 04:55:12.010
we've got the variable a assigned to the value
of that function. And then we can invoke the

04:55:12.010 --> 04:55:17.070
a function just like any other function. The
only difference between this and the normal

04:55:17.070 --> 04:55:23.228
declaration of a function is that the a function
can only be invoked after it's been declared.

04:55:23.228 --> 04:55:28.388
So when you declare a function using the traditional
syntax, it's actually declared at the time

04:55:28.388 --> 04:55:32.708
that the package is initialized. And so it's
always available to you. When you're using

04:55:32.708 --> 04:55:37.048
this syntax, you have to make sure that a
is initialized before you can call it extending

04:55:37.048 --> 04:55:41.808
on that discussion about the ability to assign
functions to variables, functions, or types,

04:55:41.808 --> 04:55:46.298
just like any other type in go language, anytime
you can use a primitive or a slice or an array

04:55:46.298 --> 04:55:50.100
or a map, you can use a function. So you can
assign them to variables, you can use them

04:55:50.100 --> 04:55:54.138
as arguments, they can even be returned values
from functions, then we also talked about

04:55:54.138 --> 04:55:58.478
how since a function is a type, we have to
have the ability to create a type signature.

04:55:58.478 --> 04:56:02.298
So if you're declaring anonymous functions,
it's often most convenient just to use that

04:56:02.298 --> 04:56:06.878
colon equals syntax and declare your anonymous
function and the type is going to be inferred.

04:56:06.878 --> 04:56:11.388
However, if you're using a function as a parameter
to another function, or the return value from

04:56:11.388 --> 04:56:15.478
a function, then you're going to need to specify
that type signature. So we see an example

04:56:15.478 --> 04:56:19.990
here. In this case, we've got the definition
of a function f. And that function is going

04:56:19.990 --> 04:56:23.798
to take three parameters, two strings, and
an integer. And then it's going to return

04:56:23.798 --> 04:56:27.870
an integer and an error type. So it's basically
the same as when you're declaring a function

04:56:27.870 --> 04:56:32.290
normally, the only difference is we don't
have the names for those variables. Because

04:56:32.290 --> 04:56:35.500
those names will be provided when we actually
implement the function, we just need to know

04:56:35.500 --> 04:56:39.218
the types that are coming in, and the types
that are coming out at this point. The last

04:56:39.218 --> 04:56:43.808
thing we talked about were methods, and how
method is a special type of function that

04:56:43.808 --> 04:56:48.548
executes in the context of a type. Now a type
doesn't have to be a struct. Although that

04:56:48.548 --> 04:56:53.820
definitely is a very common use case for methods,
you can actually attach a method to any custom

04:56:53.820 --> 04:56:58.578
type. So you can create a type of an integer,
and then you can add methods on to that integer.

04:56:58.578 --> 04:57:03.040
When we create a method, we're going to use
a modified version of the basic function syntax.

04:57:03.040 --> 04:57:07.298
So before the name of the function, and after
the func keyword, we're going to provide another

04:57:07.298 --> 04:57:10.970
set of parentheses, we're going to provide
a local name for the type that's going to

04:57:10.970 --> 04:57:14.980
receive that method. And then we're going
to follow that with that method type. Now,

04:57:14.980 --> 04:57:20.378
that variable is what's called the receiver
for the method. So in this case, our G variable

04:57:20.378 --> 04:57:24.010
is what's called a value receiver, which means
we're going to get a copy of that greeter

04:57:24.010 --> 04:57:28.260
object. And that's going to be passed into
the greet method. However, we can also use

04:57:28.260 --> 04:57:33.250
what are called pointer receivers. So by adding
an asterisk in front of that greeter type,

04:57:33.250 --> 04:57:36.720
the method is going to change. So instead
of passing a copy of the greeter, we're going

04:57:36.720 --> 04:57:40.260
to get a pointer to the greeter object in
there. And then any manipulations we make

04:57:40.260 --> 04:57:44.450
to the greeter object in the greet method
are going to be reflected throughout your

04:57:44.450 --> 04:57:47.760
application. Now, that's very powerful if
you need the method to be able to manipulate

04:57:47.760 --> 04:57:53.148
the state of the object. It's also much more
efficient if you're dealing with large structures,

04:57:53.148 --> 04:57:56.770
because instead of copying the entire structure,
it only has to copy a pointer. And that's

04:57:56.770 --> 04:58:00.670
normally a much more efficient operation,
I want to talk about one of the coolest features

04:58:00.670 --> 04:58:05.910
of the go language. And that is interfaces.
Now I know that interfaces are normally considered

04:58:05.910 --> 04:58:09.990
pretty humble features, and they sit in the
background. It's much more fun to talk about

04:58:09.990 --> 04:58:14.421
go routines and channels, especially when
you're learning to go language. But I would

04:58:14.421 --> 04:58:19.318
argue that the way interfaces are implemented
in the go language are potentially one of

04:58:19.318 --> 04:58:23.700
the reasons why go applications tend to be
as maintainable and scalable as they have

04:58:23.700 --> 04:58:28.218
proven to be. So we're going to start this
conversation like we start every conversation

04:58:28.218 --> 04:58:32.738
by introducing the basics. So we'll learn
what an interface is and how to use them in

04:58:32.738 --> 04:58:37.488
the language itself. Then we'll move on to
discuss how to compose interfaces together.

04:58:37.488 --> 04:58:42.020
Now, just like in other high level languages,
such as Java, or C sharp, we can actually

04:58:42.020 --> 04:58:46.600
make interfaces of interfaces. And we'll talk
about how to do that, and why that's a very

04:58:46.600 --> 04:58:51.260
good thing to do when you're writing your
applications. Then we'll talk about type conversion.

04:58:51.260 --> 04:58:55.510
Now, we've touched on this a little bit before
in a previous video. But when we talk about

04:58:55.510 --> 04:59:00.310
interfaces, things changed a little bit, and
it's worth revisiting the topic. Along the

04:59:00.310 --> 04:59:04.648
way, we're going to talk about the empty interface,
which is a very useful general construct that

04:59:04.648 --> 04:59:08.610
we're going to deal with in our programming.
We'll also revisit type switches, which we've

04:59:08.610 --> 04:59:13.798
talked about before, and we'll revisit them
in the context of our interface discussion.

04:59:13.798 --> 04:59:17.398
Then we'll talk about how to implement interfaces.
And there's actually two different ways that

04:59:17.398 --> 04:59:22.128
you can do that. One is by implementing with
value type, and one is by implementing with

04:59:22.128 --> 04:59:25.440
a pointer. And we'll talk about some of the
subtle differences that you're going to run

04:59:25.440 --> 04:59:30.770
into as you implement interfaces with these
two different types. And then finally, we're

04:59:30.770 --> 04:59:34.790
going to talk about some best practices that
have been discovered over the last few years

04:59:34.790 --> 04:59:39.718
of working with the go language about how
to use interfaces in your actual production

04:59:39.718 --> 04:59:44.030
applications. Okay, so let's get started by
learning the basics of using interfaces in

04:59:44.030 --> 04:59:49.540
go. So to start our discussion about interfaces,
I'm going to actually build our first application

04:59:49.540 --> 04:59:53.998
up a piece at a time now often I just drop
in code and talk about it. But I want to take

04:59:53.998 --> 04:59:58.898
this one step at a time so that we're working
together and understanding what's going on.

04:59:58.898 --> 05:00:02.750
So the first thing that we're going to do
is we're going to introduce our first interface.

05:00:02.750 --> 05:00:08.070
So interfaces are a type, just like structs
or type aliases. So we're going to start with

05:00:08.070 --> 05:00:12.620
the type keyword, then we're going to enter
the name of our interface. And then the type

05:00:12.620 --> 05:00:16.728
that we're creating is a type interface. And
then we're going to surround the definition

05:00:16.728 --> 05:00:20.930
of this interface with curly braces, just
like we do when we're defining a struct. Now

05:00:20.930 --> 05:00:25.478
with a struct, we would add in here, the data
that we want that struct to hold on to because

05:00:25.478 --> 05:00:30.520
structs are ultimately data containers. And
so that's how we work with them. interfaces

05:00:30.520 --> 05:00:37.048
don't describe data, interfaces describe behaviors.
So instead of entering a bunch of data types

05:00:37.048 --> 05:00:40.548
that we're going to be storing inside of a
writer interface here, we're actually going

05:00:40.548 --> 05:00:45.888
to be storing method definitions. So I want
to create a write method here. And this is

05:00:45.888 --> 05:00:49.950
actually an interface from the IO package,
we're just going to be working with it here

05:00:49.950 --> 05:00:54.718
as if we created it. But this is exactly the
same interface that you would find in the

05:00:54.718 --> 05:00:58.770
IO package under the writer interface. So
this method is going to accept a slice of

05:00:58.770 --> 05:01:04.048
bytes. And then it's going to return an integer
and an error. Now on the writer interface,

05:01:04.048 --> 05:01:08.350
the way this works is anything that implements
this interface is going to take in that slice

05:01:08.350 --> 05:01:14.398
of bytes, write it to something that something
might be the console, it might be a TCP connection,

05:01:14.398 --> 05:01:18.128
it might be the file system, we don't know,
we just know that we're writing a slice of

05:01:18.128 --> 05:01:22.388
bytes to something. And then the integer and
error that get returned, of course, the error

05:01:22.388 --> 05:01:26.680
is there in case something goes wrong with
the write operation. And the integer is normally

05:01:26.680 --> 05:01:30.570
the number of bytes written. So now that we
have the interface defined, let's go ahead

05:01:30.570 --> 05:01:34.950
and implement it. So we're going to implement
this with a console writer implementation,

05:01:34.950 --> 05:01:39.808
and that'll be a struct. And that's all we
need to do with the struct definition. Now,

05:01:39.808 --> 05:01:44.040
if you come from another language, you might
be looking for an implements keyword or something

05:01:44.040 --> 05:01:49.291
like that. Well, in go, we don't actually
explicitly implement interfaces, we're going

05:01:49.291 --> 05:01:54.298
to implicitly implement the interface. And
we're going to do that by actually creating

05:01:54.298 --> 05:02:00.130
a method on our console writer that has the
signature of a writer interface. So let me

05:02:00.130 --> 05:02:04.078
just drop that in. Because if I try and type
all this out, I will screw it up, and then

05:02:04.078 --> 05:02:08.090
I'll have bugs that I have to go through.
So it's much easier just to drop it in. But

05:02:08.090 --> 05:02:11.798
notice what I've done here, I've got a method
on my console writer called write. So it's

05:02:11.798 --> 05:02:16.561
got the same name as my writer interface,
it's accepting a slice of bytes, and it's

05:02:16.561 --> 05:02:20.700
returning an integer and an error. Now the
implementation is whatever I want it to be.

05:02:20.700 --> 05:02:24.750
Now, in this case, all I'm going to do is
convert that byte slice into a string and

05:02:24.750 --> 05:02:29.218
printed onto the console to keep things easy
in the playground. But I can have my writer

05:02:29.218 --> 05:02:31.110
do whatever I want.

05:02:31.110 --> 05:02:36.908
So what's the value of doing this? Well, the
value of doing this is up in my main method,

05:02:36.908 --> 05:02:42.100
I can actually create a variable that's of
type writer. And let me just drop that code

05:02:42.100 --> 05:02:49.248
in and format it and set that equal to a console
writer instance. So the W variable here is

05:02:49.248 --> 05:02:53.748
holding a writer, which is something that
implements the writer interface. I don't actually

05:02:53.748 --> 05:02:58.040
know the concrete type, though. So when I
call the write method down here on line nine,

05:02:58.040 --> 05:03:03.648
I know how to call that because that's defined
by the interface. But I don't actually know

05:03:03.648 --> 05:03:08.298
in my main function, what's being written
to, that's the responsibility of the actual

05:03:08.298 --> 05:03:14.208
implementation. So I could replace this with
a TCP writer, I could replace it with a file

05:03:14.208 --> 05:03:18.138
writer, I could replace it with any other
kind of writer. And so I get what's called

05:03:18.138 --> 05:03:25.318
a polymorphic behavior. Why nine doesn't care
what it's writing to, I specify that behavior

05:03:25.318 --> 05:03:30.798
before that. But then anything that's going
to use this w object just knows that it can

05:03:30.798 --> 05:03:34.558
write to it. And so it can take advantage
of that behavior. So if I go ahead and run

05:03:34.558 --> 05:03:39.440
this application, you see that I do get a
logo printed out to the console, just like

05:03:39.440 --> 05:03:44.820
I would expect. So the key takeaway here as
we're learning the basics of interfaces, is

05:03:44.820 --> 05:03:50.180
this concept of implicit implementation. And
so what that means, for example, is if you

05:03:50.180 --> 05:03:55.298
need to wrap a concrete type, and somebody
hasn't published an interface, you can actually

05:03:55.298 --> 05:04:00.240
create an interface that their type implements.
So we did it the other way, we created an

05:04:00.240 --> 05:04:04.270
interface, and then we created a concrete
type that implemented it. But there's nothing

05:04:04.270 --> 05:04:10.440
to say we can't go the other way around. We
could, for example, go to if I travel to go

05:04:10.440 --> 05:04:16.290
lang.org, and go into packages, this is actually
something that I just ran into, in order to

05:04:16.290 --> 05:04:22.158
test SQL database connections. So if I come
down to the database package, and go into

05:04:22.158 --> 05:04:27.980
the SQL package, if we look at this, notice
that the DB type is a struct. So we don't

05:04:27.980 --> 05:04:33.308
have an interface here. So if our go application
is talking to a SQL database, we've got concrete

05:04:33.308 --> 05:04:38.708
types all over the place. So for our transactions,
we're interacting with this DB object. everything

05:04:38.708 --> 05:04:43.908
that we're doing sending SQL statements making
queries are all through this concrete DB object.

05:04:43.908 --> 05:04:48.280
So how do I test that without a database?
Well, the way that you test that without a

05:04:48.280 --> 05:04:53.878
database is you actually create an interface
that replicates this method signature, and

05:04:53.878 --> 05:04:59.200
the DB object from the SQL package will automatically
implement it, so I don't have to worry about

05:04:59.200 --> 05:05:04.890
creating inner phases at design time if I
don't need them myself, because consumers

05:05:04.890 --> 05:05:09.761
of my library or whatever I'm creating can
always create interfaces later. And their

05:05:09.761 --> 05:05:14.978
interfaces can be shaped to exactly what they
need for their application. Now another thing

05:05:14.978 --> 05:05:18.870
that I want to talk about before I move on
here is a naming convention. Now obviously,

05:05:18.870 --> 05:05:22.360
the name of the interface should represent
what that interface is going to be doing for

05:05:22.360 --> 05:05:27.548
you. And there is one special case, if you've
got single method interfaces, which are very

05:05:27.548 --> 05:05:32.798
common in the go language, then the convention
is to name the interface with the method name

05:05:32.798 --> 05:05:37.370
plus er. So if we're defining an interface,
like we have here with the right method, then

05:05:37.370 --> 05:05:41.030
the interface name should be writer, if we're
going to create an interface with a read method

05:05:41.030 --> 05:05:45.308
on it, then the interface name should be a
reader. Now if you got more than one method

05:05:45.308 --> 05:05:49.410
in the interface, things can get a little
bit more challenging. But at the end of the

05:05:49.410 --> 05:05:53.680
day, you should name your interface by what
it does. And in the case of a single method

05:05:53.680 --> 05:05:58.331
interface, just add er onto the end of the
method name. Okay, now, in this example, we

05:05:58.331 --> 05:06:02.160
use the struct, which is probably one of the
most common ways to implement interfaces,

05:06:02.160 --> 05:06:06.908
but you don't need to any type that can have
a method associated with it can implement

05:06:06.908 --> 05:06:11.780
an interface. And as we've talked about before,
any type can have methods associated with

05:06:11.780 --> 05:06:16.400
it. So in order to demonstrate that, let me
just drop in this example here. Now in line

05:06:16.400 --> 05:06:20.940
16, through 18, I've defined a new interface
called incrementer. And that increment is

05:06:20.940 --> 05:06:25.120
going to be a method that only returns an
integer, so it's going to increment something.

05:06:25.120 --> 05:06:30.320
So whatever we're going to implement this
thing with, is going to increment values.

05:06:30.320 --> 05:06:36.920
So down here on line 20, I defined the type
alias for an integer called an int counter.

05:06:36.920 --> 05:06:41.908
And then I added a method to that custom type
on lines 22 through 25. And that's going to

05:06:41.908 --> 05:06:47.080
be my implementation for the incrementer interface.
So the method name is called increment, and

05:06:47.080 --> 05:06:51.090
it's going to return an integer. Now, in this
case, look at what I'm doing, I'm actually

05:06:51.090 --> 05:06:56.620
incrementing. The type itself, since I've
got a type alias for an integer, it's a number,

05:06:56.620 --> 05:07:00.128
so I can go ahead and increment that. And
then I'm going to return it as the result

05:07:00.128 --> 05:07:01.930
of this method call.

05:07:01.930 --> 05:07:06.700
So I've actually got a type defined on an
integer, and the integer itself is storing

05:07:06.700 --> 05:07:11.568
the data that the method is using. So up here
in my main function, I'm going to go ahead

05:07:11.568 --> 05:07:15.690
and create that integer counter. And I have
to cast an integer to an encounter. In order

05:07:15.690 --> 05:07:20.940
to do that. That's what I'm doing here on
line eight. And then I create my incrementer

05:07:20.940 --> 05:07:24.440
and assign that to a pointer of the my ns
object. And we'll talk about why that has

05:07:24.440 --> 05:07:28.010
to be a pointer toward the end of this video.
And then I'm just going to loop from zero

05:07:28.010 --> 05:07:31.700
to nine. And I'm going to print out the value
of the increment method every time I call

05:07:31.700 --> 05:07:36.260
it. So if I go ahead and run this, I see no
big surprise, I get the values one through

05:07:36.260 --> 05:07:41.138
10 printed out. So what's the takeaway here?
Well, you don't have to use structs. To implement

05:07:41.138 --> 05:07:45.708
interfaces, you can use any kind of custom
type. Now I couldn't add a method directly

05:07:45.708 --> 05:07:50.700
to the entity type. Because the event type
isn't under my control that's defined in another

05:07:50.700 --> 05:07:54.708
package. It's a matter of fact, that's a primitive
type, and you can't modify it. But any type

05:07:54.708 --> 05:07:59.200
that I do have control over that I can create,
I can add methods to it. And if I can add

05:07:59.200 --> 05:08:03.228
methods to it, I can implement interfaces
with it. Now the next thing that I want to

05:08:03.228 --> 05:08:08.078
talk about is how to compose interfaces together.
Because this is another very powerful concept

05:08:08.078 --> 05:08:12.990
in the go language, and is one of the keys
to scalability, because if you remember I

05:08:12.990 --> 05:08:17.390
mentioned a little while ago, single method
interfaces are very common and very powerful

05:08:17.390 --> 05:08:22.920
in the language, because they define a very
specific behavior. But by having a single

05:08:22.920 --> 05:08:26.680
method, they don't have a lot of opinions.
And so they can be implemented in a lot of

05:08:26.680 --> 05:08:32.318
ways. So for example, the IO dot writer interface
is one of the most common interfaces in the

05:08:32.318 --> 05:08:37.170
entire go language, because all it does is
talk about how to write two things. And we

05:08:37.170 --> 05:08:42.470
write two things all the time. So by taking
as little opinion as possible, we actually

05:08:42.470 --> 05:08:46.730
make the interface very, very powerful and
very, very useful. So let me go ahead and

05:08:46.730 --> 05:08:51.850
paste this example here. Because what happens
if we need more than one method, but we can

05:08:51.850 --> 05:08:56.930
decompose the interfaces down. So in this
case, I've created an interface that's composed

05:08:56.930 --> 05:09:01.408
of other interfaces. So I've got my writer
interface that we started the video with.

05:09:01.408 --> 05:09:04.048
And then I've added this closer interface
that just has

05:09:04.048 --> 05:09:08.730
a closed method on it, and returns an error
just in case something happened when we tried

05:09:08.730 --> 05:09:14.548
to call this method. Now the writer closer
interface is actually composed of the writer

05:09:14.548 --> 05:09:19.260
interface and the closer interface. And this
is done exactly the same way that you do embedding

05:09:19.260 --> 05:09:25.530
with structs. We're just embedding interfaces
within other interfaces. So the writer closer

05:09:25.530 --> 05:09:31.830
is going to be implemented. If an object has
this method on it, and this method on it,

05:09:31.830 --> 05:09:36.420
then we can treat that as a writer closer.
So as an example, I've created this struct

05:09:36.420 --> 05:09:41.350
here, a buffered writer closer. Now, I'm not
saying that this is an efficient way of doing

05:09:41.350 --> 05:09:45.950
things. This is just an example of how you
might use this writer closer interface in

05:09:45.950 --> 05:09:49.440
a way that runs in the playground easily.
So in this case, I've got my write method

05:09:49.440 --> 05:09:53.530
that I'm going to be implementing. And what
I decided to do is I'm going to write out

05:09:53.530 --> 05:09:58.030
whatever gets sent into the buffered writer
closer. I'm going to print that out to the

05:09:58.030 --> 05:10:04.068
console in eight increments. So that's what
all this code is doing, when you pass data

05:10:04.068 --> 05:10:09.370
into the write method, it's going to store
that in this internal buffer that the structure

05:10:09.370 --> 05:10:14.190
defines. And then as long as the buffer has
more than eight characters, it's going to

05:10:14.190 --> 05:10:18.208
go ahead and write that out. But it won't
write anything out if it's got less than eight

05:10:18.208 --> 05:10:22.700
characters. So we're basically buffering the
data that we're sending in. And then down

05:10:22.700 --> 05:10:26.648
here in the close method, I've got to implement
that too. And so what we're gonna do there

05:10:26.648 --> 05:10:30.850
is we're going to flush the rest of the buffer.
So I'm pulling the next eight characters out.

05:10:30.850 --> 05:10:35.158
And I'm going to write that out to the console.
And keep doing that until the buffer is empty.

05:10:35.158 --> 05:10:40.828
Okay, up here in the main method, I simply
create a writer closer variable, and define

05:10:40.828 --> 05:10:45.270
that using the new buffered writer closer
function. And just to show you that I didn't

05:10:45.270 --> 05:10:49.640
talk about it, that's down here at the bottom,
that's just a constructor function that's

05:10:49.640 --> 05:10:54.340
returning a pointer to a buffered writer closer.
And I need to do that because I need to initialize

05:10:54.340 --> 05:10:59.228
this internal buffer to a new buffer. So I
have a constructor method there just to make

05:10:59.228 --> 05:11:02.719
sure that everything has been initialized
properly. So if I come back up to the main

05:11:02.719 --> 05:11:07.488
function, and look at that, then I'm going
to call the right method. And I'm converting

05:11:07.488 --> 05:11:11.520
the string hello youtube listeners, this is
a test over to a byte slice, because that's

05:11:11.520 --> 05:11:15.020
what the right method expects. And then I'm
going to call the close method. So if I go

05:11:15.020 --> 05:11:19.718
ahead and run this, you see that I get the
message printed out to the console in eight

05:11:19.718 --> 05:11:25.290
character chunks. And eventually I get all
this printed out. But if I comment out this

05:11:25.290 --> 05:11:31.010
last method, call here, you see that I don't
get the a test part of the string, because

05:11:31.010 --> 05:11:35.558
that's actually a partial. And so we didn't
get that full eight characters that's required

05:11:35.558 --> 05:11:40.670
for the right method to print it out. And
so I didn't actually flush the buffer. Okay.

05:11:40.670 --> 05:11:45.120
So I know that maybe a little bit of a complicated
example, to show a fairly simple thing. But

05:11:45.120 --> 05:11:49.400
I just wanted to show you this is how you
can compose interfaces together. And as long

05:11:49.400 --> 05:11:53.870
as you implement all of the methods on the
embedded interfaces, then you actually implement

05:11:53.870 --> 05:11:58.090
the composed interface as well. The next example
that I want to talk about is how we can do

05:11:58.090 --> 05:12:02.298
type conversion. So I'm going to go ahead
and replace my main function here with this

05:12:02.298 --> 05:12:06.600
code here, get rid of the extra curly brace,
actually, I'm going to get rid of this too,

05:12:06.600 --> 05:12:11.770
I guess I pulled in the whole function signature.
And then I made a little bit of a change down

05:12:11.770 --> 05:12:17.638
here in line 13. So lines nine through 11
are our original implementation, where we're

05:12:17.638 --> 05:12:21.658
creating the new buffered writer closer or
writing a string out, and then we're calling

05:12:21.658 --> 05:12:27.158
the close method on it. But on line 13, I'm
actually doing a type conversion. So using

05:12:27.158 --> 05:12:32.228
this syntax here, where I've got an object,
dot, and then in parentheses, I've got a type

05:12:32.228 --> 05:12:36.719
that I'm going to try and convert this variable
to. And then I can assign that to a variable

05:12:36.719 --> 05:12:42.260
such as this PwC variable right here. Now,
if that succeeds, then everything's fine.

05:12:42.260 --> 05:12:45.420
And I can go ahead and work with it. Now,
there's nothing useful I can do with this.

05:12:45.420 --> 05:12:49.440
But I'm just printing out the variable, because
I have to use the variables and go. So I'm

05:12:49.440 --> 05:12:52.898
just going to go ahead and print that out.
So if I run this, I see I get exactly the

05:12:52.898 --> 05:12:57.978
same output I had before. But now I get the
memory address of this buffered writer closer,

05:12:57.978 --> 05:13:02.568
so that tape conversion succeeded. And therefore
I can work with this no longer as a writer

05:13:02.568 --> 05:13:06.878
closer, but as a buffered writer closer. So
for example, if I needed to access the buffer

05:13:06.878 --> 05:13:10.790
directly, then I would be able to do that
now. Whereas with the writer closer, it's

05:13:10.790 --> 05:13:15.790
not aware of the internal fields of a specific
implementation. And so I wouldn't have access

05:13:15.790 --> 05:13:21.320
to that data. Now there is a problem. However,
if I import the IO package, and try and convert

05:13:21.320 --> 05:13:24.900
this to a type that it doesn't implement.
So for example, if I try and convert this

05:13:24.900 --> 05:13:30.500
over to an IO reader, which is another interface,
and that IO reader interface requires a read

05:13:30.500 --> 05:13:34.899
method on it. So if I try that now, let's
go ahead and run that. And we see here we

05:13:34.899 --> 05:13:39.450
put the application into a state that it can't
manage. And so what it does is whatever good

05:13:39.450 --> 05:13:43.388
go program does, when it can't figure out
what to do it panics. And the panic messages

05:13:43.388 --> 05:13:47.660
interface conversion, it can't figure out
how to cast a buffered writer closer into

05:13:47.660 --> 05:13:52.610
an IO reader. And so it's going to fail on
us. Now, it does give us some useful information

05:13:52.610 --> 05:13:56.568
about why it couldn't do that. It says it's
missing a method read. And then it's gonna

05:13:56.568 --> 05:14:00.830
give us a stack trace letting us know where
that error occurred. Now, this isn't really

05:14:00.830 --> 05:14:05.010
great, because sometimes we need to try and
convert an interface into something else.

05:14:05.010 --> 05:14:08.610
And we're not sure if it's going to work or
not. So it's not going to be good for our

05:14:08.610 --> 05:14:11.648
application to be panicking all the time,
because then we're going to have recovers

05:14:11.648 --> 05:14:15.780
and we're going to be using that as a primary
control flow concept. And we want to avoid

05:14:15.780 --> 05:14:19.388
that in the go language, because panicking
is pretty expensive. So we need another way

05:14:19.388 --> 05:14:24.270
around it. Well, we just so happen have another
way around it. And so I'm going to show you

05:14:24.270 --> 05:14:28.958
that. All we need to do let me rename this
variable, because PwC doesn't make sense for

05:14:28.958 --> 05:14:33.718
a reader anymore. I'm going to paste this
code in. So I'm going to now try and cast

05:14:33.718 --> 05:14:37.620
it to a variable called R. I'm going to do
the same type conversion, but now I'm using

05:14:37.620 --> 05:14:41.658
this comma, okay, syntax. So we've seen this
before, when we were trying to pull a value

05:14:41.658 --> 05:14:45.430
out of a map and we weren't sure if it was
there or not. Well, we have the same ability

05:14:45.430 --> 05:14:50.238
with type conversion. If we add a comma, okay,
this is going to be a Boolean result. And

05:14:50.238 --> 05:14:55.728
then we can test against that to see if we
can work with it. So if the conversion succeeds,

05:14:55.728 --> 05:15:00.059
then we're going to get an okay value back
out. If the conversion fails, then we're Going

05:15:00.059 --> 05:15:04.228
to get the zero value of whatever type we
were trying to convert to. So an IO reader

05:15:04.228 --> 05:15:08.898
is an interface. And so it's zero value is
going to be nil. So if we go ahead and run

05:15:08.898 --> 05:15:14.148
this now, we see that our conversion failed,
but our application didn't crash. If we switch

05:15:14.148 --> 05:15:20.318
this back to a pointer to a buffered writer
closer, let me go ahead and drop that in.

05:15:20.318 --> 05:15:25.148
And we run that we got to drop out our package
here that we're no longer using. And then

05:15:25.148 --> 05:15:29.270
we see that we're back to having things successfully
converted. And we could work with that however

05:15:29.270 --> 05:15:34.770
we needed to. So this is really important
to be aware of, especially if you're not sure

05:15:34.770 --> 05:15:38.510
if you're going to get a pointer or a value
type. So for example, it would be really easy

05:15:38.510 --> 05:15:43.298
to write this and have a problem because we
implemented the interface with a pointer,

05:15:43.298 --> 05:15:47.530
not with the value itself. And so we can't
actually do the conversion to the underlying

05:15:47.530 --> 05:15:51.240
value type. So let's go ahead and run this
again, we see that that all works. And one

05:15:51.240 --> 05:15:55.600
more thing I want to show you let me just
pull this error back up again, you'll notice

05:15:55.600 --> 05:16:00.058
that the reason this type assertion failed
is because buffered writer closer does not

05:16:00.058 --> 05:16:04.958
implement writer closer now that might seem
a little strange to you, because our buffered

05:16:04.958 --> 05:16:09.648
writer closer has a write method, and it has
a closed method, and they have the right signature.

05:16:09.648 --> 05:16:14.260
So for some reason this works when I asked
it to convert it to a pointer, but it doesn't

05:16:14.260 --> 05:16:18.480
work when I asked it to convert it to the
underlying value. Now we'll come back in just

05:16:18.480 --> 05:16:22.208
a second and talk about why that happens.
But I want to finish our discussion of type

05:16:22.208 --> 05:16:26.818
conversions first. So stay tuned, and we'll
talk about why that works the way it does.

05:16:26.818 --> 05:16:30.458
So the next thing that I want to talk about
is something called the empty interface. Now

05:16:30.458 --> 05:16:35.000
the empty interface is exactly that. It's
an interface that has no methods on it. And

05:16:35.000 --> 05:16:39.468
we describe that using this syntax here. Now,
this isn't a special symbol, this is just

05:16:39.468 --> 05:16:43.578
an interface that we're defining on the fly,
and we don't have any methods on it. So it's

05:16:43.578 --> 05:16:47.600
called the empty interface. But there's nothing
special about it, we could create this as

05:16:47.600 --> 05:16:51.968
the empty interface exactly the same way by
just deleting the method out. And that's an

05:16:51.968 --> 05:16:55.790
empty interface now, so you see it like this
all the time. Just be aware, there's nothing

05:16:55.790 --> 05:16:59.828
special about this, it's just an interface
to find on the fly that has no methods on

05:16:59.828 --> 05:17:05.378
it. Now the nice thing about the empty interface
is everything can be cast into an object that

05:17:05.378 --> 05:17:10.290
has no methods on it even primitives because,
well, an integer has no methods. And so it

05:17:10.290 --> 05:17:15.510
can be cast to the empty interface. And so
this can be very useful in situations where

05:17:15.510 --> 05:17:20.010
you've got multiple things that you need to
be working with. But they aren't tight compatible

05:17:20.010 --> 05:17:24.010
with one another. And you need to apply some
logic later to figure out exactly what you

05:17:24.010 --> 05:17:28.500
received. But we do have a problem with the
empty interface. Because we now have this

05:17:28.500 --> 05:17:34.010
my object variable that's defined as an empty
interface, we can't actually do anything with

05:17:34.010 --> 05:17:39.200
it, because my object has no methods that
it exposes because it's an empty interface.

05:17:39.200 --> 05:17:43.860
So in order to do anything useful with a variable
that has the type of an empty interface, you're

05:17:43.860 --> 05:17:47.350
going to need to do either type conversion,
or you're going to need to start using the

05:17:47.350 --> 05:17:52.080
reflect package in order to figure out what
kind of an object you're dealing with. So

05:17:52.080 --> 05:17:56.340
in this case, on line 10, I'm actually trying
to type cast into a writer closer, and I'm

05:17:56.340 --> 05:18:00.670
using the comma okay syntax to see if that
worked. If it does, then go ahead and call

05:18:00.670 --> 05:18:04.910
the write and close methods like I saw before.
And then I've got this other type conversion

05:18:04.910 --> 05:18:09.728
that I've done that before just to keep things
consistent. So if I run this, we see that

05:18:09.728 --> 05:18:15.204
I forgot to re import the IO package, let
me go ahead and pull that back in.

05:18:15.204 --> 05:18:19.888
And we see that everything works as normal.
So the empty interface is very common. But

05:18:19.888 --> 05:18:23.958
just keep in mind, it's almost always going
to be an intermediate step. And you're going

05:18:23.958 --> 05:18:28.150
to define a variable of the type empty interface.
And then you're gonna have to figure out exactly

05:18:28.150 --> 05:18:32.090
what you receive before you can do anything
useful with it. The last thing that I want

05:18:32.090 --> 05:18:37.138
to talk about in the context of type conversions
are type switches. So I want to revisit that

05:18:37.138 --> 05:18:42.520
conversation from a few videos ago. And just
to show you, we can do something like this.

05:18:42.520 --> 05:18:46.648
So in line eight, I've got a variable i that's
defined as the empty interface, and I'm setting

05:18:46.648 --> 05:18:50.968
it equal to the integer zero. And then I'm
going to use this switch block here, and I'm

05:18:50.968 --> 05:18:56.670
going to use this syntax. So I've got my variable
name I, and then I'm going to use this dot

05:18:56.670 --> 05:19:01.208
and inside of prims, I'm going to put type.
And so what this is called is this is called

05:19:01.208 --> 05:19:06.410
a type switch. So each of the cases in this
type of switch are actually going to be a

05:19:06.410 --> 05:19:11.478
data type. So in this case, I'm looking to
see if I've got an integer or a string, or

05:19:11.478 --> 05:19:14.718
I've got a default case, which is going to
be handled by our application, just saying

05:19:14.718 --> 05:19:21.020
it doesn't know what AI is. So let's go ahead
and run this, I properly identify as an integer.

05:19:21.020 --> 05:19:26.010
So we execute this case here. If I put params
around this, then of course, I is now going

05:19:26.010 --> 05:19:31.128
to contain a string. And so if I run that,
again, it identifies it as a string. And if

05:19:31.128 --> 05:19:36.318
I change this, once again, maybe we can make
this a Boolean, gotta spell true correctly,

05:19:36.318 --> 05:19:41.110
and run that then it has no idea what it is.
So this is commonly paired with the empty

05:19:41.110 --> 05:19:46.860
interface in order to list out the types that
you're expecting to receive. And then you

05:19:46.860 --> 05:19:51.308
would add in the logic of how to process those
different types. Now, I promised you that

05:19:51.308 --> 05:19:56.248
we would come back and talk about that weird
type conversion behavior, where we could convert

05:19:56.248 --> 05:20:01.228
our writer closer into a pointer to a buffered
writer closer but Couldn't convert it into

05:20:01.228 --> 05:20:05.298
the value itself. So now I want to go through
and have that conversation about why that

05:20:05.298 --> 05:20:09.270
happened. So let me just drop this code in.
This is a much simpler implementation than

05:20:09.270 --> 05:20:13.610
what we had before. I've actually not really
implemented these methods anymore, in order

05:20:13.610 --> 05:20:17.638
to keep things as clean as possible for you
to see. So all I'm doing is I'm going to create

05:20:17.638 --> 05:20:22.850
a my writer closer, and that's down here as
my writer closer struct with nil implementations

05:20:22.850 --> 05:20:27.888
for the methods. But I do have the methods
implemented. So I can create this object as

05:20:27.888 --> 05:20:32.750
a writer closer, and then I'm just printing
out the value of the variable just so we have

05:20:32.750 --> 05:20:37.100
some use for that variable. So the go runtime
will actually compile and run this, and the

05:20:37.100 --> 05:20:41.870
interface for the writer closers to find exactly
the way we had before. So if I run this, everything

05:20:41.870 --> 05:20:46.370
works out just fine. However, what happens
if I change the receiver of one of these methods

05:20:46.370 --> 05:20:51.620
to a pointer? Well, if I run this, now, I
get an error. And the reason that I get that

05:20:51.620 --> 05:20:58.488
error is it can no longer convert my writer
closer into a writer closer interface. And

05:20:58.488 --> 05:21:02.898
it gives us an interesting message here, it
says my writer closer does not implement writer

05:21:02.898 --> 05:21:09.158
closer, the right method has a pointer receiver.
And this is the key to understand what happened

05:21:09.158 --> 05:21:14.360
with this. So when we define types, and we
assign methods to them, each one of those

05:21:14.360 --> 05:21:18.898
types has what's called a method set. Now
when you're working with the types directly,

05:21:18.898 --> 05:21:24.120
the method set is all of the methods regardless
of the receiver types associated with that

05:21:24.120 --> 05:21:30.228
type. With interfaces, however, things change
a little bit when I implement an interface

05:21:30.228 --> 05:21:34.700
with the concrete value. So notice here I'm
creating my writer closer, I'm not taking

05:21:34.700 --> 05:21:41.488
the address of my writer closer, I'm using
my writer closer directly. So WC is defined

05:21:41.488 --> 05:21:47.310
as holding the value my writer closer. So
the method set for a value when we're talking

05:21:47.310 --> 05:21:53.878
in the context of an interface is any method
that has a value as the receiver. So the reason

05:21:53.878 --> 05:21:59.048
we're not implementing writer closer is because
a write method no longer has a value receiver,

05:21:59.048 --> 05:22:03.540
it's going to point a receiver. And so its
method set is incomplete. And now we can fix

05:22:03.540 --> 05:22:09.500
this by using the address of operator and
running again. And notice now everything works.

05:22:09.500 --> 05:22:15.530
And the reason for that is the method set
for a pointer is the sum of all of the value

05:22:15.530 --> 05:22:20.808
receiver methods, and all of the pointer receiver
methods. So let's go through that. Again,

05:22:20.808 --> 05:22:26.940
when I'm implementing an interface, if I use
a value type, the methods that implement the

05:22:26.940 --> 05:22:33.078
interface have to all have value receivers.
If I'm implementing the interface with a pointer,

05:22:33.078 --> 05:22:37.328
then I just have to have the methods there,
regardless of the receiver type. So the method

05:22:37.328 --> 05:22:42.500
set for a value type is the set of all methods
that have value receivers. But the method

05:22:42.500 --> 05:22:47.950
set for a pointer type is all of the methods
with value receivers, as well as all of the

05:22:47.950 --> 05:22:51.798
methods with pointer receivers. So there's
a couple of ways that we could fix this. Now

05:22:51.798 --> 05:22:55.200
in this case, we don't need access to the
underlying data. So we could just go back

05:22:55.200 --> 05:22:59.458
to a value receiver. And then this is going
to work just fine. This is actually the initial

05:22:59.458 --> 05:23:04.370
example we had. If we have one method that's
going to appoint a receiver, however, we're

05:23:04.370 --> 05:23:09.770
going to need to switch that over to a pointer
type. And notice I can actually remove this.

05:23:09.770 --> 05:23:15.090
And it continues to work. Or I can make both
of these pointer receivers. And this continues

05:23:15.090 --> 05:23:20.100
to work as well. So this is an important concept
when you're implementing your own interfaces.

05:23:20.100 --> 05:23:24.908
If any of the methods require a pointer receiver,
you're going to have to implement that interface

05:23:24.908 --> 05:23:30.180
with a pointer. If not, though, if all of
the methods except value types, then you can

05:23:30.180 --> 05:23:34.168
go ahead and use a value type if that's what
you want. But you could also use a pointer.

05:23:34.168 --> 05:23:39.158
Okay, the last thing that I want to talk about
are some best practices when using interfaces

05:23:39.158 --> 05:23:44.080
in your own go applications. So let's take
a look at those. Okay, when we're working

05:23:44.080 --> 05:23:47.559
with interfaces, there's a couple of rules
and guidelines that I'd like you to keep in

05:23:47.559 --> 05:23:53.200
mind. And these have been developed over the
last few years by the NGO community, and are

05:23:53.200 --> 05:23:57.248
generally accepted as some of the best ways
to use interfaces, if it's practical in your

05:23:57.248 --> 05:24:04.040
applications. The first is prefer many small
interfaces versus large monolithic ones. Now,

05:24:04.040 --> 05:24:08.078
if you need large, monolithic ones, that's
fine, go ahead and compose smaller interfaces

05:24:08.078 --> 05:24:12.568
together to make those but the smaller you
can make your interfaces, the more useful

05:24:12.568 --> 05:24:16.520
and powerful they're going to be. And that's
not actually unique to go. No matter what

05:24:16.520 --> 05:24:22.048
language you're working in interfaces there.
They're generally having many smaller interfaces

05:24:22.048 --> 05:24:27.700
is preferable in the long run to having a
few monolithic ones. Now, some examples that

05:24:27.700 --> 05:24:32.950
are in the go standard library are the IO
dot writer interface, the IO dot reader interface

05:24:32.950 --> 05:24:37.968
in the empty interface. Now these are arguably
three of the most powerful interfaces in the

05:24:37.968 --> 05:24:42.620
entire language. And if you think about it,
writer has one method reader has one method

05:24:42.620 --> 05:24:46.668
and the empty interface has zero methods.
So it's interesting support to the argument

05:24:46.668 --> 05:24:51.578
that smaller interfaces are better that some
of the most powerful interfaces in the language

05:24:51.578 --> 05:24:56.718
contain one or zero methods on them. Now when
you're working with interfaces, if you're

05:24:56.718 --> 05:25:00.998
coming from a language that has explicitly
implemented interfaces, You're going to be

05:25:00.998 --> 05:25:07.208
very tempted to create interfaces and export
those. So here's the guidance for that if

05:25:07.208 --> 05:25:12.040
you don't need to export the interface yourself,
so if you don't have any particular reason

05:25:12.040 --> 05:25:16.950
to do it, go ahead and don't. So there are
some good examples of why you would want to

05:25:16.950 --> 05:25:22.430
do that. But often, it's perfectly acceptable
to export the concrete type.

05:25:22.430 --> 05:25:26.900
I'll take as an example, the database slash
SQL package that we looked at earlier in the

05:25:26.900 --> 05:25:32.958
video, where we saw that the DB object was
exported as a concrete struct. And it had

05:25:32.958 --> 05:25:37.808
all sorts of methods that pointed to other
concrete structs. So you can't directly mock

05:25:37.808 --> 05:25:44.180
that out for testing right out of the box.
However, by not exporting an interface, it

05:25:44.180 --> 05:25:49.621
allows you as the consumer of that struct
to define your own interface that you can

05:25:49.621 --> 05:25:54.898
use for testing. And the beauty of that is,
if you don't use every method on the DB object,

05:25:54.898 --> 05:25:59.058
your interface doesn't have to have every
method on it, you can just expose the methods

05:25:59.058 --> 05:26:04.958
that you need, however, do export interfaces
for types that you will be using. So if you're

05:26:04.958 --> 05:26:10.388
going to pull a value in, go ahead and accept
an interface instead of a concrete type, if

05:26:10.388 --> 05:26:15.898
at all possible. So this is going to be almost
exactly backwards from how other languages

05:26:15.898 --> 05:26:21.968
consider interfaces. And the reason is that
whole idea about implicitly implementing interfaces

05:26:21.968 --> 05:26:26.350
instead of explicitly doing it. So if you
were working in Java or C sharp, you could

05:26:26.350 --> 05:26:31.500
not do this, because you have to define the
interface before you implement the interface,

05:26:31.500 --> 05:26:36.340
because they're explicitly implemented. But
since go has implicit implementation, you

05:26:36.340 --> 05:26:40.680
can go ahead and defer the creation of the
interfaces until exactly when you need them.

05:26:40.680 --> 05:26:44.818
So if you're creating a library that other
people are going to consume, you can define

05:26:44.818 --> 05:26:49.218
the interfaces that you accept. And then they
can provide whatever implementations that

05:26:49.218 --> 05:26:54.030
they want. Now, if your library has reasonable
defaults, then you could export those concrete

05:26:54.030 --> 05:26:59.708
types as well. But make sure that you're accepting
interfaces whenever possible. And that's what

05:26:59.708 --> 05:27:04.148
this third point is talking about. design
your functions and methods to receive interfaces

05:27:04.148 --> 05:27:08.798
whenever possible. Now, that's not always
possible. If you need access to the underlying

05:27:08.798 --> 05:27:14.798
data fields, then certainly taking the concrete
types. But if you're accepting behavior providers,

05:27:14.798 --> 05:27:19.978
then go ahead and try and accept those as
interface types instead of the concrete types.

05:27:19.978 --> 05:27:25.078
Okay, so that covers what I want to talk about
with interfaces. today. Let's go into a summary

05:27:25.078 --> 05:27:30.068
and review what we've talked about. In this
video, we've talked about interfaces and how

05:27:30.068 --> 05:27:34.170
to use them in the go language, we started
with a discussion of the basics of interfaces,

05:27:34.170 --> 05:27:37.680
so how to create them and how to implement
them. And we ended up with code that looks

05:27:37.680 --> 05:27:41.488
something like this. So we're defining an
interface as a type. So we're going to start

05:27:41.488 --> 05:27:45.910
with the type keyword, the name of the interface,
and then the keyword interface. And then inside

05:27:45.910 --> 05:27:49.030
of curly braces, things are going to be a
little bit different than if we were defining

05:27:49.030 --> 05:27:52.818
a struct. For example, if we were defining
a struct, we would put data fields inside

05:27:52.818 --> 05:27:57.510
of the curly braces, because we're defining
the data that that structure is holding. With

05:27:57.510 --> 05:28:02.120
interfaces. we're defining behaviors, however,
so instead of adding data fields, we're gonna

05:28:02.120 --> 05:28:06.620
add method signatures. So we see here on this
example, we're going to define a write method

05:28:06.620 --> 05:28:12.128
that accepts a slice of bytes, and returns
an integer and an error. And then we implement

05:28:12.128 --> 05:28:18.058
that interface by creating a method on our
type that has the same signature. So we don't

05:28:18.058 --> 05:28:22.728
have to explicitly state that we're implementing
the interface, we implement the interface

05:28:22.728 --> 05:28:27.958
by implementing the interface by having the
methods there that match the type signature

05:28:27.958 --> 05:28:32.410
for the interfaces methods, then we talked
about how to compose interfaces together,

05:28:32.410 --> 05:28:37.798
and how this is a preferable approach versus
creating a single monolithic interface, if

05:28:37.798 --> 05:28:43.218
you can break that interface down into smaller
types, and then compose them together. And

05:28:43.218 --> 05:28:47.208
we did that something like this. So we're
going to create multiple interfaces. So we

05:28:47.208 --> 05:28:51.478
have a writer interface and a closer interface.
And then when we compose them together, just

05:28:51.478 --> 05:28:57.040
like when we compose structs, by embedding,
we can embed interfaces into one another.

05:28:57.040 --> 05:29:01.780
So we can create a writer closer interface
that embeds the writer interface and the closer

05:29:01.780 --> 05:29:06.408
interface. So to implement that writer closer
interface, you have to implement the right

05:29:06.408 --> 05:29:10.068
method, because it's defined by the writer
interface. And you have to implement the closed

05:29:10.068 --> 05:29:14.998
method as as defined by the closer interface.
So by doing this, you can actually pass smaller

05:29:14.998 --> 05:29:20.648
chunks of your interface around your application.
So for example, if a method only needs a writer,

05:29:20.648 --> 05:29:25.790
it doesn't need a closer, then you can actually
pass this writer closer as a writer, and it

05:29:25.790 --> 05:29:30.718
worked just fine versus passing the entire
writer closer along, and potentially exposing

05:29:30.718 --> 05:29:36.208
methods to the consumer that aren't really
necessary. Then we talked about type conversion

05:29:36.208 --> 05:29:40.660
and how we can drill through the interface
to get at the underlying types in case we

05:29:40.660 --> 05:29:45.748
need to work with those directly. So we had
an example here, where we created a writer

05:29:45.748 --> 05:29:50.190
closure instance, and the underlying type
was a pointer to a buffered writer closer,

05:29:50.190 --> 05:29:54.628
and how we could cast that back to a pointer
to a buffered writer closer by using this

05:29:54.628 --> 05:29:59.648
syntax here, where we have a dot after the
object and then inside of print, we put the

05:29:59.648 --> 05:30:01.370
type We want to cast to

05:30:01.370 --> 05:30:02.370
know, we learned

05:30:02.370 --> 05:30:05.958
that when we did this, if the type assertion
failed, then we're actually going to panic

05:30:05.958 --> 05:30:11.499
or application. So remember to use that comma,
okay syntax, if you want to get a boolean

05:30:11.499 --> 05:30:17.030
variable out that you can run tests against
to see if that type conversion succeeded.

05:30:17.030 --> 05:30:20.978
And then we talked about the empty interface
and type switches. The empty interface is

05:30:20.978 --> 05:30:25.458
nothing magic, it's just an interface to find
on the fly that has no methods on it. Now,

05:30:25.458 --> 05:30:31.718
it's special in that every type in go implements
the empty interface. So you can store anything

05:30:31.718 --> 05:30:37.298
you want in a variable of type empty interface.
And then very often, we're going to pair that

05:30:37.298 --> 05:30:41.020
with what's called a type switch. And we see
an example of that here, where we're going

05:30:41.020 --> 05:30:45.180
to use the switch keyword, we're going to
have the object and then dot and params, like

05:30:45.180 --> 05:30:49.250
we do with a type assertion. But instead of
having a concrete type that we're asserting

05:30:49.250 --> 05:30:54.030
against, we put the keyword type in there.
And then in our case statements, we're actually

05:30:54.030 --> 05:30:58.350
going to put in the data type that we're asserting
against. So in this case, we're looking for

05:30:58.350 --> 05:31:03.248
integers or strings, or we have a default
case, in case the value stored in i is neither

05:31:03.248 --> 05:31:08.918
an integer nor a string. After that, we talked
about implementing with values versus pointers.

05:31:08.918 --> 05:31:12.918
And we learned about a concept called method
sets. Now, when you're working with types

05:31:12.918 --> 05:31:16.568
directly, you never have to think about this
because the methods are always all of the

05:31:16.568 --> 05:31:21.280
methods assigned to that type. But with interfaces,
the rules change a little bit. The method

05:31:21.280 --> 05:31:25.898
set of a value is all of the methods with
value receivers. So if you're going to try

05:31:25.898 --> 05:31:31.600
and implement an interface with a value type,
than all of the methods that implement that

05:31:31.600 --> 05:31:37.430
interface, have to have value receivers. With
pointers, things are a little bit more flexible,

05:31:37.430 --> 05:31:41.708
because pointers always have access to the
underlying tape as well. The method sets for

05:31:41.708 --> 05:31:46.680
a pointer is all of the methods regardless
of the receiver type, so all of the value

05:31:46.680 --> 05:31:51.308
receivers, as well as all of the pointer receivers.
So pointer types are definitely more flexible

05:31:51.308 --> 05:31:55.190
when you're implementing interfaces. Just
keep in mind, you don't want to assign pointer

05:31:55.190 --> 05:32:00.328
receivers everywhere without thinking about
the idea that that gives access to the underlying

05:32:00.328 --> 05:32:05.318
data of that type. And so that can allow methods
to alter that underlying data, even if you

05:32:05.318 --> 05:32:09.488
don't want them to. So be careful when you
make that choice about using pointer receivers

05:32:09.488 --> 05:32:14.010
or value receivers. The last thing that we
talked about were some best practices that

05:32:14.010 --> 05:32:19.190
have evolved over the last few years about
using interfaces in the go language. And we

05:32:19.190 --> 05:32:24.430
talked about use many smaller interfaces whenever
possible. And then if you need larger interfaces,

05:32:24.430 --> 05:32:29.600
go ahead and compose those together with interface
composition. Don't export interfaces for types

05:32:29.600 --> 05:32:34.450
that will be consumed. So if you're creating
a library, and somebody else is going to be

05:32:34.450 --> 05:32:39.238
consuming a type, go ahead and publish that
concrete type out there don't create an interface,

05:32:39.238 --> 05:32:43.298
assuming you know how people are going to
use it, allow them to create the interfaces

05:32:43.298 --> 05:32:47.728
that your type will implement. That way, they
don't have to implement a whole bunch of methods

05:32:47.728 --> 05:32:53.298
in their test suite that they never even use.
Do export interfaces for types that you will

05:32:53.298 --> 05:32:57.850
be consuming however. So again, these two
points are exactly opposite of how you're

05:32:57.850 --> 05:33:02.208
going to think about interfaces, if you're
coming from another language, such as C sharp

05:33:02.208 --> 05:33:07.830
or Java, that have explicit implementation
of interfaces. So when you're defining a type

05:33:07.830 --> 05:33:11.850
that you're going to be consuming in your
package, then go ahead and export interfaces.

05:33:11.850 --> 05:33:17.568
That way whoever's using your package can
create their own concrete types, and implement

05:33:17.568 --> 05:33:21.700
the interfaces that you need. So you don't
need to worry about the implementation, you

05:33:21.700 --> 05:33:25.990
just need to worry about the behaviors that
they're exposing to you. And then, if possible,

05:33:25.990 --> 05:33:30.378
define your functions and methods to receive
interfaces. Don't get too crazy with this.

05:33:30.378 --> 05:33:35.770
So don't go over the top. Use common sense
with this. But if you have the option of receiving

05:33:35.770 --> 05:33:39.650
interfaces, for example, if you don't need
access to the underlying data, then go ahead

05:33:39.650 --> 05:33:44.040
and define an interface that you're going
to be receiving. That way it makes your methods

05:33:44.040 --> 05:33:48.620
and functions more flexible. Since you can
have multiple implementations that you never

05:33:48.620 --> 05:33:53.620
thought about at design time. And your functions
and methods will continue to work. Even when

05:33:53.620 --> 05:33:58.540
those new concepts are thrown at your application,
I want to have a conversation about the tools

05:33:58.540 --> 05:34:03.660
that we have available to implement concurrent
and parallel programming in the go language.

05:34:03.660 --> 05:34:04.660
Now,

05:34:04.660 --> 05:34:08.919
if you come this far in the series, or you've
done any research and go at all, concurrent

05:34:08.919 --> 05:34:12.750
programming is one of the hottest topics that
is talked about, especially among people who

05:34:12.750 --> 05:34:17.400
are learning to go language for the first
time. So we're going to talk about this concept

05:34:17.400 --> 05:34:23.738
of a go routine, and how that enables us to
create efficient and highly concurrent applications.

05:34:23.738 --> 05:34:27.280
We'll start our conversation by learning how
to create go routines themselves. So this

05:34:27.280 --> 05:34:31.138
is going to be the basics of how we create
go routines and how we can work with them

05:34:31.138 --> 05:34:35.818
a little bit. Then we'll move into a conversation
about synchronization. And we'll talk about

05:34:35.818 --> 05:34:41.218
two concepts, weight groups and mutexes. And
how we can use those to get multiple go routines

05:34:41.218 --> 05:34:45.180
to work together. Because one of the challenges
that we're going to have with go routines

05:34:45.180 --> 05:34:49.360
is also one of the greatest advantages. Go
routines are going to allow our application

05:34:49.360 --> 05:34:54.760
to work on multiple things at the same time.
However, you're often going to run into situations

05:34:54.760 --> 05:34:59.408
where you need a certain bit of functionality
in your application to weight into one or

05:34:59.408 --> 05:35:03.658
more of those concurrent calculations is complete.
So we'll talk about how to use synchronization

05:35:03.658 --> 05:35:08.441
primitives in order to do that. Then we'll
move into a discussion of parallelism. Now

05:35:08.441 --> 05:35:13.250
up to this point, our conversation is going
to be about concurrency in the go language.

05:35:13.250 --> 05:35:17.430
And concurrency is just the ability of the
application to work on multiple things at

05:35:17.430 --> 05:35:22.120
the same time, it doesn't mean it can work
on them at the same time, it just means it

05:35:22.120 --> 05:35:26.910
has multiple things that it can be doing.
When we talk about parallelism, we'll talk

05:35:26.910 --> 05:35:31.350
about how we can take our NGO applications
and enable them to work on those concurrent

05:35:31.350 --> 05:35:37.280
calculations in parallel, or in other words,
introduce parallelism into our applications.

05:35:37.280 --> 05:35:41.718
And finally, we're gonna wrap this video up
again, with a little section on best practices,

05:35:41.718 --> 05:35:45.020
just to talk about some of the gotchas that
you can run into with concurrent and parallel

05:35:45.020 --> 05:35:49.520
programming, and some of the tools that are
available to help keep your application safe

05:35:49.520 --> 05:35:54.058
and away from those minefields. Okay, so let's
get started by talking about how to create

05:35:54.058 --> 05:35:58.290
go routines. Okay, so the first thing that
you're going to notice is that we're in Visual

05:35:58.290 --> 05:36:02.230
Studio code right now. Now, the reason for
that is while we can certainly play with go

05:36:02.230 --> 05:36:06.478
routines in the playground, when we start
to get into parallelism, that's going to be

05:36:06.478 --> 05:36:11.180
limited by the playground, because the playground
only enables us to use one core at a time.

05:36:11.180 --> 05:36:14.540
So when we're running locally, we can use
as many cores as we want. So we can truly

05:36:14.540 --> 05:36:17.900
run our applications in parallel. So some
of the things that I want to show you are

05:36:17.900 --> 05:36:21.950
going to be easier to illustrate in this environment.
So the first thing that I want to show you

05:36:21.950 --> 05:36:25.591
is how we can create our very first go routine.
So the first thing that we're going to need

05:36:25.591 --> 05:36:29.011
to do is we're going to need to have a function
here. So I will create a function called Say

05:36:29.011 --> 05:36:32.990
hello. And this is going to be a very simple
function, all it's going to do is well say

05:36:32.990 --> 05:36:37.398
hello. So we'll start with that. And that's
going to be just enough for us to get started

05:36:37.398 --> 05:36:42.998
seeing what's going to happen with our application.
So we can of course, call the say hello function

05:36:42.998 --> 05:36:48.280
and call that from the main function. So we
can run this application by just using go

05:36:48.280 --> 05:36:53.570
run and pointing it to that file. And of course,
it says hello, so no big surprises there.

05:36:53.570 --> 05:36:59.190
Now, to turn this into a go routine, all we
have to do is in front of the function invocation,

05:36:59.190 --> 05:37:04.120
just type the keyword go. Now what that's
going to do is that's going to tell go to

05:37:04.120 --> 05:37:10.850
spin off what's called a green thread, and
run the say hello function in that green thread.

05:37:10.850 --> 05:37:15.110
Now I need to take a little bit of a moment
here to talk about threads. most programming

05:37:15.110 --> 05:37:19.700
languages that you've probably heard of and
worked with us, oh s threads are used operating

05:37:19.700 --> 05:37:25.328
system threads. And what that means is that
they've got an individual function call stack

05:37:25.328 --> 05:37:30.208
dedicated to the execution of whatever code
is handed to that thread. Now, traditionally,

05:37:30.208 --> 05:37:35.378
these tend to be very, very large. They have,
for example, about one megabyte of RAM, they

05:37:35.378 --> 05:37:39.610
take quite a bit of time for the application
to set up. And so you want to be very conservative

05:37:39.610 --> 05:37:43.360
about how you use your threads. And that's
where you get into concepts of thread pooling

05:37:43.360 --> 05:37:47.860
and things like that, because the creation
and destruction of threads is very expensive.

05:37:47.860 --> 05:37:53.998
And so we want to avoid that in most programming
languages, such as Java, or C sharp. Now,

05:37:53.998 --> 05:37:58.308
in go, it follows a little bit of a different
model. And as a matter of fact, the first

05:37:58.308 --> 05:38:02.968
place I saw this model was used by the Erlang
language. And this is using what's called

05:38:02.968 --> 05:38:08.498
Green threads. So instead of creating these
very massive heavy overhead threads, we're

05:38:08.498 --> 05:38:13.600
going to create an abstraction of a thread
that we're going to call a go routine. Now,

05:38:13.600 --> 05:38:18.818
inside of the go runtime, we've got a scheduler
that's going to map these go routines onto

05:38:18.818 --> 05:38:23.568
these operating system threads for periods
of time, and the scheduler will then take

05:38:23.568 --> 05:38:28.270
turns with every CPU thread that's available
and assign the different go routines, a certain

05:38:28.270 --> 05:38:32.780
amount of processing time on those threads.
But we don't have to interact with those low

05:38:32.780 --> 05:38:37.079
level threads directly. we're interacting
with these high level go routines. Now the

05:38:37.079 --> 05:38:42.860
advantage of that is since we have this abstraction
go routines can start with very, very small

05:38:42.860 --> 05:38:47.628
stack spaces, because they can be reallocated
very, very quickly. And so they're very cheap

05:38:47.628 --> 05:38:53.658
to create and to destroy. So it's not uncommon
in a go application to see 1000s or 10s of

05:38:53.658 --> 05:38:57.748
1000s of go routines running at the same time.
And the application is no problem with that

05:38:57.748 --> 05:38:58.748
at all.

05:38:58.748 --> 05:39:02.320
Now, if you compare that to other languages
that rely on operating system threads that

05:39:02.320 --> 05:39:06.200
have one megabyte of overhead, there's no
way you're going to run 10,000 threads in

05:39:06.200 --> 05:39:11.440
an environment like that. So by using go routines,
we get this nice lightweight abstraction over

05:39:11.440 --> 05:39:16.030
a thread, and we no longer have to be afraid
of creating and destroying them. So anyway,

05:39:16.030 --> 05:39:19.378
let's go ahead and run this and see what happens.
And it's going to be a little disappointing

05:39:19.378 --> 05:39:23.218
because you notice that our message doesn't
print out. And the reason for that is our

05:39:23.218 --> 05:39:28.168
main function is actually executing in a go
routine itself. So what we did here in line

05:39:28.168 --> 05:39:33.908
six was we told the main function to spawn
another go routine, but the application exits

05:39:33.908 --> 05:39:37.828
as soon as the main function is done. So as
soon as it spawn that go routine, it finished,

05:39:37.828 --> 05:39:42.558
it didn't have any more work to do. So the
say hello function never actually had any

05:39:42.558 --> 05:39:48.940
time available to it to print out its message.
So we can get around that a little bit by

05:39:48.940 --> 05:39:54.058
using a horrible practice, but it's good enough
to get us started in understanding this. So

05:39:54.058 --> 05:39:58.680
we'll just put an arbitrary sleep calling
here in order to get the main function to

05:39:58.680 --> 05:40:03.058
delay a little bit Now when we run the application,
we see that we do get our Hello message printed

05:40:03.058 --> 05:40:08.308
out. Now, as opposed to our first run of this,
it's not actually the main function that's

05:40:08.308 --> 05:40:13.770
executing this code. It's a go routine that
we're spawning off from the main function.

05:40:13.770 --> 05:40:17.238
And that's what's responsible for printing
out the message. Okay, now, this is a pretty

05:40:17.238 --> 05:40:21.968
typical use case of go routine where we're
using the go routine to invoke a function.

05:40:21.968 --> 05:40:25.748
But we don't have to do that. As a matter
of fact, let me just drop in this example

05:40:25.748 --> 05:40:32.090
here, which is basically the same, except
for instead of using a named function, I'm

05:40:32.090 --> 05:40:37.138
using this anonymous function here. So notice
that I've got this anonymously declared function,

05:40:37.138 --> 05:40:42.128
and I'm invoking it immediately. And I'm launching
it with go routine. Now, what's interesting

05:40:42.128 --> 05:40:47.068
about it is I'm printing out the message variable
that I've defined up here on line nine, down

05:40:47.068 --> 05:40:53.260
here inside of the go routine. So if I run
this, we do in fact, see that it works. Now

05:40:53.260 --> 05:40:58.568
the reason that it works is go has the concept
of closures, which means that this anonymous

05:40:58.568 --> 05:41:04.100
function actually does have access to the
variables in the outer scope. So it can take

05:41:04.100 --> 05:41:09.158
advantage of this MSG variable that we declared
up here on line nine, and use it inside of

05:41:09.158 --> 05:41:13.090
the go routine. Even though the go routine
is running with a completely different execution

05:41:13.090 --> 05:41:18.190
stack. The go runtime understands where to
get that MSG variable, and it takes care of

05:41:18.190 --> 05:41:23.170
it for us. Now, the problem with this is that
we've actually created a dependency between

05:41:23.170 --> 05:41:27.770
the variable in the main function and the
variable in the go routine. So to illustrate

05:41:27.770 --> 05:41:32.520
how that can be a problem. Let me modify the
example just a little bit. So I'm declaring

05:41:32.520 --> 05:41:36.400
the variable message and setting it equal
to Hello, and then printing it out in the

05:41:36.400 --> 05:41:40.968
go routine. And then right after I launched
the go routine, right here on line 13, I'm

05:41:40.968 --> 05:41:45.918
reassigning the variable to goodbye. So if
I go ahead and run this, you'll see that we

05:41:45.918 --> 05:41:50.718
in fact, get goodbye printed out in the go
routine, not Hello, like you might expect

05:41:50.718 --> 05:41:55.378
based on how the program is written. And the
reason for that. And it's not always going

05:41:55.378 --> 05:42:00.720
to be guaranteed to execute this way. But
most of the time, the ghost scheduler is not

05:42:00.720 --> 05:42:06.058
going to interrupt the main thread until it
hits this sleep call on line 14. Which means

05:42:06.058 --> 05:42:10.080
even though it launches another go routine
on line 10, it doesn't actually give

05:42:10.080 --> 05:42:14.968
it any love yet, it's still executing the
main function. And so it actually gets to

05:42:14.968 --> 05:42:20.100
line 13 and reassigns, the value of the message
variable before the go routine has a chance

05:42:20.100 --> 05:42:24.058
to print it out. And this is actually creating
what's called a race condition. And we'll

05:42:24.058 --> 05:42:28.648
come back and talk about race conditions at
the end of this video. But this is a bad thing.

05:42:28.648 --> 05:42:32.738
And generally, it's something that you want
to avoid, so that you can access variables

05:42:32.738 --> 05:42:37.790
via the closure, it's generally not a good
idea to do that. So if that's not a good idea,

05:42:37.790 --> 05:42:42.318
what are your other options? Well, notice
that we have a function here. And this is

05:42:42.318 --> 05:42:46.110
just a function invocation, there's nothing
special about it, just because we put the

05:42:46.110 --> 05:42:51.458
go keyword in front of it, it's just a function.
So functions can take arguments. So what happens

05:42:51.458 --> 05:42:57.140
if we add a message argument here, and then
down in the prints, where we're actually invoking

05:42:57.140 --> 05:43:02.270
the function? What if we pass in the message
parameter? Well, since we're passing this

05:43:02.270 --> 05:43:07.870
in by value, so we're actually going to copy
the string hello into the function, then we've

05:43:07.870 --> 05:43:13.628
actually decoupled the message variable in
the main function from the go routine, because

05:43:13.628 --> 05:43:19.078
now, this message that's going to print out
is actually a copy that we're passing in when

05:43:19.078 --> 05:43:24.080
we're invoking the function for the go routine.
So now if we run this, we see that we get

05:43:24.080 --> 05:43:27.680
Hello printed out. So this is generally the
way that you're going to want to pass data

05:43:27.680 --> 05:43:32.798
into your go routines, use arguments to do
that, and really intend for the variables

05:43:32.798 --> 05:43:38.230
to be coupled together. Now, this example
so far is working. But it's really not best

05:43:38.230 --> 05:43:42.158
practice. And the reason it's not best practice
is because we're using this sleep call. So

05:43:42.158 --> 05:43:47.620
we're actually binding the applications performance
and the applications clock cycles to the real

05:43:47.620 --> 05:43:52.260
world clock. And that's very unreliable. So
in order to get your applications to work,

05:43:52.260 --> 05:43:56.530
you're typically going to have to sleep for
a very long time relative to the average performance

05:43:56.530 --> 05:44:00.950
time in order to get the performance to be
reliable. So we don't want to use sleep calls

05:44:00.950 --> 05:44:05.610
in production, at least not for something
like this. So what are the other alternatives?

05:44:05.610 --> 05:44:10.168
Well, one of the other alternatives that we
have is to use what's called a weight group.

05:44:10.168 --> 05:44:13.998
So let's go ahead and add one in. And then
while we're doing that, we'll talk about what

05:44:13.998 --> 05:44:18.340
they are. So I'm going to create another variable.
And it looks like my auto formatting just

05:44:18.340 --> 05:44:21.828
helped me here. And we'll pull that from the
sync package. And we'll create an object of

05:44:21.828 --> 05:44:27.541
type weight group. So I just need to put my
curly braces here to initialize it. Now what

05:44:27.541 --> 05:44:33.080
a weight group does is it's designed to synchronize
multiple go routines together. So in this

05:44:33.080 --> 05:44:36.750
application, we've got two go routines that
we care about, we've got the go routine that's

05:44:36.750 --> 05:44:40.770
executing the main function. And we've got
this go routine that we're spawning off here

05:44:40.770 --> 05:44:46.860
on line 13. So what we want to do is we want
to synchronize the main function to this anonymous

05:44:46.860 --> 05:44:51.048
go routine. So we're going to do that by telling
the weight group that we've got another go

05:44:51.048 --> 05:44:56.120
routine that we wanted to synchronize to it
starts off synchronizing to zero. And so we're

05:44:56.120 --> 05:45:00.180
going to add one because we want to tell it
that we're going to synchronize to this go

05:45:00.180 --> 05:45:06.701
Right here. Now once it's done, we don't need
this line anymore. Once it's done, we're going

05:45:06.701 --> 05:45:09.990
to go ahead and exit the application. And
we will do that by just waiting on the weight

05:45:09.990 --> 05:45:14.740
group. And we do that by using the weight
method right here. Now when the go routine

05:45:14.740 --> 05:45:20.040
is done, then it can tell the weight group
that it's actually completed its execution.

05:45:20.040 --> 05:45:25.170
And we do that by using the done method. So
if we execute that, basically, what that's

05:45:25.170 --> 05:45:28.298
going to do is it's going to decrement, the
number of groups that the weight group is

05:45:28.298 --> 05:45:33.120
waiting on. And since we added one, and it's
going to decrement by one to be down to zero,

05:45:33.120 --> 05:45:36.600
and then the weight method will say, Okay,
it's time for us to go ahead and finish up

05:45:36.600 --> 05:45:41.798
our application run. So if I save this off,
and I go ahead and run it, we see in fact

05:45:41.798 --> 05:45:45.818
that our application is performing as it did
before. But now it's taking just enough time

05:45:45.818 --> 05:45:50.718
to complete the execution. We're not relying
on the rolling clock anymore, and having to

05:45:50.718 --> 05:45:55.208
Jimmy run with variables and hope that everything
stays consistent. Now, in this example, we're

05:45:55.208 --> 05:45:59.488
just synchronizing to go routines together.
But only one of the go routines is really

05:45:59.488 --> 05:46:03.568
doing any work. The main function in this
example is just storing data, and spawning

05:46:03.568 --> 05:46:08.468
other go routines. But we can have multiple
go routines that are working on the same data.

05:46:08.468 --> 05:46:12.100
And we might need to synchronize those together.
And that can be a little bit tricky. So let

05:46:12.100 --> 05:46:16.208
me drop in this example here, and we'll talk
about it. So I'm creating weight group again,

05:46:16.208 --> 05:46:21.578
up here on line eight. And then I'm initializing
a counter variable. inside of my main function,

05:46:21.578 --> 05:46:26.808
I'm actually spawning 20 go routines, because
inside of this for loop, each time I run through,

05:46:26.808 --> 05:46:31.340
I add two to the weight group to let it know
there are two more go routines that are running.

05:46:31.340 --> 05:46:35.870
And then I spawn a say hello, and then I spawn
an increment here. And then I just have a

05:46:35.870 --> 05:46:39.840
wait method call here on line 17, just to
make sure that the main function doesn't exit

05:46:39.840 --> 05:46:43.978
out too early now and say hello, all I'm going
to do is I'm going to print out Hello, and

05:46:43.978 --> 05:46:48.168
I'm going to print out the counter value.
And then in the increment function down here,

05:46:48.168 --> 05:46:51.940
I'm just going to increment the counter by
one. Now after each one of those is done,

05:46:51.940 --> 05:46:55.808
I'm going to call the done method on the weight
group. And everything should be just fine.

05:46:55.808 --> 05:47:00.760
Now notice that I've broken my own rule here,
the weight group is actually being accessed

05:47:00.760 --> 05:47:04.860
globally in this application. And that makes
sense, because I actually do want to share

05:47:04.860 --> 05:47:06.590
this object, and the weight group

05:47:06.590 --> 05:47:11.748
is safe to use concurrently like this. It's
designed to be using this way. So let's go

05:47:11.748 --> 05:47:16.260
ahead and run this application and see what's
going to happen. So our intuition says that

05:47:16.260 --> 05:47:20.190
we're going to print say, Hello. So it should
print say hello, zero, because the counters

05:47:20.190 --> 05:47:24.280
value is zero right here. And then it's going
to increment it. And then it's going to say

05:47:24.280 --> 05:47:27.280
hello, again, it's going to increment it.
So should say hello, number zero, hello, number

05:47:27.280 --> 05:47:32.346
one, hello, number two, and so on. So let's
go ahead and run this and see what happens.

05:47:32.346 --> 05:47:37.530
And we see that we get a mess, we in fact,
don't have any kind of reliable behavior going

05:47:37.530 --> 05:47:43.068
on here, we printed one twice, and then 2345.
So that seemed to work consistently. And then

05:47:43.068 --> 05:47:46.468
we jumped all the way to nine, we printed
10 out twice, and then we went back to nine

05:47:46.468 --> 05:47:50.870
for some reason. And if we run this again,
we'll get a completely different result. So

05:47:50.870 --> 05:47:54.680
what's happening here is our go routines are
actually racing against each other. So we

05:47:54.680 --> 05:47:59.100
have no synchronization between the go routines,
they're just going hell bent for leather,

05:47:59.100 --> 05:48:03.930
and going as fast as they can to accomplish
the work that we've asked them to do, regardless

05:48:03.930 --> 05:48:09.058
of what else is going on in the application.
So in order to correct this, we need to find

05:48:09.058 --> 05:48:13.479
a way to synchronize these guys together.
Now, we could probably find a way to use a

05:48:13.479 --> 05:48:17.168
weight group on this. But we've already talked
about weight groups. So I want to talk about

05:48:17.168 --> 05:48:21.908
another way to do this. So we're going to
introduce this concept of a mutex. So with

05:48:21.908 --> 05:48:27.190
a mutex. let me paste this example in here,
and then we'll talk about what it does. But

05:48:27.190 --> 05:48:31.100
a mutex is basically a lock that the application
is going to honor.

05:48:31.100 --> 05:48:35.818
Now in this case, you see on line 11, I'm
creating what's called an rW mutex, which

05:48:35.818 --> 05:48:41.568
is a read write mutex. Now a simple mutex
is simply locked or unlocked. So if the mutex

05:48:41.568 --> 05:48:46.250
is locked, and something tries to manipulate
that value, it has to wait until the mutex

05:48:46.250 --> 05:48:50.590
is unlocked. And they can obtain the mutex
lock itself. So what we can do with that is

05:48:50.590 --> 05:48:55.218
we can actually protect parts of our code
so that only one entity can be manipulating

05:48:55.218 --> 05:48:59.690
that code at a time. And typically what we're
going to use that for is to protect data to

05:48:59.690 --> 05:49:05.190
ensure that only one thing can access the
data at a single time. With an rW mutex, we've

05:49:05.190 --> 05:49:09.860
changed things a little bit. We've basically
said as many things as want to can read this

05:49:09.860 --> 05:49:15.180
data, but only one can write it at a time.
And if anything is reading, then we can't

05:49:15.180 --> 05:49:20.218
write to it at all. So we can have an infinite
number of readers, but only one writer. And

05:49:20.218 --> 05:49:23.920
so when something comes in and makes a write
request, it's going to wait till all the readers

05:49:23.920 --> 05:49:27.988
are done. And then the writer is going to
lock the mutex. So nothing can read it or

05:49:27.988 --> 05:49:32.170
write it until the writer is done. So in this
modification, actually, I don't want to talk

05:49:32.170 --> 05:49:37.458
about that line yet. We'll come back and revisit
that. So in this modification, what I've done

05:49:37.458 --> 05:49:43.350
here is I'm attempting to use a mutex to synchronize
things together. So the modification is down

05:49:43.350 --> 05:49:47.878
here in my say, Hello, I'm just reading the
value of the counter variable. And that's

05:49:47.878 --> 05:49:51.180
what I'm trying to protect. I'm trying to
protect the counter variable from concurrent

05:49:51.180 --> 05:49:56.100
reading and writing because that's what was
getting us into trouble. So on line 22, I

05:49:56.100 --> 05:50:00.760
obtained a read lock on the mutex and then
I print out my message and And then I released

05:50:00.760 --> 05:50:05.540
that lock using the R unlock method. Now in
the increment, that's where I'm actually mutating

05:50:05.540 --> 05:50:09.968
the data. So I need to write lock. And so
I'm going to call the lock method on the mutex,

05:50:09.968 --> 05:50:14.728
increment the value. And then I'm going to
call unlock. Now, if I run this application,

05:50:14.728 --> 05:50:20.700
I actually haven't gotten quite where I want
to be. So I don't get the weird random behavior

05:50:20.700 --> 05:50:25.648
that I was seeing before. But you notice that
something seems to be out of sync still, because

05:50:25.648 --> 05:50:30.430
I get Hello, one, hello, two, and then it
stays at two. And if I keep running, this

05:50:30.430 --> 05:50:35.298
actually can get different behaviors. But
notice that I'm always going in the proper

05:50:35.298 --> 05:50:39.350
order. So I fixed part of my problem, but
I haven't fixed all of it yet. So I can keep

05:50:39.350 --> 05:50:42.958
running. Actually, that one got pretty close.
But there's obviously something else going

05:50:42.958 --> 05:50:48.470
on here. With the reason that we have an issue
here is we're still working within the go

05:50:48.470 --> 05:50:54.010
routines. So if this say hello, function gets
executed twice by its go routines, and the

05:50:54.010 --> 05:50:58.170
increment function doesn't get called in between.
That's where we get this behavior here, where

05:50:58.170 --> 05:51:01.620
we actually get the same message printing
out twice, because we don't have a chance

05:51:01.620 --> 05:51:06.888
to lock this mutex before we try and read
it that second time. So the way to address

05:51:06.888 --> 05:51:11.378
this is we actually have to lock the mutex
outside of the context of the go routine.

05:51:11.378 --> 05:51:16.548
So we have a reliable execution model. So
let's go ahead and paste in a small modification

05:51:16.548 --> 05:51:22.158
here. Now all I've done is I've moved the
locks out here. So the locks are now executing

05:51:22.158 --> 05:51:27.908
before each go routine executes. And then
I unlock them when the go routine is done.

05:51:27.908 --> 05:51:33.940
So if I run this, we actually see that I now
get the behavior that I expect, I see zero

05:51:33.940 --> 05:51:39.958
through nine printed out. And if I run it
again, and I run it again, and run it again,

05:51:39.958 --> 05:51:44.798
everything is working great. So the reason
that this is working is I'm actually locking

05:51:44.798 --> 05:51:50.458
the mutex is in a single context. So the main
function is actually executing the locks.

05:51:50.458 --> 05:51:54.978
And then asynchronously, I'll unlock them
once I'm done with the asynchronous operation.

05:51:54.978 --> 05:51:59.648
Now the problem with this application is I
basically have completely destroyed concurrency

05:51:59.648 --> 05:52:04.921
and parallelism in this application. Because
all of these mutexes are forcing the data

05:52:04.921 --> 05:52:10.680
to be synchronized and run in a single threaded
way. So any potential benefits that I would

05:52:10.680 --> 05:52:14.440
get from the go routines are actually gone.
As a matter of fact, this application probably

05:52:14.440 --> 05:52:18.908
performs worse than one without go routines,
because I'm mucking around with this mutex.

05:52:18.908 --> 05:52:24.000
And I'm constantly locking it and unlocking
it. So this is an example where if this is

05:52:24.000 --> 05:52:28.620
all that this application needed to do, we
would actually be much better served by removing

05:52:28.620 --> 05:52:33.808
the go routines, and just running this with
a single execution path and removing any concurrency

05:52:33.808 --> 05:52:38.708
at all. However, there are often situations
where you can get a significant advantage

05:52:38.708 --> 05:52:43.510
by running things in parallel. And so you
can use weight groups, or mutex is in order

05:52:43.510 --> 05:52:47.409
to synchronize things together, and make sure
that your data is protected, and everything

05:52:47.409 --> 05:52:51.919
is playing well together. Now I have this
line in here, and I apologize for that I really

05:52:51.919 --> 05:52:56.498
shouldn't have had that in these earlier examples.
But I do want to talk about this function

05:52:56.498 --> 05:53:02.398
from the runtime package called go max procs.
So in modern versions of go, if you look at

05:53:02.398 --> 05:53:06.458
this go max procs variable, let's just go
ahead and execute this simple program, all

05:53:06.458 --> 05:53:07.458
it's going

05:53:07.458 --> 05:53:10.090
to do is it's going to tell me the number
of threads that are available. So it prints

05:53:10.090 --> 05:53:13.771
out that there are four threads available
in the application ends. Matter of fact, let

05:53:13.771 --> 05:53:16.790
me just add this carriage return in here and
run this again, that way things look a little

05:53:16.790 --> 05:53:22.310
better. And you see that I have four threads
available. So by default, what go is going

05:53:22.310 --> 05:53:27.048
to do is it's going to give you the number
of operating system threads equal to the number

05:53:27.048 --> 05:53:32.280
of cores that are available on the machine.
So in this virtual machine, I've exposed four

05:53:32.280 --> 05:53:33.728
cores to the VM.

05:53:33.728 --> 05:53:38.650
So I have by default four oh s threads that
I can work with. Now, I can change that value

05:53:38.650 --> 05:53:45.290
to anything I want. So for example, I can
change that to one. And now my application

05:53:45.290 --> 05:53:50.100
is running single threaded. So now I have
a truly concurrent application with no parallelism

05:53:50.100 --> 05:53:55.168
at all. So this can be useful in situations
where there's a lot of data synchronization

05:53:55.168 --> 05:54:00.110
going on. And you really need to be careful
to avoid any kind of race conditions that

05:54:00.110 --> 05:54:04.828
parallelism can incur. And maybe there's no
better way to do it. Now, I would say there's

05:54:04.828 --> 05:54:09.748
an architecture problem there. But it is possible
to run an application in a single threaded

05:54:09.748 --> 05:54:14.378
way, by setting go max procs equal to one.
Now if you're wondering what this negative

05:54:14.378 --> 05:54:19.270
one does, when you invoke the go max procs
function, it actually returns the number of

05:54:19.270 --> 05:54:23.628
threads that were previously set. And if you
pass a negative number, then it doesn't change

05:54:23.628 --> 05:54:27.398
the values. So this go max procs, negative
one, all that's doing is that's letting us

05:54:27.398 --> 05:54:32.468
interrogate how many threads we have available.
Now we can also set this to for example, 100.

05:54:32.468 --> 05:54:37.708
There's nothing stopping us from creating
a massive number of operating system threads.

05:54:37.708 --> 05:54:43.648
Now what I found in working with NGO is that
go max procs is a tuning variable for you

05:54:43.648 --> 05:54:50.860
to work with. So the general advice is one
operating system thread per core is a minimum.

05:54:50.860 --> 05:54:56.320
But a lot of times you'll actually find that
your application will get faster by increasing

05:54:56.320 --> 05:55:02.020
go max procs beyond that value. Now if you
get up too high Like, for example, 100, then

05:55:02.020 --> 05:55:05.690
you can run into other problems, because now
you've got additional memory overhead. Because

05:55:05.690 --> 05:55:09.968
you're maintaining 100 operating system threads,
your scheduler has to work harder because

05:55:09.968 --> 05:55:14.290
it's got all these different threads to manage.
And so eventually, the performance peaks and

05:55:14.290 --> 05:55:19.569
it starts to fall back off, because your application
is constantly rescheduling go routines on

05:55:19.569 --> 05:55:25.468
different threads. And so you're losing time
every time that occurs. So as you get your

05:55:25.468 --> 05:55:29.450
application closer to production, I would
encourage you definitely develop with go max

05:55:29.450 --> 05:55:34.398
procs greater than one because you want to
reveal those race conditions as early as possible.

05:55:34.398 --> 05:55:38.350
But just before you release to production,
you might want to run your application through

05:55:38.350 --> 05:55:43.578
a performance test suite with varying values
of go max procs, to see where it's going to

05:55:43.578 --> 05:55:48.040
perform the best. Now, the last thing that
I want to talk about are some best practices

05:55:48.040 --> 05:55:52.510
to keep in mind when you're working with go
routines in the go language. So let's take

05:55:52.510 --> 05:55:57.708
a look at those next. Go routines in the go
language are very powerful, and it can be

05:55:57.708 --> 05:56:01.308
easy to let them get a little bit out of hand.
So I want to go through and give you some

05:56:01.308 --> 05:56:06.510
advice on how to work with go routines in
your own applications. The first bit of advice

05:56:06.510 --> 05:56:11.770
is, if you're working in a library, be very,
very careful about creating go routines yourself,

05:56:11.770 --> 05:56:16.100
because generally, it's better to let the
consumer control the concurrency of the library,

05:56:16.100 --> 05:56:20.548
not the library itself. If you force your
library to work concurrently, then that can

05:56:20.548 --> 05:56:24.658
actually cause your consumers to have more
problems synchronizing data together. So in

05:56:24.658 --> 05:56:29.290
general, keep things simple, keep things single
threaded, and let the consumer of your library

05:56:29.290 --> 05:56:35.328
decide when to use a go routine and when not
to now, this advice can be softened a little

05:56:35.328 --> 05:56:38.610
bit, if you have a function called that's
going to return a channel that will return

05:56:38.610 --> 05:56:43.180
the result, then having the go routine in
there might not be such a bad thing, because

05:56:43.180 --> 05:56:47.371
your consumer never really has to worry about
how that unit of work is getting done. They

05:56:47.371 --> 05:56:51.248
don't really care if it's running concurrently
or not. Because they are just going to be

05:56:51.248 --> 05:56:54.680
listening for the result on a channel. But
we haven't talked about channels yet. So we'll

05:56:54.680 --> 05:56:59.850
revisit that topic in the next video. But
for now, if you're creating a library, trying

05:56:59.850 --> 05:57:04.200
to avoid go routines, at least go routines
that are going to be surface to the consumer

05:57:04.200 --> 05:57:08.620
and have them forced to work with them. When
you create a go routine, know how it's going

05:57:08.620 --> 05:57:14.190
to end. Now we're gonna see how to do this
a little bit more when we talk about channels.

05:57:14.190 --> 05:57:18.420
But it's really easy to have a go routine
launched as kind of a watch or go routine.

05:57:18.420 --> 05:57:22.010
So it's going to be just sitting out there
listening for messages to come in. And it's

05:57:22.010 --> 05:57:26.530
going to process those messages as they arrive.
However, if you don't have a way to stop that

05:57:26.530 --> 05:57:31.850
go routine, that go routine is going to continue
on for ever. And so it's constantly going

05:57:31.850 --> 05:57:37.458
to be a drain on the resources of your application.
And eventually, as the go routine ages, it

05:57:37.458 --> 05:57:41.750
could even cause other issues and cause your
application to crash. The other thing that

05:57:41.750 --> 05:57:46.418
I want to give you some advice about is check
for race conditions at compile time. So I

05:57:46.418 --> 05:57:50.610
want to jump back over to the editor and show
you how to do that. But it's very important

05:57:50.610 --> 05:57:54.850
and very simple to do in most environments
that go runs in. So let's jump over to the

05:57:54.850 --> 05:57:58.908
editor and take a look at that in order to
see if we don't have to go any further than

05:57:58.908 --> 05:58:02.648
this example. Now I know this is right from
the beginning of the video, and it's got sleeps

05:58:02.648 --> 05:58:07.620
in there. And it's got some bad practices.
But if you remember, if we run this application,

05:58:07.620 --> 05:58:12.298
then it prints goodbye instead of the Hello
message that we originally printed. So how

05:58:12.298 --> 05:58:17.878
could we have detected this without running
the application? Well, you might not think

05:58:17.878 --> 05:58:21.040
it's terribly important to be able to do that.
Because it's obvious, we've got some kind

05:58:21.040 --> 05:58:24.760
of a problem here. And all we have to do is
apply our debugging skills. But there are

05:58:24.760 --> 05:58:30.370
other cases where this is very, very subtle
and very, very hard to track down without

05:58:30.370 --> 05:58:35.450
a little bit of help. Well, fortunately, the
go compiler has quite a bit of help available

05:58:35.450 --> 05:58:42.190
to you. And it's as simple to invoke as just
adding a dash race flag to go run, go install,

05:58:42.190 --> 05:58:45.990
go build whatever you're using to get your
application up and running. So let's go ahead

05:58:45.990 --> 05:58:50.738
and try that and see what it says about our
little application here. And you notice it

05:58:50.738 --> 05:58:55.208
does run the application because we invoked
go run so we see goodbye printed here. But

05:58:55.208 --> 05:59:00.548
notice what we got up here we got this data
race message. So it's telling us it sees that

05:59:00.548 --> 05:59:06.078
the same area of data is being accessed by
two different executing go routines. So it

05:59:06.078 --> 05:59:10.958
says the first one that it found was in go
routine six which an internal identifier unless

05:59:10.958 --> 05:59:15.340
we're profiling, we've got no idea what goroutine
six is, but it does tell us it was invoked

05:59:15.340 --> 05:59:20.968
on line 11. So apparently in this run, go
routine six was this go routine right here.

05:59:20.968 --> 05:59:27.048
And it was accessing the MSG variable. It
also sees that we access the MSG variable

05:59:27.048 --> 05:59:32.260
on line 13, which is in our main function.
And so by adding the dash race flag, we get

05:59:32.260 --> 05:59:38.440
all of this additional information where the
go compiler itself, analyzes our application

05:59:38.440 --> 05:59:43.068
and tries to determine if we have any race
conditions. So I would strongly encourage

05:59:43.068 --> 05:59:47.530
you if you get any kind of concurrency at
all in your application, you're going to want

05:59:47.530 --> 05:59:52.628
to run this because it's very simple check
it runs very, very quickly. And it's going

05:59:52.628 --> 05:59:57.430
to help you prevent very subtle bugs from
getting into your production code.

05:59:57.430 --> 06:00:02.388
Okay, so that's what I have to talk about.
With go routines, maybe you are expecting

06:00:02.388 --> 06:00:06.580
more. But go routines are really quite simple.
Now when we get into our next conversation,

06:00:06.580 --> 06:00:10.888
which will be about channels, things get a
little bit more complicated, but go routines

06:00:10.888 --> 06:00:14.840
are relatively straightforward. So let's go
into a summary and review what we've talked

06:00:14.840 --> 06:00:20.998
about in this video. In this video, we learned
about go routines and how we can use them

06:00:20.998 --> 06:00:26.680
to create concurrent and parallel execution
paths in our applications. We started by learning

06:00:26.680 --> 06:00:31.048
how to create go routines themselves. And
we learned that by adding the go keyword in

06:00:31.048 --> 06:00:34.690
front of a function call, we've created a
go routine. And that's all that it takes.

06:00:34.690 --> 06:00:38.620
There's no special semantics, there's no special
things that need to be done. It's simply a

06:00:38.620 --> 06:00:44.048
function call with the keyword go in front
of it. Now when we're using anonymous functions,

06:00:44.048 --> 06:00:48.870
we in general want to pass data as local variables.
So you want to add a parameter into that anonymous

06:00:48.870 --> 06:00:54.748
function and pass data into the go routine,
instead of relying on the closures to prevent

06:00:54.748 --> 06:00:59.048
any kind of race conditions as you try and
manipulate that data. And that's not always

06:00:59.048 --> 06:01:03.780
true. We saw with weight groups that we access
that globally, because that was our intention,

06:01:03.780 --> 06:01:08.298
we truly did want that to be available in
multiple scopes. But even then we could pass

06:01:08.298 --> 06:01:12.718
a pointer in, in order to be very clear about
what information that go routine should have

06:01:12.718 --> 06:01:17.170
access to. Then we talked about the different
ways that we can synchronize multiple go routines

06:01:17.170 --> 06:01:21.790
together, one of the challenges that we have
with go routines is now we've got all sorts

06:01:21.790 --> 06:01:26.511
of things happening. And there's no way to
ensure without synchronization, how they're

06:01:26.511 --> 06:01:31.230
going to interact with one another. Now for
a lot of concurrent calculations, that's not

06:01:31.230 --> 06:01:35.420
a problem at all, because the two might not
be related to one another. But often you get

06:01:35.420 --> 06:01:39.940
into situations where you're relying on the
result of multiple calculations, or something

06:01:39.940 --> 06:01:45.580
needs to know the result of the work that's
been done, or you've got a shared memory issue.

06:01:45.580 --> 06:01:49.228
And you need to make sure that those go routines
aren't trying to manipulate the same data

06:01:49.228 --> 06:01:54.850
at the same time. So we can use weight groups
to wait for groups of go routines to complete.

06:01:54.850 --> 06:01:58.360
So we saw that we have three methods that
are interesting. There, we have the Add method

06:01:58.360 --> 06:02:02.200
to inform the weight group that there are
more go routines for it to wait on, we have

06:02:02.200 --> 06:02:06.270
the weight method that's going to block the
go routine that is called on until the weight

06:02:06.270 --> 06:02:10.860
group is completed. And then we have the done
method available on that weight group that

06:02:10.860 --> 06:02:15.120
lets the weight group know that one of the
go routines is completed with its work.

06:02:15.120 --> 06:02:19.548
We also talked about the mutex and the rW
mutex, and how those are generally used to

06:02:19.548 --> 06:02:23.818
protect data. So if you have a piece of data
that's going to be accessed in multiple locations

06:02:23.818 --> 06:02:29.728
in your application, then you can protect
that access by using a mutex or an rW mutex.

06:02:29.728 --> 06:02:34.818
To ensure that only one go routine is manipulating
that data at one time. We then talked about

06:02:34.818 --> 06:02:39.200
parallelism and how parallelism can introduce
some really tricky challenges into your go

06:02:39.200 --> 06:02:45.020
applications. We talked about how by default
go will use the number of CPU threads equal

06:02:45.020 --> 06:02:49.920
to the number of available cores on the computer
that is running on. We talked about how we

06:02:49.920 --> 06:02:54.850
can change that by using the go max procs
function from the runtime package. And we

06:02:54.850 --> 06:02:59.228
talked about how more threads will generally
increase performance. But too many can actually

06:02:59.228 --> 06:03:04.138
slow it down. So in general, if you're developing
an application, you want to start from day

06:03:04.138 --> 06:03:09.738
one with go max procs greater than one to
find any concurrency and any race conditions

06:03:09.738 --> 06:03:14.398
early on in your application development.
But don't settle on a final number until right

06:03:14.398 --> 06:03:17.920
as you get close to production and you have
a performance test suite that you can work

06:03:17.920 --> 06:03:23.468
with. To find out what the best value for
go max procs is for your application. Because

06:03:23.468 --> 06:03:27.840
while the starting number is a very good number
to start with, a lot of applications actually

06:03:27.840 --> 06:03:33.270
perform better with a value higher or lower
than that default value. And finally, we wrapped

06:03:33.270 --> 06:03:36.610
up with a discussion of some best practices
to keep in mind when you're working with go

06:03:36.610 --> 06:03:41.228
routines. We learned that if you're a library
developer, you should avoid the creation of

06:03:41.228 --> 06:03:45.578
go routines that are going to be exposed to
the consumer of your library. Let the consumer

06:03:45.578 --> 06:03:48.940
control the concurrency of your application
because they're the ones that are in the best

06:03:48.940 --> 06:03:53.690
place to know if something needs to be executed
single threaded, or if it can be executed

06:03:53.690 --> 06:03:57.860
concurrently. When creating a go routine,
know how it's going to end. It's very easy

06:03:57.860 --> 06:04:02.020
to get into situations where go routines start
leaking memory because they're never cleaned

06:04:02.020 --> 06:04:06.878
up because they never quite get done with
their work. Now normally a go routine is killed

06:04:06.878 --> 06:04:11.139
as soon as it finishes its execution. And
we saw that with the main function, the main

06:04:11.139 --> 06:04:15.350
function runs in a go routine. And that go
routine terminates as soon as the main function

06:04:15.350 --> 06:04:20.298
exits. We also saw in our say hello function,
as soon as it printed its message out and

06:04:20.298 --> 06:04:25.540
the function exited. That go routine was killed
and it was cleaned out. So it was very clear

06:04:25.540 --> 06:04:30.000
when those go routines life cycle is going
to be over. However, if you've got go routines

06:04:30.000 --> 06:04:34.638
that are listening for messages in a continuous
loop, then make sure that you code in a way

06:04:34.638 --> 06:04:39.968
to shut those go routines down so that once
you're done using them and clean up the memory

06:04:39.968 --> 06:04:44.708
that they're using. Also, as you're going
along with your application development, check

06:04:44.708 --> 06:04:49.420
for race conditions, it's not that hard to
do. You just have to add dash race onto the

06:04:49.420 --> 06:04:54.340
go command that's compiling your application.
And then the go compiler is going to analyze

06:04:54.340 --> 06:05:00.110
your application and try and locate places
in it that have the potential of access Seeing

06:05:00.110 --> 06:05:05.440
the same memory at the same time, or in an
unsynchronized way, causing very subtle and

06:05:05.440 --> 06:05:10.341
potentially very disastrous bugs where your
application when it gets to production. Over

06:05:10.341 --> 06:05:15.058
the course of this video series, we've talked
about a lot of structures and techniques and

06:05:15.058 --> 06:05:19.280
tools that are available. In order to get
started successfully programming with the

06:05:19.280 --> 06:05:23.840
go language. Well, I want to wrap up that
discussion in this video by talking about

06:05:23.840 --> 06:05:27.940
one of the features that makes go really stand
out when you're looking for different languages

06:05:27.940 --> 06:05:32.828
to work with. And that is this concept of
channels. Now most programming languages that

06:05:32.828 --> 06:05:37.968
are out there, were originally designed with
a single processing core in mind. And so when

06:05:37.968 --> 06:05:42.510
concurrency and parallelism came into play,
they were really kind of bolted on to the

06:05:42.510 --> 06:05:46.700
side. And so a lot of times, you're actually
going to be working with third party libraries

06:05:46.700 --> 06:05:52.058
and packages in order to help with data synchronization
and things like that. Well go was born in

06:05:52.058 --> 06:05:57.520
a multiprocessor world. So every computer
that was out there when go was invented, had

06:05:57.520 --> 06:06:02.690
more than one processing core. So it made
sense as the language was being designed to

06:06:02.690 --> 06:06:07.830
consider concurrency and parallelism from
the beginning. Now in the last video, we talked

06:06:07.830 --> 06:06:14.378
about go routines, and how go abstracts the
concept of a thread into this higher concept

06:06:14.378 --> 06:06:19.718
called a go routine to allow hundreds or 1000s
or even 10s of 1000s of things to be going

06:06:19.718 --> 06:06:24.760
on in your application at the same time. On
this video, we're going to be talking about

06:06:24.760 --> 06:06:30.158
channels, and how those can be used to pass
data between different go routines in a way

06:06:30.158 --> 06:06:35.940
that is safe, and prevents issues such as
race conditions, and memory sharing problems

06:06:35.940 --> 06:06:41.010
that can cause issues in your application
that are very difficult to debug.

06:06:41.010 --> 06:06:44.540
So we're going to start this talk by talking
about the basics of channels. So we'll talk

06:06:44.540 --> 06:06:49.010
about how to create them, how we can use them
how we can pass data through them, then we'll

06:06:49.010 --> 06:06:53.558
talk about how we can restrict data flow.
Now a basic channel is a two way street, we

06:06:53.558 --> 06:06:57.398
can send data in and we can get data out.
But that's not always what you want to be

06:06:57.398 --> 06:07:01.208
able to do with the channel. Sometimes you
want to send only channel or receive only

06:07:01.208 --> 06:07:05.798
channel. And we'll talk about how to do that
in the second section. Then we'll talk about

06:07:05.798 --> 06:07:11.158
buffered channels, and how we can actually
design channels to have an internal data store

06:07:11.158 --> 06:07:15.548
so that they can store several messages at
once just in case the sender and the receiver

06:07:15.548 --> 06:07:19.468
aren't processing data at the same rate. Then
we'll talk about how we can close channels

06:07:19.468 --> 06:07:24.218
once we're done with them. We'll then revisit
the topic of four range loops. And we'll learn

06:07:24.218 --> 06:07:28.770
how we can use channels with a four range
loop. And then we'll wrap up our discussion

06:07:28.770 --> 06:07:33.260
by talking about SELECT statements, which
is kind of like a switch statement, but specifically

06:07:33.260 --> 06:07:37.548
designed to work in the context of a channel.
Okay, so let's go ahead and dive in and learn

06:07:37.548 --> 06:07:40.360
the basics of working with channels.

06:07:40.360 --> 06:07:44.180
So when we're working with channels in the
go language, we're almost always going to

06:07:44.180 --> 06:07:48.850
be working with them in the context of go
routines. And the reason is because channels

06:07:48.850 --> 06:07:54.040
are really designed to synchronize data transmission
between multiple go routines. So let's go

06:07:54.040 --> 06:07:57.520
ahead and get started by creating some go
routines. Well, actually, the first thing

06:07:57.520 --> 06:08:00.998
that I need to do is I need to create a weight
group. Because as you remember from the last

06:08:00.998 --> 06:08:05.388
video, we use weight groups in order to synchronize
go routines together. So we're going to use

06:08:05.388 --> 06:08:09.660
the weight group to synchronize the go routines
to make sure that our main routine waits for

06:08:09.660 --> 06:08:14.120
all of our other go routines to finish. And
then we're going to use channels in order

06:08:14.120 --> 06:08:18.440
to synchronize the data flow between them.
So we got two different synchronization mechanisms

06:08:18.440 --> 06:08:22.421
going on in this little application. The next
thing we need to do is we need to create a

06:08:22.421 --> 06:08:26.770
channel. Now channels are created with the
built in make function. And there really is

06:08:26.770 --> 06:08:31.020
no shortcut around this. Now a lot of uses
of the make function, you can actually use

06:08:31.020 --> 06:08:35.208
other forms. When you're creating a channel,
there's enough internal mechanisms that need

06:08:35.208 --> 06:08:39.840
to fire that you have to use the make function
in order to allow the runtime to properly

06:08:39.840 --> 06:08:44.021
set up the channel for you. Now on the simplest
form of the make function with working with

06:08:44.021 --> 06:08:48.398
channels, we're going to use the channel keyword
to say that we want to create a channel. And

06:08:48.398 --> 06:08:51.170
then we're going to provide the data type
that's going to flow through the channel.

06:08:51.170 --> 06:08:55.708
Now you can pick any data type that you want,
we're just going to be using integers here.

06:08:55.708 --> 06:09:00.668
But keep in mind that this means that the
channel is strongly typed, you can only send

06:09:00.668 --> 06:09:04.730
integers through this channel that we're creating
here. Similarly, if we provided strings, we

06:09:04.730 --> 06:09:08.741
could only pass in strings. If you provided
pointers to integers, you can only send in

06:09:08.741 --> 06:09:13.010
pointers to integer, you get the general idea.
So when you create a channel, you're going

06:09:13.010 --> 06:09:18.138
to create that channel to accept messages
of a certain type. And it's only ever going

06:09:18.138 --> 06:09:22.708
to receive them send messages of that type.
Now in this initial example, we're going to

06:09:22.708 --> 06:09:26.558
have to go routines, I'm going to spawn so
I'm going to add two items to my wait group.

06:09:26.558 --> 06:09:30.128
And then we'll go ahead and create those go
routines, and then we'll talk about those.

06:09:30.128 --> 06:09:35.090
So let me just drop in the rest of the code
here. And you can see my first go routine

06:09:35.090 --> 06:09:39.910
is an anonymous function actually both of
the marm and this first one is going to be

06:09:39.910 --> 06:09:44.908
receiving data from the channel. So this go
routine is actually going to be my receiving

06:09:44.908 --> 06:09:49.648
go routine. And then this channel is actually
going to be my sending go routine. So the

06:09:49.648 --> 06:09:54.408
way that we send a message into a channel
is as you see here, we're going to use this

06:09:54.408 --> 06:09:58.870
arrow syntax, so we're going to use a less
than and a dash, and when we're putting data

06:09:58.870 --> 06:10:03.458
into the channel we list the channel first,
then we have this arrow and then the data

06:10:03.458 --> 06:10:07.560
that we want to pass in. So imagine that the
arrow is pointing in the direction that we

06:10:07.560 --> 06:10:11.238
want the data to flow. So we want the data
to flow into the channel, and so the arrow

06:10:11.238 --> 06:10:15.760
is pointing toward the channel. Similarly,
if we want to receive data from the channel,

06:10:15.760 --> 06:10:19.148
then we're going to put the arrow on the other
side. So we're going to use that same less

06:10:19.148 --> 06:10:24.218
than and dash, but it's going to be before
the channel. And so we're going to be pulling

06:10:24.218 --> 06:10:29.660
data from the channel. So in this line right
here, on line 14, we're going to be receiving

06:10:29.660 --> 06:10:33.968
data from the channel and assigning it to
the variable i. And then after we're done,

06:10:33.968 --> 06:10:37.080
we're going to call the done method on our
weight groups. And we're just going to print

06:10:37.080 --> 06:10:41.680
the value out. So all we're doing here is
this go routine is going to be sending the

06:10:41.680 --> 06:10:46.988
value 42, this go routine is going to be receiving
whatever value comes out of the channel, which

06:10:46.988 --> 06:10:50.870
in this case, of course, will be 42. And it's
going to print that out to the console. So

06:10:50.870 --> 06:10:55.410
let's go ahead and run that. And we see that
in fact, it does work. So the nice thing about

06:10:55.410 --> 06:11:01.190
doing this is since we're sending a copy of
the data to the channel, we could manipulate

06:11:01.190 --> 06:11:05.930
the variable assigned here. So for example,
we could actually start this off with I set

06:11:05.930 --> 06:11:13.238
equal to 42. And we can pass in I and then
afterwards, we can reassign I, and it doesn't

06:11:13.238 --> 06:11:18.058
matter because like with all other variable
operations and go, when we're passing data

06:11:18.058 --> 06:11:21.940
into the channel, we're actually going to
pass a copy of the data. So when we manipulate

06:11:21.940 --> 06:11:26.468
it afterwards, the receiving go routine doesn't
really care that we change the value of the

06:11:26.468 --> 06:11:31.270
variable, it's not affected by that at all.
Now another common use case for go routines

06:11:31.270 --> 06:11:36.308
is if you have data that's asynchronously
processed, so maybe you can generate the data

06:11:36.308 --> 06:11:41.578
very, very quickly, but it takes time to process
it. Or maybe it takes a long time to generate

06:11:41.578 --> 06:11:46.709
that data. So you've got multiple generators,
but it can be processed very quickly. So you

06:11:46.709 --> 06:11:50.728
might want to have a different number of go
routines that are sending data into a channel,

06:11:50.728 --> 06:11:55.260
then you have receiving. So let's take a look
at how we can do that. So it's a slight modification

06:11:55.260 --> 06:12:00.040
to the example that we just went through,
instead of just having the go routines fire

06:12:00.040 --> 06:12:04.610
once, I'm actually creating go routines inside
of this loop here. So I'm going to create

06:12:04.610 --> 06:12:08.530
five sets of go routines. So each one of the
groups is going to have a sender like we have

06:12:08.530 --> 06:12:12.670
here, which is exactly what we had before.
And then we're going to have a receiver, which

06:12:12.670 --> 06:12:16.731
is again, just like we had before. So by the
time the application is done, we're going

06:12:16.731 --> 06:12:22.180
to spawn 10 go routines here, five senders
and five receivers, and all of them are going

06:12:22.180 --> 06:12:26.978
to be using this single channel to communicate
their messages across. So if we go ahead and

06:12:26.978 --> 06:12:31.470
run this, we see that we do get five messages
received.

06:12:31.470 --> 06:12:36.430
Okay, so this works out really well, well,
but I will warn you, if you start playing

06:12:36.430 --> 06:12:40.340
around with this, and you decide to start
moving the senders and receivers to make them

06:12:40.340 --> 06:12:43.718
asymmetrical, things won't work very well.
So one of the things you might want to do

06:12:43.718 --> 06:12:49.398
to play with this example is take this go
routine, and move it outside of the for loop.

06:12:49.398 --> 06:12:54.138
So you're gonna have one receiver and multiple
senders at the end of this, well, that actually

06:12:54.138 --> 06:12:57.568
isn't going to work right now. Because if
you think about how this go routine is going

06:12:57.568 --> 06:13:01.540
to process, it's going to receive the message
coming in from the channel, it's going to

06:13:01.540 --> 06:13:04.860
print and then it's going to exit, but then
down here in the loop, we're actually going

06:13:04.860 --> 06:13:09.388
to spawn five messages into that channel.
So we can only receive one, but we're sending

06:13:09.388 --> 06:13:13.340
five. And if we run this, we're actually going
to run into a problem. And that is we see

06:13:13.340 --> 06:13:18.568
all routines are asleep, that we have a deadlock
condition. And the reason for that is because

06:13:18.568 --> 06:13:22.818
we have these go routines down here that are
trying to push messages into the channel.

06:13:22.818 --> 06:13:27.770
But there's nothing that can process them.
Now an important thing to keep in mind here

06:13:27.770 --> 06:13:33.128
is the reason that this is a deadlock. And
the reason for that is this line of code here

06:13:33.128 --> 06:13:39.500
is actually going to pause the execution of
this go routine right at this line until there's

06:13:39.500 --> 06:13:44.658
a space available in the channel. So by default,
we're working with unbuffered channels, which

06:13:44.658 --> 06:13:49.488
means only one message can be in the channel
at one time. So our first go routine in this

06:13:49.488 --> 06:13:54.600
loop gets happily spun up, it pushes a message
into the channel, and then it exits and then

06:13:54.600 --> 06:13:58.558
calls this done method on the weight group.
And then that message gets processed by this

06:13:58.558 --> 06:14:03.980
go routine here and everything's happy. However,
this go routine then exits. And then our next

06:14:03.980 --> 06:14:08.148
go routine comes along and tries to push another
message in. Well, it blocks right on this

06:14:08.148 --> 06:14:11.940
statement. And there's nothing in our application
that's going to receive that message. And

06:14:11.940 --> 06:14:16.320
that's why we see the go runtime. Notice that
and it's going to kill the application because

06:14:16.320 --> 06:14:20.701
it notices that we have a problem, and it
doesn't know how to resolve it. Now I want

06:14:20.701 --> 06:14:25.020
to go back to our previous example. And actually
I'm going to modify things slightly here.

06:14:25.020 --> 06:14:29.450
Because I want to show you that notice that
we're just working with the raw channel. So

06:14:29.450 --> 06:14:33.888
this is perfectly valid code for us to write.
As a matter of fact, if I go ahead and run

06:14:33.888 --> 06:14:39.128
this, we see that we get two messages printed
out but look at how that's happening. So this

06:14:39.128 --> 06:14:45.090
go routine is pushing a message into the channel.
That message is then being received up in

06:14:45.090 --> 06:14:50.978
this go routine and printed out this go routine
then the one that received this message is

06:14:50.978 --> 06:14:55.000
then putting a message back into the channel.
And that is then being received down here

06:14:55.000 --> 06:14:59.840
and this go routine, which is then printing
the message out. So both of these go routines

06:14:59.840 --> 06:15:05.280
are actually as readers and writers, now that
may be a situation that you want, but very

06:15:05.280 --> 06:15:10.100
often, you want to actually dedicate a go
routine to either reading from a channel or

06:15:10.100 --> 06:15:14.728
writing to a channel. So in order to do that,
what we're going to do is we're actually going

06:15:14.728 --> 06:15:19.030
to pass in the channel with a bias on the
direction that is going to be able to work

06:15:19.030 --> 06:15:23.830
with. So the way we're going to do that is
by accepting variables in our go routines.

06:15:23.830 --> 06:15:28.708
So we'll start with this first one here. And
we want this to be a receive only channel.

06:15:28.708 --> 06:15:33.170
So the way we're going to do that is we want
data to flow out of the channel. So you notice

06:15:33.170 --> 06:15:37.558
we're using that similar syntax, we're going
to list the type of the channel, and then

06:15:37.558 --> 06:15:41.728
we're going to have this arrow coming out
of it. So data is flowing out of the channel.

06:15:41.728 --> 06:15:46.260
And so this is going to be a receive only
channel. Similarly, if we want a send only

06:15:46.260 --> 06:15:51.260
channel, we're going to give it the variable
name, we're going to say that it's a channel,

06:15:51.260 --> 06:15:57.200
now we put the Send only operator right here,
and then we put the data type. So this is

06:15:57.200 --> 06:16:01.408
going to be sending data into the channel
only. And this is going to be receiving data

06:16:01.408 --> 06:16:06.498
from the channel. And then of course, we have
to pass the channel into the go routines as

06:16:06.498 --> 06:16:12.090
arguments. So when we run this, we're actually
going to get an error. And the reason we get

06:16:12.090 --> 06:16:16.360
an error is because we're trying to pass data
into this channel. But this is a receive only

06:16:16.360 --> 06:16:20.990
channel. So it's invalid to send data into
it. And then similarly, we have an error down

06:16:20.990 --> 06:16:25.828
here on line 21, because we're trying to receive
data from the Send only channel. So if we

06:16:25.828 --> 06:16:32.958
go ahead and wipe out these lines here, this
line, and this line, and run, then everything

06:16:32.958 --> 06:16:39.048
works as it did before. But now it's much
more clear what the data flow is in the go

06:16:39.048 --> 06:16:42.070
routine, we know that we're going to be receiving
data on one side, and we're going to be sending

06:16:42.070 --> 06:16:47.468
data on the other. Now something that's a
little unusual with this is notice that we're

06:16:47.468 --> 06:16:52.090
passing in a bi directional channel. So this
is just a normal channel, and we're receiving

06:16:52.090 --> 06:16:56.340
it a little bit differently. So this kind
of feels like a little bit of polymorphic

06:16:56.340 --> 06:17:01.978
behavior. And this is a special aspect of
channels, the runtime understands this syntax.

06:17:01.978 --> 06:17:06.378
And so it actually is going to, I'm going
to use the word cast here, it's going to cast

06:17:06.378 --> 06:17:11.248
this bi directional channel into a unidirectional
channel. But that's not something you can

06:17:11.248 --> 06:17:16.328
generally do in the go language. That is something
that is specific to channels. Now one of the

06:17:16.328 --> 06:17:21.610
problems we ran into on a previous example
is we had a situation where we tried to push

06:17:21.610 --> 06:17:26.340
five messages into a channel, but we only
had one receiver. And we noticed that the

06:17:26.340 --> 06:17:30.738
application deadlock, well, we can get around
that in a couple of different ways. Now I'm

06:17:30.738 --> 06:17:35.370
going to show you one way to get around that
that really is nice deal for solving that

06:17:35.370 --> 06:17:39.718
problem. But I will talk about the problem
that it is solving. And that is by using buffered

06:17:39.718 --> 06:17:44.728
channels. So if I go ahead and paste in this
example, here, we will see an example of the

06:17:44.728 --> 06:17:48.430
problem we might run into. I've simplified
it a little bit from the previous example

06:17:48.430 --> 06:17:53.000
we ran into. So we've got our initial example
where we've got a receive only go routine,

06:17:53.000 --> 06:17:57.430
we've got a send only go routine. But in our
send go routine, we're actually sending two

06:17:57.430 --> 06:18:02.708
messages. But since we're only receiving one,
we expect that we're going to run into a problem.

06:18:02.708 --> 06:18:06.540
So let's go ahead and run this. And we see
that we do in fact have a problem, we received

06:18:06.540 --> 06:18:10.540
the 42 out and printed it. But there's nothing
to deal with this message here that's in the

06:18:10.540 --> 06:18:16.110
channel. And so the application blows up,
because this go routine can never complete,

06:18:16.110 --> 06:18:21.740
because it's blocked on this line. So we need
a way to get around that. Now a simple way

06:18:21.740 --> 06:18:28.340
to get around that is by simply adding a buffer
here. So if we add a second parameter to the

06:18:28.340 --> 06:18:33.700
make function up here, and provide an integer,
that's actually going to tell go to create

06:18:33.700 --> 06:18:39.610
a channel that's got an internal data store
that can store in this case, 50 integers.

06:18:39.610 --> 06:18:44.048
Now what that's going to do is it's actually
going to allow our application to complete.

06:18:44.048 --> 06:18:48.738
But we do have a little bit of a problem here
because this message is lost. So it did eliminate

06:18:48.738 --> 06:18:52.638
the panic. And I guess in one way, you could
say it solved the problem. But it did create

06:18:52.638 --> 06:18:57.440
another problem in that we lost this message.
Now this isn't the problem that buffer channels

06:18:57.440 --> 06:19:02.468
are really intended to solve. But I do want
to show you that it does create that internal

06:19:02.468 --> 06:19:06.638
store, so we can receive multiple messages
back out. As a matter of fact, what we can

06:19:06.638 --> 06:19:12.208
do is we can just copy this line down here
and reformat this, and we don't need this

06:19:12.208 --> 06:19:17.128
column right here. And if we run this, we
see that we do get both messages printed back

06:19:17.128 --> 06:19:23.968
out. Now what a buffered channel is really
designed to do is if the sender or the receiver

06:19:23.968 --> 06:19:30.148
operate at a different frequency than the
other side. So you can imagine if we had a

06:19:30.148 --> 06:19:36.510
data acquisition system, and maybe we retrieve
data from our sensors, and a burst transmission,

06:19:36.510 --> 06:19:41.798
so maybe we're acquiring data from seismometers,
and we're monitoring earthquakes, well, maybe

06:19:41.798 --> 06:19:47.100
those seismometers in order to conserve power,
don't send their data continuously, they're

06:19:47.100 --> 06:19:50.968
going to send a burst transmission, maybe
once an hour. So every hour, we're going to

06:19:50.968 --> 06:19:55.048
get a burst transmission that maybe last five
or six seconds, that's going to contain the

06:19:55.048 --> 06:20:01.950
entire hours worth of data. So in that case,
our sender is going to be inundated with data

06:20:01.950 --> 06:20:06.808
when that burst happens. And it's going to
have to have a way to deal with it, one of

06:20:06.808 --> 06:20:11.309
the receivers might take a little while to
process that data. So in that case, what we

06:20:11.309 --> 06:20:16.238
might want to do is create a buffer here of
these signals that are coming in from our

06:20:16.238 --> 06:20:20.748
seismometer, that's going to be able to accept
that one hours worth of data. And then our

06:20:20.748 --> 06:20:25.930
receivers can pull that data off, as they're
able to process it, and keep things working

06:20:25.930 --> 06:20:31.168
smoothly, so that the channel that's receiving
the data from our sensors, doesn't get locked

06:20:31.168 --> 06:20:35.218
up, because it doesn't have a place to put
the next message. So that's really what buffered

06:20:35.218 --> 06:20:39.930
go routines are designed to work with, is
when your sender or your receiver needs a

06:20:39.930 --> 06:20:44.620
little bit more time to process. And so you
don't want to block the other side, because

06:20:44.620 --> 06:20:48.530
you have a little bit of a delay there. Now
if this isn't the right way to handle this

06:20:48.530 --> 06:20:53.378
situation, what is the right way? Well, the
way that we typically handle something that's

06:20:53.378 --> 06:20:57.298
going to happen multiple times, such as passing
a message into a channel, is by using some

06:20:57.298 --> 06:21:01.328
kind of a looping construct. And that's no
different with channels as is with anything

06:21:01.328 --> 06:21:07.318
else. So let's paste in this example, where
I instead of processing the message once and

06:21:07.318 --> 06:21:12.340
then having this first go routine exit, I'm
actually going to use a for range loop. But

06:21:12.340 --> 06:21:13.930
notice what I'm arranging over,

06:21:13.930 --> 06:21:18.360
instead of ranging over some kind of a collection,
such as an array, a slice or a map, I'm actually

06:21:18.360 --> 06:21:23.770
ranging over the channel. Now the syntax changes
just a little bit. Because if this were a

06:21:23.770 --> 06:21:29.900
slice, the first index that we pull back is
going to be the index in the slice. And then

06:21:29.900 --> 06:21:33.898
the second variable we pulled out, if we had,
for example, a second variable here would

06:21:33.898 --> 06:21:38.030
be the value. Well, when you're arranging
over a channel, things are a little bit different.

06:21:38.030 --> 06:21:41.168
When you pull a single value, you're actually
going to get the value that's coming out of

06:21:41.168 --> 06:21:48.540
the channel. And so if we run this, we see
that we do in fact get 42 and 27. But we still

06:21:48.540 --> 06:21:53.530
have a deadlock condition. So what's causing
that deadlock condition? Well, before we had

06:21:53.530 --> 06:21:58.578
this four range loop, we actually deadlocked
this go routine right here, and everything

06:21:58.578 --> 06:22:03.878
died. We're in our new application, we're
actually deadlocking in the four range loop.

06:22:03.878 --> 06:22:08.790
And the reason for that is because we're continuing
to monitor for additional messages, but we

06:22:08.790 --> 06:22:13.638
stopped sending messages. And so now this
four range loop doesn't know how to exit.

06:22:13.638 --> 06:22:18.030
And so this go routine is now causing the
deadlock condition. So we've improved the

06:22:18.030 --> 06:22:22.040
situation, we kind of move the needle where
we're no longer dead locking in our sender,

06:22:22.040 --> 06:22:26.821
but we are still dead locking in our receiver.
So how do we handle that? Well, the way that

06:22:26.821 --> 06:22:32.071
we're going to handle that is we have to understand
how the four range loop works. So if you're

06:22:32.071 --> 06:22:37.588
using a for range, loop over a slice, how
many times does that iterate? Well, it executes

06:22:37.588 --> 06:22:41.950
the loop once for every item in the slice.
So if you've got a slice with five elements

06:22:41.950 --> 06:22:45.828
in it, you're going to run through the four
range loop five times, well, how many elements

06:22:45.828 --> 06:22:50.498
are in a channel? Well, there can be an infinite
number of elements in a channel because you

06:22:50.498 --> 06:22:55.040
can constantly push a new message into it.
So what is the way to signal a four range

06:22:55.040 --> 06:22:59.940
loop with a channel that there are no more
messages coming? Well, the answer is we need

06:22:59.940 --> 06:23:03.899
to close the channel. So anything that has
access to the channel can do this, we're going

06:23:03.899 --> 06:23:08.328
to use the built in close function. And we're
going to pass in the channel like you see

06:23:08.328 --> 06:23:12.838
here. So what we're doing on our sending side
is we're passing in two messages, we're passing

06:23:12.838 --> 06:23:18.298
in 42, and 27. And then we're letting the
channel know we're done working with you.

06:23:18.298 --> 06:23:23.048
So we're going to go ahead and close the channel,
this four range loop is going to detect that.

06:23:23.048 --> 06:23:27.898
And when we run this, now everything runs
well, because we're passing in the message

06:23:27.898 --> 06:23:33.208
42, that gets processed in the for loop, we're
passing in 27, that gets processed, then we

06:23:33.208 --> 06:23:37.950
close the channel, that gets processed by
the for range loop, which notices that the

06:23:37.950 --> 06:23:42.340
channel is closed, and it's going to exit
and it's going to terminate the loop. So when

06:23:42.340 --> 06:23:46.248
we terminate the loop, then we call the done
method on the weight group. And then we exit

06:23:46.248 --> 06:23:50.200
the go routine, all of our go routines exit
properly, and we have no more

06:23:50.200 --> 06:23:51.200
deadlocks.

06:23:51.200 --> 06:23:54.378
Now we do have to be a little bit careful
in closing channels, because when you close

06:23:54.378 --> 06:23:59.200
a channel, you really have to mean that you're
closing the channel down. So let's try closing

06:23:59.200 --> 06:24:04.058
the channel right here and then pushing another
message into it. So if we run this, we actually

06:24:04.058 --> 06:24:09.850
get a bad thing happening. So in this case,
the application panicked. And why did it panic,

06:24:09.850 --> 06:24:14.680
because we tried to send a message on a closed
channel. So the issue here is we close the

06:24:14.680 --> 06:24:19.228
channel right here on line 21. And then on
line 22, we tried to pass another message

06:24:19.228 --> 06:24:24.218
into it. So that is a no, no, you are not
allowed to pass a message into a closed channel

06:24:24.218 --> 06:24:28.388
because the channel is closed. So you might
ask, Well, how do I recover from this? How

06:24:28.388 --> 06:24:34.890
do I reopen the channel or undo that or whatever?
And the answer is, you can't. As a matter

06:24:34.890 --> 06:24:40.870
of fact, you can't even detect if a channel
is closed, except for by looking for the application

06:24:40.870 --> 06:24:46.170
panicking. So call that a limitation of the
go language or not, I don't know. But you

06:24:46.170 --> 06:24:49.968
do have to be very careful that when you close
a channel, nothing else is going to send a

06:24:49.968 --> 06:24:55.350
message into it. So if that is a possibility,
then the only option you really have is to

06:24:55.350 --> 06:25:00.128
have a deferred function and use a recover
in there to recover from the panic that gets

06:25:00.128 --> 06:25:04.208
thrown because in this situation, you will
have a panic and there is no way to avoid

06:25:04.208 --> 06:25:08.828
it. So if in your application, that's a situation
that's likely to happen, then again, you're

06:25:08.828 --> 06:25:12.360
going to have to use that recover function.
And you can review the video where I talked

06:25:12.360 --> 06:25:17.398
about using those. Now on the receiving side,
we do have a little bit of a different story

06:25:17.398 --> 06:25:21.180
here, because this issue is on the closing
side. So we cannot send the message into a

06:25:21.180 --> 06:25:25.600
closed channel. And we can't detect if a channel
is closed before we try and send a message

06:25:25.600 --> 06:25:31.350
into it. However, if we go on the receiving
side, then the story gets a little bit brighter.

06:25:31.350 --> 06:25:35.708
So you might ask the question, how does the
four range loop know that the channel is closed,

06:25:35.708 --> 06:25:41.430
it has to have some way of detecting it, what
turns out that there's more than one parameter

06:25:41.430 --> 06:25:46.238
that you can pull back from the channel. So
just like when we're querying maps, and we're

06:25:46.238 --> 06:25:51.170
trying to get a value out of a map, and we
can use that comma, okay, syntax, well, that

06:25:51.170 --> 06:25:56.190
syntax works for channels as well. So if I
change this example up a little bit, and this

06:25:56.190 --> 06:26:01.048
is going to do exactly the same thing as our
current example, here using a four range loop,

06:26:01.048 --> 06:26:04.958
but instead of using the four range loop,
and having go automatically processed the

06:26:04.958 --> 06:26:09.568
closed channel for us, we're going to process
this manually. So let me paste in this example

06:26:09.568 --> 06:26:14.498
and show you so notice that I'm in a for loop
in this go routine, and I don't have any conditions

06:26:14.498 --> 06:26:19.228
on it. So this is going to execute forever.
Down here, then I'm receiving a message from

06:26:19.228 --> 06:26:24.110
the channel, and I'm using the comma. Okay,
syntax. So I'm going to get the value from

06:26:24.110 --> 06:26:28.568
the channel and I and I'm going to get a Boolean
letting me know if the channels open or not

06:26:28.568 --> 06:26:33.180
in the okay variable. So if the channel is
open, then okay is going to be true. If the

06:26:33.180 --> 06:26:37.240
channel is closed, then Okay, it's going to
be false. So the happy path, if okay is true,

06:26:37.240 --> 06:26:41.398
then I'm going to go ahead and print out my
message. Otherwise, I'm going to break out

06:26:41.398 --> 06:26:45.450
of this for loop here, because the channels
closed, and I'm not going to be receiving

06:26:45.450 --> 06:26:51.680
any more messages from it. So this is functionally
exactly the same as the four range construct.

06:26:51.680 --> 06:26:56.510
But we're explicitly seeing this comma, okay,
syntax. So which one would you use?

06:26:56.510 --> 06:27:00.680
Well, in this situation, it would make more
sense to use the for range construct. But

06:27:00.680 --> 06:27:05.760
there may be situations where you're receiving
data from a channel, and you're not in a loop.

06:27:05.760 --> 06:27:09.940
So maybe you're spinning off a new go routine
for every time you're processing a message.

06:27:09.940 --> 06:27:14.308
And so the loop is going to contain the spinning
off of the go routines. And so you're going

06:27:14.308 --> 06:27:18.128
to need this comma, okay syntax, because it
might not make sense to use the for range

06:27:18.128 --> 06:27:22.978
loop. Now, the last thing that I want to talk
about in this video are what are called SELECT

06:27:22.978 --> 06:27:28.010
statements. So let me go ahead and paste in
this code here. So we talked about in the

06:27:28.010 --> 06:27:33.248
last video, how there can be situations where
you create go routines that don't have an

06:27:33.248 --> 06:27:37.320
obvious way to close. And that's what I want
to try and illustrate here. So if I go ahead

06:27:37.320 --> 06:27:42.048
and run this, we see that we do get these
messages printed out. So I'm just doing a

06:27:42.048 --> 06:27:47.510
simple logger implementation. So what you
see here is I've got some constants that are

06:27:47.510 --> 06:27:51.658
declaring my log level, I've got a struct
that I've declared the holding the timestamp

06:27:51.658 --> 06:27:55.668
for the login tree, the severity of the log
level, and then whatever message I'm trying

06:27:55.668 --> 06:28:00.450
to print out, then I'm creating a log channel.
And the way this application works, is the

06:28:00.450 --> 06:28:03.940
first thing the main function does is it spins
up this go routine, that's going to be my

06:28:03.940 --> 06:28:09.030
logger. And what it's going to do is it's
simply going to monitor that log channel for

06:28:09.030 --> 06:28:13.270
log entries that are coming from throughout
my application. So the idea is I've got a

06:28:13.270 --> 06:28:17.168
central logger, and anything that could do
logging in, my application just needs to know

06:28:17.168 --> 06:28:21.370
about this channel. And all of my logging
logic can be hidden within the processing

06:28:21.370 --> 06:28:26.488
of those log channel messages. So the logger
is down here, we've got a four range loop

06:28:26.488 --> 06:28:30.190
that's listening for messages from the log
channel. And all it's doing is it's printing

06:28:30.190 --> 06:28:35.200
out a formatted message that's got the timestamp,
it's got the log level, and it's got the message

06:28:35.200 --> 06:28:40.410
from the log. So no big deal here, nothing
terribly exciting. Then my main function goes

06:28:40.410 --> 06:28:45.200
on to exercise that a little bit, it sends
two messages into the log channel, one letting

06:28:45.200 --> 06:28:48.490
it know that the application is starting another
one letting the application note shutting

06:28:48.490 --> 06:28:52.850
down. And then I've got a sleep call here
just to make sure that the logger co routine

06:28:52.850 --> 06:28:57.540
has enough time to process that. Now you notice
my timestamps are a little funny here. That's

06:28:57.540 --> 06:29:01.568
because I'm working with the playground, I
promise you this code does work. If you shifted

06:29:01.568 --> 06:29:05.958
over to Visual Studio code, you will actually
get real timestamps. But for some reason,

06:29:05.958 --> 06:29:10.200
the playground doesn't give you the current
time when you call the now function. And so

06:29:10.200 --> 06:29:13.620
this is just something that we're going to
have to work with in this example. Now the

06:29:13.620 --> 06:29:20.600
problem I want you to consider is when does
the logger go routine closed down. So obviously,

06:29:20.600 --> 06:29:24.898
the logger go routine has to terminate sometime
because the program finishes execution, and

06:29:24.898 --> 06:29:30.370
we get the results back from the playground.
So what's happening here is remember, an application

06:29:30.370 --> 06:29:37.020
is shut down as soon as the last statement
of the main function finishes execution. So

06:29:37.020 --> 06:29:43.218
when we finish this sleep call here, the application
terminates and everything is torn down and

06:29:43.218 --> 06:29:49.100
all resources are reclaimed as the go runtime
returns all of the resources that it was using

06:29:49.100 --> 06:29:54.238
back to the operating system. So what that
means is that our logger go routine is being

06:29:54.238 --> 06:29:59.208
torn down forcibly. There's no graceful shutdown
for this go routine. It's just being ripped

06:29:59.208 --> 06:30:03.520
out because the main function has done. Now
in some situations like this one that may

06:30:03.520 --> 06:30:07.920
be acceptable. But there are many situations
where you want to have much more control over

06:30:07.920 --> 06:30:12.738
a go routine. Because remember what I said
in the go routine video, you should always

06:30:12.738 --> 06:30:16.930
have a strategy for how your go routine is
going to shut down when you create your go

06:30:16.930 --> 06:30:22.280
routine. Otherwise, it can be a subtle resource
leak, and eventually, it can leak enough resources

06:30:22.280 --> 06:30:25.729
that it can bring your application down. So
there's a couple of different things we could

06:30:25.729 --> 06:30:31.010
do here, right, we could of course, do a defer
call here, we can pass in an anonymous function.

06:30:31.010 --> 06:30:35.750
And inside of that, we could go ahead and
close the log channel. So what that's going

06:30:35.750 --> 06:30:40.248
to do is when the main function exits, it's
going to go ahead and close the channel, and

06:30:40.248 --> 06:30:43.680
then we are gracefully shutting down that
channel. And that works just fine. There's

06:30:43.680 --> 06:30:48.730
no issues with that we are intentionally closing
down the channel, we know how our go routine

06:30:48.730 --> 06:30:54.120
is going to close. And so this is perfectly
acceptable in this use case. But this isn't

06:30:54.120 --> 06:30:57.530
what I want to show you. So this is certainly
something you could use in this use case.

06:30:57.530 --> 06:31:02.190
But I want to show you another way that very
commonly used in these kinds of situations.

06:31:02.190 --> 06:31:06.708
So the way that I want to show you is using
what's called a select statement. So let me

06:31:06.708 --> 06:31:10.600
go ahead and paste in that code. And we'll
walk through that. So the application

06:31:10.600 --> 06:31:14.530
is basically the same, I've got the same constants
have here, I've got the same struct, I do

06:31:14.530 --> 06:31:19.378
have this additional channel here. And notice
the type signature for it. So it's strongly

06:31:19.378 --> 06:31:24.180
typed, but it's strongly typed to a struct
with no fields. Now struct with no fields

06:31:24.180 --> 06:31:29.828
in the go language is unique in that it requires
zero memory allocations. So a lot of times

06:31:29.828 --> 06:31:35.290
you will see a channel set up like this. And
the intention is it can send any data through

06:31:35.290 --> 06:31:41.338
except for the fact that a message was sent
or received. So this is what's called a signal

06:31:41.338 --> 06:31:46.558
only channel. There's zero memory allocations
required in sending the message. But we do

06:31:46.558 --> 06:31:52.310
have the ability to just let the receiving
side know that a message was sent. So this

06:31:52.310 --> 06:31:56.818
is pretty common, you might be tempted if
you're new to the language, like I first did

06:31:56.818 --> 06:32:01.870
you send a Boolean in here. But that does
actually require a variable to be allocated

06:32:01.870 --> 06:32:06.430
and copied. So it is actually better to use
an empty struct because it saves a couple

06:32:06.430 --> 06:32:10.370
of memory allocations. It's a little bit minor.
But it is something that if you are going

06:32:10.370 --> 06:32:14.280
to use a channel as a pure message, then you
might as well go with the conventions and

06:32:14.280 --> 06:32:18.270
use this approach. So our main function is
exactly the same as it was before. We've got

06:32:18.270 --> 06:32:22.750
our logger, we've got our log channel, sending
in a couple of messages. And then we got a

06:32:22.750 --> 06:32:27.838
sleep call here. And then inside of our logger
function, we've got an infinite loop now,

06:32:27.838 --> 06:32:33.350
and we're using this select block. So what
this SELECT statement does is the entire statement

06:32:33.350 --> 06:32:38.388
is going to block until a message is received
on one of the channels that it's listening

06:32:38.388 --> 06:32:42.870
for. So in this case, we've got a case listening
for messages from the log channel, and the

06:32:42.870 --> 06:32:47.180
case listening for messages from the done
channel. So if we get a message from the log

06:32:47.180 --> 06:32:50.738
channel, then we're going to print out our
log entry. If we get a message from the done

06:32:50.738 --> 06:32:55.010
channel, then we're going to go ahead and
break out of this for loop. So what this allows

06:32:55.010 --> 06:33:01.270
us to do is at the end of our application,
we can go ahead and pass in a message into

06:33:01.270 --> 06:33:07.148
our dumb channel. And that is going to be
an empty struct. And I'm just going to define

06:33:07.148 --> 06:33:11.998
that empty struct on the fly here. So this
is a little bit confusing syntax. But this

06:33:11.998 --> 06:33:16.040
is the type signature for my struct. So I'm
defining a struct with no fields. And then

06:33:16.040 --> 06:33:20.850
I'm initializing that struct using these curly
braces here. So if I go ahead and run this,

06:33:20.850 --> 06:33:25.548
you see that the application runs properly.
So I do process my log messages. And then

06:33:25.548 --> 06:33:30.920
I pass in this message into my done channel
when I wish the logger to shut down. So this

06:33:30.920 --> 06:33:36.160
is a common situation for you to use when
you're monitoring channels. And you need a

06:33:36.160 --> 06:33:40.860
way to have the go routine that's monitoring
those handles be able to terminate. So very

06:33:40.860 --> 06:33:44.520
often you're going to send in normally as
a parameter, you're going to send in this

06:33:44.520 --> 06:33:48.568
done channel. And then whatever's ready to
kill the go routine, will go ahead and send

06:33:48.568 --> 06:33:53.110
a message into that done channel. And it'll
go ahead and kill it. Now one more thing that

06:33:53.110 --> 06:33:56.690
I do want to talk about. And I'm not going
to actually run it because it's going to break

06:33:56.690 --> 06:34:02.760
our application here. But you can have a default
case here. And if you do, then this no longer

06:34:02.760 --> 06:34:07.370
becomes a blocking SELECT statement. So what
this is going to do is if there's a message

06:34:07.370 --> 06:34:11.058
ready on one of the channels that are being
monitored, then it's going to execute that

06:34:11.058 --> 06:34:16.430
code path. If not, it will execute a default
block. So this is useful. If you want to have

06:34:16.430 --> 06:34:20.770
a non blocking SELECT statement, then you
need to have that default case in there. If

06:34:20.770 --> 06:34:24.940
you don't have the default case, then the
select statement will block forever until

06:34:24.940 --> 06:34:28.738
a message does come in. Okay, so that's what
I have to talk about with channels. Let's

06:34:28.738 --> 06:34:33.690
go into a summary and review what we've talked
about. In this video, we talked about channels

06:34:33.690 --> 06:34:39.208
and how we can use them to synchronize data
transmission between go routines. We started

06:34:39.208 --> 06:34:42.458
out by talking about the basics of working
with channels. And we learned that we can

06:34:42.458 --> 06:34:46.888
make our channels using the built in make
function and how that's really the only way

06:34:46.888 --> 06:34:51.350
that we have available in the go routine to
make a channel. When we do make those channels,

06:34:51.350 --> 06:34:55.270
those channels are strongly typed. So we're
going to use the chain keyword to indicate

06:34:55.270 --> 06:34:59.088
that we wish to create a channel and then
we have to follow that with the data type

06:34:59.088 --> 06:35:03.100
that the channel is going to be Send and Receive.
Now that data type can be anything, it can

06:35:03.100 --> 06:35:07.530
be a primitive like we see here with an integer,
it can be a struct, it can be an interface.

06:35:07.530 --> 06:35:11.798
But it does have to be strongly typed, we
can send a message into the channel using

06:35:11.798 --> 06:35:16.548
this arrow syntax. And the position of the
arrow kind of indicates the direction that

06:35:16.548 --> 06:35:20.510
the data is going to flow. So in this case,
we list channel, we have the arrow and then

06:35:20.510 --> 06:35:24.760
the value that we wish to send into the channel.
So notice that the arrow is pointing into

06:35:24.760 --> 06:35:29.548
the channel. But when we went to receive messages
from the channel, then the arrow is leading

06:35:29.548 --> 06:35:33.578
out of the channel. And so we're going to
use the same arrow syntax, but the channel

06:35:33.578 --> 06:35:38.250
is going to be added after the arrow instead
of before. And we can have multiple senders

06:35:38.250 --> 06:35:42.298
and receivers. As a matter of fact, it's very
common. As a matter of fact, it's very common

06:35:42.298 --> 06:35:47.920
for one channel to be distributed among multiple
go routines. And that way, you can have multiple

06:35:47.920 --> 06:35:52.628
data generators that are sending messages
into the channel, as well as multiple data

06:35:52.628 --> 06:35:57.290
receivers. And that allows you to balance
the performance between senders and receivers.

06:35:57.290 --> 06:36:01.510
So if you can generate data 10 times as fast
as you can process it, then you can create

06:36:01.510 --> 06:36:06.138
10 times as many receivers. And that way you
can balance the workload out between senders

06:36:06.138 --> 06:36:07.208
and receivers.

06:36:07.208 --> 06:36:12.898
We then talked about how to restrict data
flow. Buying default, channels are bi directional

06:36:12.898 --> 06:36:17.770
constructs, so you can send and receive data
into a channel. Now very often what we want,

06:36:17.770 --> 06:36:23.398
though, is our go routines to be designed
to handle channel data only in one direction.

06:36:23.398 --> 06:36:29.128
So we saw that we can do that by passing in
the channel. But then on the receiving side.

06:36:29.128 --> 06:36:33.378
So for example, in the argument list of the
function, we can actually specify the direction

06:36:33.378 --> 06:36:38.540
that we can work with by again adding that
arrow, and we either add it before or after

06:36:38.540 --> 06:36:41.790
the chain keyword. Depending on what kind
of channel that we want to make, we can make

06:36:41.790 --> 06:36:46.218
a send only channel by putting the arrow after
the chain keyword, and we can make a receive

06:36:46.218 --> 06:36:50.930
only channel by adding the arrow before it.
We then talk about buffered channels, and

06:36:50.930 --> 06:36:56.190
how buffered channels contain internal data
stores that allow us to get around this limitation

06:36:56.190 --> 06:37:01.158
of channels that by default, a channel will
block the sender side until a receiver is

06:37:01.158 --> 06:37:05.888
available, and the receiver side will be blocked
until a message is available to come out of

06:37:05.888 --> 06:37:09.830
the channel. So you can actually block a go
routine on the sending side or the receiving

06:37:09.830 --> 06:37:14.490
side of the channel. So if there's no position
available in the channel to add the message,

06:37:14.490 --> 06:37:18.270
then the sending side will be blocked until
a space does become available. And if there's

06:37:18.270 --> 06:37:22.548
no message in the channel, then the receiving
side is going to be blocked until a message

06:37:22.548 --> 06:37:28.468
becomes available for it to work with. So
in order to decouple that we can add an integer

06:37:28.468 --> 06:37:32.270
as a second argument to the main function.
And that's going to allow the channel to have

06:37:32.270 --> 06:37:37.158
an internal buffer to decouple your senders
and receivers, just in case there are situations

06:37:37.158 --> 06:37:41.968
where data is generated faster than it's received.
So just like it says here, we want to use

06:37:41.968 --> 06:37:46.248
buffered channels when sending and receiving
have asymmetric loading. So if we can generate

06:37:46.248 --> 06:37:50.110
messages faster than we can receive them,
then a lot of times a buffered channel is

06:37:50.110 --> 06:37:54.780
a really good way to go. We then moved on
to talk about four range loops, and specifically

06:37:54.780 --> 06:37:58.128
how to work with them with channels. And we
learned that they basically work the same

06:37:58.128 --> 06:38:03.318
way. But there are a couple of subtle differences.
The first thing is the first parameter that

06:38:03.318 --> 06:38:07.430
you're going to receive from the four range
loop when working with channels is the value

06:38:07.430 --> 06:38:12.260
itself, not the index, like we saw when we
were using for range loops over arrays, slices

06:38:12.260 --> 06:38:17.408
and maps. And we saw how we can use for range
loops to monitor channel and process messages

06:38:17.408 --> 06:38:21.418
as they arrive. So the four range loop is
just going to keep pulling messages as they

06:38:21.418 --> 06:38:26.040
come in off the channel. And it'll process
them as they come. Then when the channel gets

06:38:26.040 --> 06:38:30.280
closed, the four range loop is going to detect
that and it will go ahead and exit the loop.

06:38:30.280 --> 06:38:35.000
And finally, we talked about SELECT statements,
and how they work kinda like switch statements,

06:38:35.000 --> 06:38:39.510
but they work only in the context of channels,
and how they allow a go routine to monitor

06:38:39.510 --> 06:38:44.578
several channels at the same time. Now if
they block if all channels are blocked, so

06:38:44.578 --> 06:38:49.388
if there's no messages available on any channel,
then the select statement will block by default.

06:38:49.388 --> 06:38:53.870
And then when a message comes in, it will
go ahead and process that on the proper case.

06:38:53.870 --> 06:38:59.158
If multiple channels receive value simultaneously,
then the behavior is actually undefined. So

06:38:59.158 --> 06:39:03.908
because of the highly parallel nature of many
go applications, you can get into situations

06:39:03.908 --> 06:39:08.790
where messages arrive on two channels at virtually
the same time. So one of those cases will

06:39:08.790 --> 06:39:12.458
get the nod from the Select block, but you
can't be sure of which one's going to get

06:39:12.458 --> 06:39:16.450
it. So there is no rule like in switch block
where the first one that matches is going

06:39:16.450 --> 06:39:21.208
to get it, it could be anyone. So the ordering
of the cases in your SELECT statements really

06:39:21.208 --> 06:39:25.248
doesn't matter from the standpoint of how
those conflicts are going to get resolved.

06:39:25.248 --> 06:39:30.228
Now if you do want a non blocking SELECT statement,
remember that you can add that default case

06:39:30.228 --> 06:39:35.058
in there. So if there are no messages on any
of the monitored channels, then the default

06:39:35.058 --> 06:39:39.638
case will go ahead and fire and so the select
statement will process and execution of the

06:39:39.638 --> 06:39:41.600
go routine will continue from there.

06:39:41.600 --> 06:39:42.600
Okay,

06:39:42.600 --> 06:39:45.908
so that wraps up what I have to talk about
with channels. And really it brings us to

06:39:45.908 --> 06:39:51.078
the end of the discussion that I have for
this introduction to go series for now. This

06:39:51.078 --> 06:39:53.850
is Mike vansickle wishing you luck in all
of your gopher endeavors.

06:39:53.850 --> 06:39:53.898
Take care

